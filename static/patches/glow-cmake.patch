diff --git a/CMakeLists.txt b/CMakeLists.txt
index a1fc09ac..e7982ef2 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -97,7 +97,6 @@ if(GLOW_USE_LLD)
 endif()
 
 include(Glog)
-include(Gflags)
 include(GlowDefaults)
 include(GlowTestSupport)
 include(GlowExternalBackends)
@@ -181,6 +180,8 @@ endif()
 
 # CPU backend, GlowAPI & apitest depend on nlohmann_json
 find_package(nlohmann_json REQUIRED)
+find_package(fmt REQUIRED)
+find_package(Gflags REQUIRED)
 
 if(GLOW_WITH_LLVMIRCODEGEN)
   add_definitions(-DGLOW_WITH_LLVMIRCODEGEN=1)
@@ -253,7 +254,7 @@ endif ()
 # Top level setup for external backends
 ExternalBackendsInit()
 
-find_package(LLVM CONFIG)
+find_package(LLVM REQUIRED)
 if(NOT LLVM_FOUND OR LLVM_VERSION VERSION_LESS 7.0)
   message(SEND_ERROR "LLVM >= 7.0 is required to build Glow")
 endif()
@@ -266,8 +267,8 @@ if (BUILD_SHARED_LIBS AND TARGET LLVM AND NOT TARGET LLVM::LLVM)
   # LLVM does not define the LLVM::LLVM alias. Unfortunately Conan can only link through LLVM::LLVM
   # Here we create a fake library to be able to use LLVM::LLVM outside of Conan through LLVM is an
   # imported library and does not allow defining an alias
-  add_library(LLVM::LLVM INTERFACE IMPORTED)
-  set_target_properties(LLVM::LLVM PROPERTIES INTERFACE_LINK_LIBRARIES LLVM)
+  #add_library(LLVM::LLVM INTERFACE IMPORTED)
+  #set_target_properties(LLVM::LLVM PROPERTIES INTERFACE_LINK_LIBRARIES LLVM)
 endif()
 
 if (GLOW_BUILD_PYTORCH_INTEGRATION)
@@ -421,7 +422,7 @@ endif()
 
 if ("${folly_PROVIDER}" STREQUAL "find_package")
   message(STATUS "Find folly with find_package")
-  find_package(folly REQUIRED)
+  find_package(folly CONFIG REQUIRED)
 else()
   if(NOT EXISTS "${GLOW_THIRDPARTY_DIR}/folly/folly")
     message(FATAL_ERROR "No folly git submodule. Run: git submodule update --init --recursive")
@@ -480,10 +481,14 @@ target_include_directories(tflite INTERFACE $<BUILD_INTERFACE:${GLOW_THIRDPARTY_
 
 # LLVM dependencies for single shared library and component static libraries
 if(BUILD_SHARED_LIBS)
-  list(APPEND LLVM_CORE_LIBS LLVM::LLVM)
-  list(APPEND LLVM_IR_LIBS LLVM::LLVM)
-  list(APPEND LLVM_JIT_LIBS LLVM::LLVM)
-  list(APPEND LLVM_SUPPORT_LIBS LLVM::LLVM)
+  llvm_map_components_to_libnames(llvm_core_libs core)
+  llvm_map_components_to_libnames(llvm_ir_libs all)
+  llvm_map_components_to_libnames(llvm_jit_libs orcjit)
+  llvm_map_components_to_libnames(llvm_support_libs support)
+  list(APPEND LLVM_CORE_LIBS ${llvm_core_libs})
+  list(APPEND LLVM_IR_LIBS ${llvm_ir_libs})
+  list(APPEND LLVM_JIT_LIBS ${llvm_jit_libs})
+  list(APPEND LLVM_SUPPORT_LIBS ${llvm_support_libs})
 else()
   list(APPEND LLVM_CORE_LIBS LLVMCore)
   list(APPEND LLVM_IR_LIBS
diff --git a/cmake/modules/Gflags.cmake b/cmake/modules/Gflags.cmake
deleted file mode 100644
index b1827ae8..00000000
--- a/cmake/modules/Gflags.cmake
+++ /dev/null
@@ -1,91 +0,0 @@
-# ---[ gflags
-# Stole from https://github.com/pytorch/pytorch/blob/45c9ed825a51c05395fd28b376271324e0315d0c/cmake/public/gflags.cmake
-
-# We will try to use the config mode first, and then manual find.
-set(GFLAGS_USE_TARGET_NAMESPACE TRUE)
-find_package(gflags CONFIG QUIET)
-if((NOT TARGET gflags) OR (NOT TARGET gflags::gflags))
-  find_package(gflags MODULE QUIET)
-endif()
-
-if (TARGET gflags::gflags)
-  message(STATUS "Glow: Found gflags with new-style gflags::gflags target.")
-elseif(TARGET gflags)
-  message(STATUS "Glow: Found gflags with new-style gflags target.")
-  add_library(gflags::gflags ALIAS gflags)
-elseif(GFLAGS_FOUND)
-  message(STATUS "Glow: Found gflags with old-style gflag starget.")
-  add_library(gflags UNKNOWN IMPORTED)
-  set_property(
-      TARGET gflags PROPERTY IMPORTED_LOCATION ${GFLAGS_LIBRARY})
-  set_property(
-      TARGET gflags PROPERTY INTERFACE_INCLUDE_DIRECTORIES
-      ${GFLAGS_INCLUDE_DIR})
-  add_library(gflags::gflags ALIAS gflags)
-else()
-  message(STATUS
-      "Glow: Cannot find gflags automatically. Using legacy find.")
-
-  # - Try to find GFLAGS in the legacy way.
-  #
-  # The following variables are optionally searched for defaults
-  #  GFLAGS_ROOT_DIR: Base directory where all GFLAGS components are found
-  #
-  # The following are set after configuration is done:
-  #  GFLAGS_FOUND
-  #  GFLAGS_INCLUDE_DIRS
-  #  GFLAGS_LIBRARIES
-  #  GFLAGS_LIBRARYRARY_DIRS
-  include(FindPackageHandleStandardArgs)
-  set(GFLAGS_ROOT_DIR "" CACHE PATH "Folder contains Gflags")
-
-  # We are testing only a couple of files in the include directories
-  if(WIN32)
-    find_path(GFLAGS_INCLUDE_DIR gflags/gflags.h
-        PATHS ${GFLAGS_ROOT_DIR}/src/windows)
-  else()
-    find_path(GFLAGS_INCLUDE_DIR gflags/gflags.h
-        PATHS ${GFLAGS_ROOT_DIR})
-  endif()
-
-  if(WIN32)
-    find_library(GFLAGS_LIBRARY_RELEASE
-        NAMES libgflags
-        PATHS ${GFLAGS_ROOT_DIR}
-        PATH_SUFFIXES Release)
-
-    find_library(GFLAGS_LIBRARY_DEBUG
-        NAMES libgflags-debug
-        PATHS ${GFLAGS_ROOT_DIR}
-        PATH_SUFFIXES Debug)
-    set(GFLAGS_LIBRARY optimized ${GFLAGS_LIBRARY_RELEASE} debug ${GFLAGS_LIBRARY_DEBUG})
-  else()
-    find_library(GFLAGS_LIBRARY gflags)
-  endif()
-
-  find_package_handle_standard_args(
-      gflags DEFAULT_MSG GFLAGS_INCLUDE_DIR GFLAGS_LIBRARY)
-
-  if(GFLAGS_FOUND)
-    message(
-        STATUS
-        "Glow: Found gflags  (include: ${GFLAGS_INCLUDE_DIR}, "
-        "library: ${GFLAGS_LIBRARY})")
-    add_library(gflags UNKNOWN IMPORTED)
-    set_property(
-        TARGET gflags PROPERTY IMPORTED_LOCATION ${GFLAGS_LIBRARY})
-    set_property(
-        TARGET gflags PROPERTY INTERFACE_INCLUDE_DIRECTORIES
-        ${GFLAGS_INCLUDE_DIR})
-    add_library(gflags::gflags ALIAS gflags)
-  endif()
-endif()
-
-# After above, we should have the gflags target now.
-if(NOT TARGET gflags)
-  message(WARNING
-      "Glow: gflags cannot be found. Depending on whether you are building "
-      "Glow or a Glow dependent library, the next warning / error will "
-      "give you more info.")
-endif()
-
diff --git a/glowConfig.cmake.in b/glowConfig.cmake.in
index 5ff3bff8..89989379 100644
--- a/glowConfig.cmake.in
+++ b/glowConfig.cmake.in
@@ -24,8 +24,8 @@ if (GLOW_WITH_ETSOC)
     find_dependency(cereal REQUIRED)
     find_dependency(fmt REQUIRED)
 
-    find_dependency(EsperantoDeviceMinionRuntime REQUIRED)
-    find_dependency(EsperantoBootLoader REQUIRED)
+    #find_dependency(EsperantoDeviceMinionRuntime REQUIRED)
+    #find_dependency(EsperantoBootLoader REQUIRED)
     find_dependency(deviceLayer REQUIRED)
     @ETSOC2_SYSEMU_CMAKE_DEPENDENCY@
 
diff --git a/include/glow/LLVMIRCodeGen/JITFilePrinter.h b/include/glow/LLVMIRCodeGen/JITFilePrinter.h
index e0e3fc9b..034c1bd0 100644
--- a/include/glow/LLVMIRCodeGen/JITFilePrinter.h
+++ b/include/glow/LLVMIRCodeGen/JITFilePrinter.h
@@ -21,6 +21,7 @@
 
 #include <condition_variable>
 #include <cstdarg>
+#include <string>
 #include <unordered_map>
 
 /// Structure implements file I/O related functions. Currently,
diff --git a/lib/Backends/ETSOC/ETSOC.cpp b/lib/Backends/ETSOC/ETSOC.cpp
index 64b2bde2..6b7d6d82 100644
--- a/lib/Backends/ETSOC/ETSOC.cpp
+++ b/lib/Backends/ETSOC/ETSOC.cpp
@@ -91,11 +91,11 @@ Error setETSOCBackendInternalParameters(
   static constexpr auto debugGlowOnlyParamName = "debug-glow-only";
   if (const auto it = parameters.find(debugGlowParamName);
       it != parameters.end()) {
-    RETURN_IF_ERR(replaceOption(it->getKey(), it->getValue()));
+    RETURN_IF_ERR(replaceOption(it->getKey().str(), it->getValue()));
   }
   if (const auto it = parameters.find(debugGlowOnlyParamName);
       it != parameters.end()) {
-    RETURN_IF_ERR(replaceOption(it->getKey(), it->getValue()));
+    RETURN_IF_ERR(replaceOption(it->getKey().str(), it->getValue()));
   }
   for (const auto &paramKeyValue : parameters) {
     const auto &paramName = paramKeyValue.getKey();
@@ -112,7 +112,7 @@ Error setETSOCBackendInternalParameters(
         << "The parameter " << std::string(paramName) << " does not exists\n";
 
     if (paramExists) {
-      RETURN_IF_ERR(replaceOption(paramName, paramValue));
+      RETURN_IF_ERR(replaceOption(paramName.str(), paramValue));
     }
 
     if (paramName == "num-devices") {
diff --git a/lib/Backends/ETSOC/ETSOCFunction.cpp b/lib/Backends/ETSOC/ETSOCFunction.cpp
index a06151e0..9c17d948 100644
--- a/lib/Backends/ETSOC/ETSOCFunction.cpp
+++ b/lib/Backends/ETSOC/ETSOCFunction.cpp
@@ -694,7 +694,7 @@ bool ETSOCFunction::bundleConstants(neura::NetId netId) {
         neura::HostPtr hostPtr{(char *)runtimeBundle_.getConstants() +
                                symbolInfo.offset};
         try {
-          neuralizer_.setConstantHostPointer(netId, v->getName(), hostPtr);
+          neuralizer_.setConstantHostPointer(netId, v->getName().str(), hostPtr);
         } catch (const neura::Exception &e) {
           LOG(FATAL) << "[ETSOCFunction] setConstantHostPointer returned an "
                         "error. Error: "
diff --git a/lib/Backends/ETSOC/ETSOCNetworkLoader.cpp b/lib/Backends/ETSOC/ETSOCNetworkLoader.cpp
index 605fe683..95474af4 100644
--- a/lib/Backends/ETSOC/ETSOCNetworkLoader.cpp
+++ b/lib/Backends/ETSOC/ETSOCNetworkLoader.cpp
@@ -138,7 +138,7 @@ void ETSOCNetworkLoader::registerTensor(neura::NetId netId,
   DEBUG_GLOW(LOG(INFO) << "registerTensor [" << toNumber(netId) << ","
                        << name.str() << "] onDev: " << onDevice << "\n");
   try {
-    neuralizer_.registerTensor(netId, name, tDesc);
+    neuralizer_.registerTensor(netId, name.str(), tDesc);
   } catch (const neura::Exception &e) {
     DEBUG_GLOW(LOG(ERROR) << "Cannot register tensor. Error: " << e.what()
                           << "\n");
@@ -322,7 +322,7 @@ void ETSOCNetworkLoader::registerNetworkOperands(Instruction &I,
     auto tDesc = createTensorDescriptor(type, neura::TensorClass::INTERNAL);
     try {
       neuralizer_.registerOperand(
-          netId, instId, name,
+          netId, instId, name.str(),
           (op.second == OperandKind::In)
               ? neura::OperandType::INPUT
               : (op.second == OperandKind::InOut) ? neura::OperandType::INOUT
@@ -352,7 +352,7 @@ void ETSOCNetworkLoader::registerNetworkOperands(Instruction &I,
   if ((I.getKind() == Kinded::Kind::TensorViewInstKind) or
       (I.getKind() == Kinded::Kind::AllocActivationInstKind)) {
     auto *tvI = static_cast<TensorViewInst *>(&I);
-    std::string name = I.getName();
+    std::string name = I.getName().str();
     auto tvType = tvI->getTy();
     // need to register the tensor first
     neura::TensorDescriptor tDesc =
@@ -511,7 +511,7 @@ neura::InstId ETSOCNetworkLoader::createMemoryInst(Instruction &I,
 
   const auto instId = getInstructionNumber(I);
   try {
-    neuralizer_.registerInstruction(netId, I.getKindName(), params, I.getName(),
+    neuralizer_.registerInstruction(netId, I.getKindName(), params, I.getName().str(),
                                     instId);
   } catch (const neura::Exception &e) {
     DEBUG_GLOW(LOG(ERROR) << "Cannot register instruction. Error: " << e.what()
@@ -589,7 +589,7 @@ neura::InstId ETSOCNetworkLoader::createConvolutionInst(Instruction &I,
 
   const auto instId = getInstructionNumber(I);
   try {
-    neuralizer_.registerInstruction(netId, I.getKindName(), params, I.getName(),
+    neuralizer_.registerInstruction(netId, I.getKindName(), params, I.getName().str(),
                                     instId);
   } catch (const neura::Exception &e) {
     DEBUG_GLOW(LOG(ERROR) << "Cannot register instruction. Error: " << e.what()
@@ -639,7 +639,7 @@ neura::InstId ETSOCNetworkLoader::createPoolingInst(Instruction &I,
 
   const auto instId = getInstructionNumber(I);
   try {
-    neuralizer_.registerInstruction(netId, I.getKindName(), params, I.getName(),
+    neuralizer_.registerInstruction(netId, I.getKindName(), params, I.getName().str(),
                                     instId);
   } catch (const neura::Exception &e) {
     DEBUG_GLOW(LOG(ERROR) << "Cannot register instruction. Error: " << e.what()
@@ -732,7 +732,7 @@ neura::InstId ETSOCNetworkLoader::createGenericInst(Instruction &I,
 
   const auto instId = getInstructionNumber(I);
   try {
-    neuralizer_.registerInstruction(netId, I.getKindName(), params, I.getName(),
+    neuralizer_.registerInstruction(netId, I.getKindName(), params, I.getName().str(),
                                     instId);
   } catch (const neura::Exception &e) {
     DEBUG_GLOW(LOG(ERROR) << "Cannot register instruction. Error: " << e.what()
@@ -801,7 +801,7 @@ neura::InstId ETSOCNetworkLoader::createParallelInst(Instruction &I,
 
   const auto instId = getInstructionNumber(I);
   try {
-    neuralizer_.registerInstruction(netId, I.getKindName(), params, I.getName(),
+    neuralizer_.registerInstruction(netId, I.getKindName(), params, I.getName().str(),
                                     instId);
   } catch (const neura::Exception &e) {
     DEBUG_GLOW(LOG(ERROR) << "Cannot register instruction. Error: " << e.what()
diff --git a/lib/Backends/ETSOC/utils/UnitTestGen.cpp b/lib/Backends/ETSOC/utils/UnitTestGen.cpp
index 9a2d089a..662a613a 100644
--- a/lib/Backends/ETSOC/utils/UnitTestGen.cpp
+++ b/lib/Backends/ETSOC/utils/UnitTestGen.cpp
@@ -702,7 +702,7 @@ void UnitTestGen::writeUTest(const Instruction &I, const std::string &bTest,
   std::cout << "[dumpUnittest] " << iInfo << "\n";
 
   // Info
-  writeUnittestHeaderComment(I.getName(), I.getKindName(), iInfo);
+  writeUnittestHeaderComment(I.getName().str(), I.getKindName(), iInfo);
 
   // Header of the test
   addLine("TEST_P(Operator, " + std::string(I.getName()) + ") {");
diff --git a/lib/Backends/ETSOC/utils/tracedump.cpp b/lib/Backends/ETSOC/utils/tracedump.cpp
index 3ae7abf9..dae10a96 100644
--- a/lib/Backends/ETSOC/utils/tracedump.cpp
+++ b/lib/Backends/ETSOC/utils/tracedump.cpp
@@ -139,7 +139,7 @@ int main(int argc, char *argv[]) {
   std::istream &in = [&]() -> std::istream & {
     if (input_filename.empty()) {
       return std::cin;
-    } else {
+    } else { 
       fin.open(input_filename, std::ios::binary);
       if (!fin.good()) {
         std::cerr << "error: cannot open file: " << input_filename << std::endl;
diff --git a/lib/Base/Tensor.cpp b/lib/Base/Tensor.cpp
index 94ce8bc5..c6c0c3ea 100644
--- a/lib/Base/Tensor.cpp
+++ b/lib/Base/Tensor.cpp
@@ -192,7 +192,7 @@ template <class ElemTy>
 static void dumpBinaryGenericImpl(Handle<ElemTy> handle,
                                   llvm::StringRef fileName, float scale,
                                   int32_t offset) {
-  auto file = std::ofstream(fileName, std::ios::binary);
+  auto file = std::ofstream(fileName.str(), std::ios::binary);
   for (size_t k = 0; k < handle.size(); ++k) {
     double value = ((double)handle.raw(k) - offset) * scale;
     file.write((char *)&value, sizeof(double));
diff --git a/lib/GlowAPI/etsoc.cpp b/lib/GlowAPI/etsoc.cpp
index 1342bb79..3acda1d3 100644
--- a/lib/GlowAPI/etsoc.cpp
+++ b/lib/GlowAPI/etsoc.cpp
@@ -423,12 +423,14 @@ auto loadJSONFile(std::filesystem::path const &filepath)
     -> GlowAPI::Expected<nlohmann::json> {
   // Helper class for handling JSON parsing errors
   class JsonParserNothrow
-      : public nlohmann::detail::json_sax_dom_parser<nlohmann::json> {
+      : public nlohmann::detail::json_sax_dom_parser<nlohmann::json,
+	                                             nlohmann::detail::input_stream_adapter> {
     std::string msg_;
 
   public:
     explicit JsonParserNothrow(nlohmann::json &j)
-        : nlohmann::detail::json_sax_dom_parser<nlohmann::json>(
+        : nlohmann::detail::json_sax_dom_parser<nlohmann::json,
+	                                        nlohmann::detail::input_stream_adapter>(
               j, /*allow_exceptions:*/ false) {}
 
     bool parse_error(std::size_t position, std::string const &,
diff --git a/lib/Importer/CMakeLists.txt b/lib/Importer/CMakeLists.txt
index 80e985c4..9fa71967 100644
--- a/lib/Importer/CMakeLists.txt
+++ b/lib/Importer/CMakeLists.txt
@@ -3,16 +3,16 @@ include_directories(${CMAKE_CURRENT_BINARY_DIR})
 
 add_definitions(-DGOOGLE_PROTOBUF_NO_RTTI)
 
-if(NOT TARGET onnx_proto)
-  # Note: This avoids libprotobuf.so complaining about name collisions at runtime
-  if(NOT ONNX_NAMESPACE)
-    set(ONNX_NAMESPACE "glow_onnx")
-  endif()
-  add_definitions("-DONNX_NAMESPACE=${ONNX_NAMESPACE}")
-  add_subdirectory(${GLOW_THIRDPARTY_DIR}/onnx EXCLUDE_FROM_ALL build_onnx)
-endif()
+#if(NOT TARGET onnx_proto)
+#  # Note: This avoids libprotobuf.so complaining about name collisions at runtime
+#  if(NOT ONNX_NAMESPACE)
+#    set(ONNX_NAMESPACE "glow_onnx")
+#  endif()
+#  add_definitions("-DONNX_NAMESPACE=${ONNX_NAMESPACE}")
+#  add_subdirectory(${GLOW_THIRDPARTY_DIR}/onnx EXCLUDE_FROM_ALL build_onnx)
+#endif()
 
-find_package(Protobuf REQUIRED)
+find_package(protobuf REQUIRED)
 PROTOBUF_GENERATE_CPP(CAFFE_SRCS CAFFE_HDRS caffe2.proto)
 
 # NB: We need to copy the *.pb.h files to appropriately-prefixed paths to
diff --git a/lib/Importer/ONNXModelLoader.cpp b/lib/Importer/ONNXModelLoader.cpp
index abc920de..17afde3c 100755
--- a/lib/Importer/ONNXModelLoader.cpp
+++ b/lib/Importer/ONNXModelLoader.cpp
@@ -54,6 +54,8 @@
 #include <llvm/Support/ErrorHandling.h>                    // for llvm_u...
 #include <llvm/Support/raw_ostream.h>                      // for errs
 
+#include <absl/strings/string_view.h>        // for string view
+
 #include <algorithm>          // for max, copy
 #include <array>              // for array
 #include <assert.h>           // for assert
@@ -1234,15 +1236,15 @@ ONNXModelLoader::loadProto(const std::string &filename, bool zipMode,
   public:
     OnnxTxtErrCollector() = default;
     ~OnnxTxtErrCollector() override = default;
-    void AddError(int line, int column, const std::string &message) override {
+    void RecordError(int line, google::protobuf::io::ColumnNumber column, absl::string_view message) override {
       llvm::errs() << strFormat("ONNX parsing error at [%d, %d]: ", line,
                                 column)
-                   << message << "\n";
+                   << std::string(message) << "\n";
     }
-    void AddWarning(int line, int column, const std::string &message) override {
+    void RecordWarning(int line, google::protobuf::io::ColumnNumber column, absl::string_view message) override {
       llvm::errs() << strFormat("ONNX parsing warning at [%d, %d]: ", line,
                                 column)
-                   << message << "\n";
+                   << std::string(message) << "\n";
     }
   };
 
diff --git a/lib/PassManager/PassManager.cpp b/lib/PassManager/PassManager.cpp
index d6711c97..042e318d 100644
--- a/lib/PassManager/PassManager.cpp
+++ b/lib/PassManager/PassManager.cpp
@@ -231,7 +231,7 @@ bool PassManagerBase::run(IRContainer *C, const CompilationContext &cctx) {
     case ConvergenceMode::UntilFixedPoint:
       while (runPassWithConfig(passConfig, C, cctx)) {
         changed = true;
-        VLOG_IF_EVERY_N(0, google::COUNTER > 1, 100)
+        VLOG_EVERY_N(0, 100)
             << "Warning: " << getNameOfPass(passConfig).str()
             << " Pass applied another 100 iterations without reaching fixed "
                "point";
diff --git a/lib/Runtime/CMakeLists.txt b/lib/Runtime/CMakeLists.txt
index edce56cd..4d80e4cc 100644
--- a/lib/Runtime/CMakeLists.txt
+++ b/lib/Runtime/CMakeLists.txt
@@ -13,6 +13,8 @@ target_link_libraries(Runtime
         glow::Support
         ${LLVM_SUPPORT_LIBS}
         Folly::folly
+	ONNX::onnx
+	ONNX::onnx_proto
     PRIVATE
         glow::Flags
         glow::Graph
diff --git a/lib/Runtime/Executor/CMakeLists.txt b/lib/Runtime/Executor/CMakeLists.txt
index 80eb69de..e37ea878 100644
--- a/lib/Runtime/Executor/CMakeLists.txt
+++ b/lib/Runtime/Executor/CMakeLists.txt
@@ -8,13 +8,13 @@ target_link_libraries(Executor
         glow::Graph
         glow::ExecutionContext
         glow::Runtime
-        Folly::folly
     PRIVATE
         glow::Base
         glow::Backend
         glow::Backends
         glow::ExecutionContext
         glog::glog
+        Folly::folly
         ${LLVM_SUPPORT_LIBS}
 )
 
