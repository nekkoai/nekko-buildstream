diff --git a/cmake/external/onnxruntime_external_deps.cmake b/cmake/external/onnxruntime_external_deps.cmake
index ebf20ab21b..c50af18841 100644
--- a/cmake/external/onnxruntime_external_deps.cmake
+++ b/cmake/external/onnxruntime_external_deps.cmake
@@ -107,172 +107,14 @@ if(onnxruntime_USE_MIMALLOC)
   FetchContent_MakeAvailable(mimalloc)
 endif()
 
-#Protobuf depends on utf8_range
-onnxruntime_fetchcontent_declare(
-    utf8_range
-    URL ${DEP_URL_utf8_range}
-    URL_HASH SHA1=${DEP_SHA1_utf8_range}
-    EXCLUDE_FROM_ALL
-    FIND_PACKAGE_ARGS NAMES utf8_range
-)
-
-set(utf8_range_ENABLE_TESTS OFF CACHE BOOL "Build test suite" FORCE)
-set(utf8_range_ENABLE_INSTALL OFF CACHE BOOL "Configure installation" FORCE)
-
-# The next line will generate an error message "fatal: not a git repository", but it is ok. It is from flatbuffers
-onnxruntime_fetchcontent_makeavailable(utf8_range)
-# protobuf's cmake/utf8_range.cmake has the following line
-include_directories(${utf8_range_SOURCE_DIR})
-
-# Download a protoc binary from Internet if needed
-if(NOT ONNX_CUSTOM_PROTOC_EXECUTABLE AND NOT onnxruntime_USE_VCPKG)
-  # This part of code is only for users' convenience. The code couldn't handle all cases. Users always can manually
-  # download protoc from Protobuf's Github release page and pass the local path to the ONNX_CUSTOM_PROTOC_EXECUTABLE
-  # variable.
-  if (CMAKE_HOST_APPLE)
-    # Using CMAKE_CROSSCOMPILING is not recommended for Apple target devices.
-    # https://cmake.org/cmake/help/v3.26/variable/CMAKE_CROSSCOMPILING.html
-    # To keep it simple, just download and use the universal protoc binary for all Apple host builds.
-    onnxruntime_fetchcontent_declare(protoc_binary URL ${DEP_URL_protoc_mac_universal} URL_HASH SHA1=${DEP_SHA1_protoc_mac_universal} EXCLUDE_FROM_ALL)
-    FetchContent_Populate(protoc_binary)
-    if(protoc_binary_SOURCE_DIR)
-      message(STATUS "Use prebuilt protoc")
-      set(ONNX_CUSTOM_PROTOC_EXECUTABLE ${protoc_binary_SOURCE_DIR}/bin/protoc)
-      set(PROTOC_EXECUTABLE ${ONNX_CUSTOM_PROTOC_EXECUTABLE})
-    endif()
-  elseif (CMAKE_CROSSCOMPILING)
-    message(STATUS "CMAKE_HOST_SYSTEM_NAME: ${CMAKE_HOST_SYSTEM_NAME}")
-    if(CMAKE_HOST_SYSTEM_NAME STREQUAL "Windows")
-      if(CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL "AMD64")
-        onnxruntime_fetchcontent_declare(protoc_binary URL ${DEP_URL_protoc_win64} URL_HASH SHA1=${DEP_SHA1_protoc_win64} EXCLUDE_FROM_ALL)
-        FetchContent_Populate(protoc_binary)
-      elseif(CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL "x86")
-        onnxruntime_fetchcontent_declare(protoc_binary URL ${DEP_URL_protoc_win32} URL_HASH SHA1=${DEP_SHA1_protoc_win32} EXCLUDE_FROM_ALL)
-        FetchContent_Populate(protoc_binary)
-      endif()
-
-      if(protoc_binary_SOURCE_DIR)
-        message(STATUS "Use prebuilt protoc")
-        set(ONNX_CUSTOM_PROTOC_EXECUTABLE ${protoc_binary_SOURCE_DIR}/bin/protoc.exe)
-        set(PROTOC_EXECUTABLE ${ONNX_CUSTOM_PROTOC_EXECUTABLE})
-      endif()
-    elseif(CMAKE_HOST_SYSTEM_NAME STREQUAL "Linux")
-      if(CMAKE_HOST_SYSTEM_PROCESSOR MATCHES "^(x86_64|amd64)$")
-        onnxruntime_fetchcontent_declare(protoc_binary URL ${DEP_URL_protoc_linux_x64} URL_HASH SHA1=${DEP_SHA1_protoc_linux_x64} EXCLUDE_FROM_ALL)
-        FetchContent_Populate(protoc_binary)
-      elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "^(i.86|x86?)$")
-        onnxruntime_fetchcontent_declare(protoc_binary URL ${DEP_URL_protoc_linux_x86} URL_HASH SHA1=${DEP_SHA1_protoc_linux_x86} EXCLUDE_FROM_ALL)
-        FetchContent_Populate(protoc_binary)
-      elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "^aarch64.*")
-        onnxruntime_fetchcontent_declare(protoc_binary URL ${DEP_URL_protoc_linux_aarch64} URL_HASH SHA1=${DEP_SHA1_protoc_linux_aarch64} EXCLUDE_FROM_ALL)
-        FetchContent_Populate(protoc_binary)
-      endif()
-
-      if(protoc_binary_SOURCE_DIR)
-        message(STATUS "Use prebuilt protoc")
-        set(ONNX_CUSTOM_PROTOC_EXECUTABLE ${protoc_binary_SOURCE_DIR}/bin/protoc)
-        set(PROTOC_EXECUTABLE ${ONNX_CUSTOM_PROTOC_EXECUTABLE})
-      endif()
-    endif()
-
-    if(NOT ONNX_CUSTOM_PROTOC_EXECUTABLE)
-      message(FATAL_ERROR "ONNX_CUSTOM_PROTOC_EXECUTABLE must be set to cross-compile.")
-    endif()
-  endif()
-endif()
-
-# if ONNX_CUSTOM_PROTOC_EXECUTABLE is set we don't need to build the protoc binary
-if (ONNX_CUSTOM_PROTOC_EXECUTABLE)
-  if (NOT EXISTS "${ONNX_CUSTOM_PROTOC_EXECUTABLE}")
-    message(FATAL_ERROR "ONNX_CUSTOM_PROTOC_EXECUTABLE is set to '${ONNX_CUSTOM_PROTOC_EXECUTABLE}' "
-                        "but protoc executable was not found there.")
-  endif()
-
-  set(protobuf_BUILD_PROTOC_BINARIES OFF CACHE BOOL "Build protoc" FORCE)
-endif()
-
-#Here we support two build mode:
-#1. if ONNX_CUSTOM_PROTOC_EXECUTABLE is set, build Protobuf from source, except protoc.exe. This mode is mainly
-#   for cross-compiling
-#2. if ONNX_CUSTOM_PROTOC_EXECUTABLE is not set, Compile everything(including protoc) from source code.
-if(Patch_FOUND)
-  set(ONNXRUNTIME_PROTOBUF_PATCH_COMMAND ${Patch_EXECUTABLE} --binary --ignore-whitespace -p1 < ${PROJECT_SOURCE_DIR}/patches/protobuf/protobuf_cmake.patch)
-else()
- set(ONNXRUNTIME_PROTOBUF_PATCH_COMMAND "")
-endif()
-
-#Protobuf depends on absl and utf8_range
-onnxruntime_fetchcontent_declare(
-  Protobuf
-  URL ${DEP_URL_protobuf}
-  URL_HASH SHA1=${DEP_SHA1_protobuf}
-  PATCH_COMMAND ${ONNXRUNTIME_PROTOBUF_PATCH_COMMAND}
-  EXCLUDE_FROM_ALL
-  FIND_PACKAGE_ARGS NAMES Protobuf protobuf
-)
-
-set(protobuf_BUILD_TESTS OFF CACHE BOOL "Build protobuf tests" FORCE)
-#TODO: we'd better to turn the following option off. However, it will cause
-# ".\build.bat --config Debug --parallel --skip_submodule_sync --update" fail with an error message:
-# install(EXPORT "ONNXTargets" ...) includes target "onnx_proto" which requires target "libprotobuf-lite" that is
-# not in any export set.
-#set(protobuf_INSTALL OFF CACHE BOOL "Install protobuf binaries and files" FORCE)
-set(protobuf_USE_EXTERNAL_GTEST ON CACHE BOOL "" FORCE)
-
-if (ANDROID)
-  set(protobuf_WITH_ZLIB OFF CACHE BOOL "Build protobuf with zlib support" FORCE)
-endif()
-
-if (onnxruntime_DISABLE_RTTI)
-  set(protobuf_DISABLE_RTTI ON CACHE BOOL "Remove runtime type information in the binaries" FORCE)
+#protobuf begin
+find_package(protobuf REQUIRED)
+if(Protobuf_FOUND)
+  message(STATUS "Using protobuf from find_package(or vcpkg). Protobuf version: ${Protobuf_VERSION}")
 endif()
 
-include(protobuf_function)
 #protobuf end
 
-onnxruntime_fetchcontent_makeavailable(Protobuf)
-if(Protobuf_FOUND)
-  message(STATUS "Using protobuf from find_package(or vcpkg). Protobuf version: ${Protobuf_VERSION}")
-else()
-  if(protobuf_SOURCE_DIR)
-    if(onnxruntime_USE_WEBGPU)
-      set(DAWN_PROTOBUF_DIR ${protobuf_SOURCE_DIR})
-    endif()
-  endif()
-  # Adjust warning flags
-  if (TARGET libprotoc)
-    if (NOT MSVC)
-      target_compile_options(libprotoc PRIVATE "-w")
-    endif()
-  endif()
-  if (TARGET protoc)
-    add_executable(protobuf::protoc ALIAS protoc)
-    if (UNIX AND onnxruntime_ENABLE_LTO)
-      #https://github.com/protocolbuffers/protobuf/issues/5923
-      target_link_options(protoc PRIVATE "-Wl,--no-as-needed")
-    endif()
-    if (NOT MSVC)
-      target_compile_options(protoc PRIVATE "-w")
-    endif()
-    get_target_property(PROTOC_OSX_ARCH protoc OSX_ARCHITECTURES)
-    if (PROTOC_OSX_ARCH)
-      if (${CMAKE_HOST_SYSTEM_PROCESSOR} IN_LIST PROTOC_OSX_ARCH)
-        message(STATUS "protoc can run")
-      else()
-        list(APPEND PROTOC_OSX_ARCH ${CMAKE_HOST_SYSTEM_PROCESSOR})
-        set_target_properties(protoc PROPERTIES OSX_ARCHITECTURES "${CMAKE_HOST_SYSTEM_PROCESSOR}")
-        set_target_properties(libprotoc PROPERTIES OSX_ARCHITECTURES "${PROTOC_OSX_ARCH}")
-        set_target_properties(libprotobuf PROPERTIES OSX_ARCHITECTURES "${PROTOC_OSX_ARCH}")
-      endif()
-    endif()
-   endif()
-  if (TARGET libprotobuf AND NOT MSVC)
-    target_compile_options(libprotobuf PRIVATE "-w")
-  endif()
-  if (TARGET libprotobuf-lite AND NOT MSVC)
-    target_compile_options(libprotobuf-lite PRIVATE "-w")
-  endif()
-endif()
 if (onnxruntime_USE_FULL_PROTOBUF)
   set(PROTOBUF_LIB protobuf::libprotobuf)
 else()
@@ -292,36 +134,17 @@ onnxruntime_fetchcontent_declare(
 )
 onnxruntime_fetchcontent_makeavailable(date)
 
-if(NOT TARGET Boost::mp11)
-  if(onnxruntime_USE_VCPKG)
-     find_package(Boost REQUIRED)
-     message(STATUS "Aliasing Boost::headers to Boost::mp11")
-     add_library(Boost::mp11 ALIAS Boost::headers)
-  else()
-    onnxruntime_fetchcontent_declare(
-     mp11
-     URL ${DEP_URL_mp11}
-     EXCLUDE_FROM_ALL
-     FIND_PACKAGE_ARGS NAMES Boost
-    )
-    onnxruntime_fetchcontent_makeavailable(mp11)    
-    if(NOT TARGET Boost::mp11)
-      add_library(Boost::mp11 ALIAS Boost::headers)
-    endif()
-  endif()
+if (NOT TARGET date::date AND TARGET date::date-tz)
+  add_library(date::date ALIAS date::date-tz)
 endif()
 
+find_package(Boost REQUIRED)
+add_library(Boost::mp11 ALIAS Boost::headers)
+
 set(JSON_BuildTests OFF CACHE INTERNAL "")
 set(JSON_Install OFF CACHE INTERNAL "")
 
-onnxruntime_fetchcontent_declare(
-    nlohmann_json
-    URL ${DEP_URL_json}
-    URL_HASH SHA1=${DEP_SHA1_json}
-    EXCLUDE_FROM_ALL
-    FIND_PACKAGE_ARGS 3.10 NAMES nlohmann_json
-)
-onnxruntime_fetchcontent_makeavailable(nlohmann_json)
+find_package(nlohmann_json REQUIRED)
 
 #TODO: include clog first
 if (onnxruntime_ENABLE_CPUINFO)
@@ -359,139 +182,18 @@ else()
 endif()
 
 if (CPUINFO_SUPPORTED)
-  if (CMAKE_SYSTEM_NAME STREQUAL "iOS")
-    set(IOS ON CACHE INTERNAL "")
-    set(IOS_ARCH "${CMAKE_OSX_ARCHITECTURES}" CACHE INTERNAL "")
-  endif()
-
-  # if this is a wasm build with xnnpack (only type of wasm build where cpuinfo is involved)
-  # we do not use cpuinfo in ORT code, so don't define CPUINFO_SUPPORTED.
-  if (NOT CMAKE_SYSTEM_NAME STREQUAL "Emscripten")
-    string(APPEND CMAKE_CXX_FLAGS " -DCPUINFO_SUPPORTED")
-  endif()
-
-
-  set(CPUINFO_BUILD_TOOLS OFF CACHE INTERNAL "")
-  set(CPUINFO_BUILD_UNIT_TESTS OFF CACHE INTERNAL "")
-  set(CPUINFO_BUILD_MOCK_TESTS OFF CACHE INTERNAL "")
-  set(CPUINFO_BUILD_BENCHMARKS OFF CACHE INTERNAL "")
-  if (onnxruntime_target_platform STREQUAL "ARM64EC" OR onnxruntime_target_platform STREQUAL "ARM64")
-      message(STATUS "Applying a patch for Windows ARM64/ARM64EC in cpuinfo")
-      onnxruntime_fetchcontent_declare(
-        pytorch_cpuinfo
-        URL ${DEP_URL_pytorch_cpuinfo}
-        URL_HASH SHA1=${DEP_SHA1_pytorch_cpuinfo}
-        EXCLUDE_FROM_ALL
-        PATCH_COMMAND ${Patch_EXECUTABLE} -p1 < ${PROJECT_SOURCE_DIR}/patches/cpuinfo/9bb12d342fd9479679d505d93a478a6f9cd50a47.patch
-        FIND_PACKAGE_ARGS NAMES cpuinfo
-      )
-  else()
-      onnxruntime_fetchcontent_declare(
-        pytorch_cpuinfo
-        URL ${DEP_URL_pytorch_cpuinfo}
-        URL_HASH SHA1=${DEP_SHA1_pytorch_cpuinfo}
-        EXCLUDE_FROM_ALL
-        FIND_PACKAGE_ARGS NAMES cpuinfo
-      )
-  endif()
-  set(ONNXRUNTIME_CPUINFO_PROJ pytorch_cpuinfo)
-  onnxruntime_fetchcontent_makeavailable(${ONNXRUNTIME_CPUINFO_PROJ})
+  find_package(cpuinfo REQUIRED)
   if(TARGET cpuinfo::cpuinfo AND NOT TARGET cpuinfo)
-    message(STATUS "Aliasing cpuinfo::cpuinfo to cpuinfo")
     add_library(cpuinfo ALIAS cpuinfo::cpuinfo)
   endif()
 endif()
 
-if(onnxruntime_USE_CUDA)
-  onnxruntime_fetchcontent_declare(
-    GSL
-    URL ${DEP_URL_microsoft_gsl}
-    URL_HASH SHA1=${DEP_SHA1_microsoft_gsl}
-    PATCH_COMMAND ${Patch_EXECUTABLE} --binary --ignore-whitespace -p1 < ${PROJECT_SOURCE_DIR}/patches/gsl/1064.patch
-    EXCLUDE_FROM_ALL
-    FIND_PACKAGE_ARGS 4.0 NAMES Microsoft.GSL
-  )
-else()
-  onnxruntime_fetchcontent_declare(
-    GSL
-    URL ${DEP_URL_microsoft_gsl}
-    URL_HASH SHA1=${DEP_SHA1_microsoft_gsl}
-    EXCLUDE_FROM_ALL
-    FIND_PACKAGE_ARGS 4.0 NAMES Microsoft.GSL
-  )
-endif()
-set(GSL_TARGET "Microsoft.GSL::GSL")
-set(GSL_INCLUDE_DIR "$<TARGET_PROPERTY:${GSL_TARGET},INTERFACE_INCLUDE_DIRECTORIES>")
-onnxruntime_fetchcontent_makeavailable(GSL)
-
-find_path(safeint_SOURCE_DIR NAMES "SafeInt.hpp")
-if(NOT safeint_SOURCE_DIR)
-  unset(safeint_SOURCE_DIR)
-  onnxruntime_fetchcontent_declare(
-      safeint
-      URL ${DEP_URL_safeint}
-      URL_HASH SHA1=${DEP_SHA1_safeint}
-      EXCLUDE_FROM_ALL
-  )
-
-  # use fetch content rather than makeavailable because safeint only includes unconditional test targets
-  FetchContent_Populate(safeint)
-endif()
-add_library(safeint_interface INTERFACE)
-target_include_directories(safeint_interface INTERFACE ${safeint_SOURCE_DIR})
-
+find_package(Microsoft.GSL REQUIRED)
+find_package(safeint REQUIRED)
+add_library(safeint_interface ALIAS safeint::safeint)
 
 # Flatbuffers
-# We do not need to build flatc for iOS or Android Cross Compile
-if (CMAKE_SYSTEM_NAME STREQUAL "iOS" OR CMAKE_SYSTEM_NAME STREQUAL "Android" OR CMAKE_SYSTEM_NAME STREQUAL "Emscripten")
-  set(FLATBUFFERS_BUILD_FLATC OFF CACHE BOOL "FLATBUFFERS_BUILD_FLATC" FORCE)
-endif()
-set(FLATBUFFERS_BUILD_TESTS OFF CACHE BOOL "FLATBUFFERS_BUILD_TESTS" FORCE)
-set(FLATBUFFERS_INSTALL OFF CACHE BOOL "FLATBUFFERS_INSTALL" FORCE)
-set(FLATBUFFERS_BUILD_FLATHASH OFF CACHE BOOL "FLATBUFFERS_BUILD_FLATHASH" FORCE)
-set(FLATBUFFERS_BUILD_FLATLIB ON CACHE BOOL "FLATBUFFERS_BUILD_FLATLIB" FORCE)
-if(Patch_FOUND)
-  set(ONNXRUNTIME_FLATBUFFERS_PATCH_COMMAND ${Patch_EXECUTABLE} --binary --ignore-whitespace -p1 < ${PROJECT_SOURCE_DIR}/patches/flatbuffers/flatbuffers.patch)
-else()
- set(ONNXRUNTIME_FLATBUFFERS_PATCH_COMMAND "")
-endif()
-
-#flatbuffers 1.11.0 does not have flatbuffers::IsOutRange, therefore we require 1.12.0+
-onnxruntime_fetchcontent_declare(
-    flatbuffers
-    URL ${DEP_URL_flatbuffers}
-    URL_HASH SHA1=${DEP_SHA1_flatbuffers}
-    PATCH_COMMAND ${ONNXRUNTIME_FLATBUFFERS_PATCH_COMMAND}
-    EXCLUDE_FROM_ALL
-    FIND_PACKAGE_ARGS 23.5.9 NAMES Flatbuffers flatbuffers
-)
-
-onnxruntime_fetchcontent_makeavailable(flatbuffers)
-if(NOT flatbuffers_FOUND)
-  if(NOT TARGET flatbuffers::flatbuffers)
-    add_library(flatbuffers::flatbuffers ALIAS flatbuffers)
-  endif()
-  if(TARGET flatc AND NOT TARGET flatbuffers::flatc)
-    add_executable(flatbuffers::flatc ALIAS flatc)
-  endif()
-  if (GDK_PLATFORM)
-    # cstdlib only defines std::getenv when _CRT_USE_WINAPI_FAMILY_DESKTOP_APP is defined, which
-    # is probably an oversight for GDK/Xbox builds (::getenv exists and works).
-    file(WRITE ${CMAKE_BINARY_DIR}/gdk_cstdlib_wrapper.h [[
-#pragma once
-#ifdef __cplusplus
-#include <cstdlib>
-namespace std { using ::getenv; }
-#endif
-]])
-    if(TARGET flatbuffers)
-      target_compile_options(flatbuffers PRIVATE /FI${CMAKE_BINARY_DIR}/gdk_cstdlib_wrapper.h)
-    endif()
-    if(TARGET flatc)
-      target_compile_options(flatc PRIVATE /FI${CMAKE_BINARY_DIR}/gdk_cstdlib_wrapper.h)
-    endif()
-  endif()
-endif()
+find_package(flatbuffers REQUIRED)
 
 # ONNX
 if (NOT onnxruntime_USE_FULL_PROTOBUF)
@@ -530,7 +232,7 @@ onnxruntime_fetchcontent_declare(
   FIND_PACKAGE_ARGS NAMES ONNX onnx
 )
 if (NOT onnxruntime_MINIMAL_BUILD)
-  onnxruntime_fetchcontent_makeavailable(onnx)
+  find_package(ONNX "1.17.0" REQUIRED CONFIG)
 else()
   include(onnx_minimal)
 endif()
@@ -582,6 +284,11 @@ if (onnxruntime_USE_XNNPACK)
   endif()
 endif()
 
+if (onnxruntime_USE_ETGLOW)
+  find_package(glow REQUIRED)
+  find_package(et-trace-utils REQUIRED)
+endif()
+
 set(onnxruntime_EXTERNAL_LIBRARIES ${onnxruntime_EXTERNAL_LIBRARIES_XNNPACK} ${WIL_TARGET} nlohmann_json::nlohmann_json
                                    onnx onnx_proto ${PROTOBUF_LIB} re2::re2 Boost::mp11 safeint_interface
                                    flatbuffers::flatbuffers ${GSL_TARGET} ${ABSEIL_LIBS} date::date
