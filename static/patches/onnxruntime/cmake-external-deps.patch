diff --git a/cmake/external/onnxruntime_external_deps.cmake b/cmake/external/onnxruntime_external_deps.cmake
index 8574602..226638c 100644
--- a/cmake/external/onnxruntime_external_deps.cmake
+++ b/cmake/external/onnxruntime_external_deps.cmake
@@ -87,25 +87,9 @@ if (onnxruntime_BUILD_BENCHMARKS)
 endif()
 
 if (NOT WIN32)
-  FetchContent_Declare(
-    google_nsync
-    URL ${DEP_URL_google_nsync}
-    URL_HASH SHA1=${DEP_SHA1_google_nsync}
-    PATCH_COMMAND ${Patch_EXECUTABLE} --binary --ignore-whitespace -p1 < ${PROJECT_SOURCE_DIR}/patches/nsync/nsync_1.26.0.patch
-    FIND_PACKAGE_ARGS NAMES nsync unofficial-nsync
-  )
-  #nsync tests failed on Mac Build
-  set(NSYNC_ENABLE_TESTS OFF CACHE BOOL "" FORCE)
-  onnxruntime_fetchcontent_makeavailable(google_nsync)
-
-  if (google_nsync_SOURCE_DIR)
-    add_library(nsync::nsync_cpp ALIAS nsync_cpp)
-    target_include_directories(nsync_cpp PUBLIC ${google_nsync_SOURCE_DIR}/public)
-  endif()
-  if(TARGET unofficial::nsync::nsync_cpp AND NOT TARGET nsync::nsync_cpp)
-    message(STATUS "Aliasing unofficial::nsync::nsync_cpp to nsync::nsync_cpp")
-    add_library(nsync::nsync_cpp ALIAS unofficial::nsync::nsync_cpp)
-  endif()
+  find_package(nsync REQUIRED)
+  find_package(nsync_cpp REQUIRED)
+  add_library(nsync::nsync_cpp ALIAS nsync_cpp)
 endif()
 
 if(onnxruntime_USE_MIMALLOC)
@@ -118,165 +102,14 @@ if(onnxruntime_USE_MIMALLOC)
   FetchContent_MakeAvailable(mimalloc)
 endif()
 
-#Protobuf depends on utf8_range
-FetchContent_Declare(
-    utf8_range
-    URL ${DEP_URL_utf8_range}
-    URL_HASH SHA1=${DEP_SHA1_utf8_range}
-    FIND_PACKAGE_ARGS NAMES utf8_range
-)
-
-set(utf8_range_ENABLE_TESTS OFF CACHE BOOL "Build test suite" FORCE)
-set(utf8_range_ENABLE_INSTALL OFF CACHE BOOL "Configure installation" FORCE)
-
-# The next line will generate an error message "fatal: not a git repository", but it is ok. It is from flatbuffers
-onnxruntime_fetchcontent_makeavailable(utf8_range)
-# protobuf's cmake/utf8_range.cmake has the following line
-include_directories(${utf8_range_SOURCE_DIR})
-
-# Download a protoc binary from Internet if needed
-if(NOT ONNX_CUSTOM_PROTOC_EXECUTABLE)
-  # This part of code is only for users' convenience. The code couldn't handle all cases. Users always can manually
-  # download protoc from Protobuf's Github release page and pass the local path to the ONNX_CUSTOM_PROTOC_EXECUTABLE
-  # variable.
-  if (CMAKE_HOST_APPLE)
-    # Using CMAKE_CROSSCOMPILING is not recommended for Apple target devices.
-    # https://cmake.org/cmake/help/v3.26/variable/CMAKE_CROSSCOMPILING.html
-    # To keep it simple, just download and use the universal protoc binary for all Apple host builds.
-    FetchContent_Declare(protoc_binary URL ${DEP_URL_protoc_mac_universal} URL_HASH SHA1=${DEP_SHA1_protoc_mac_universal})
-    FetchContent_Populate(protoc_binary)
-    if(protoc_binary_SOURCE_DIR)
-      message(STATUS "Use prebuilt protoc")
-      set(ONNX_CUSTOM_PROTOC_EXECUTABLE ${protoc_binary_SOURCE_DIR}/bin/protoc)
-      set(PROTOC_EXECUTABLE ${ONNX_CUSTOM_PROTOC_EXECUTABLE})
-    endif()
-  elseif (CMAKE_CROSSCOMPILING)
-    message(STATUS "CMAKE_HOST_SYSTEM_NAME: ${CMAKE_HOST_SYSTEM_NAME}")
-    if(CMAKE_HOST_SYSTEM_NAME STREQUAL "Windows")
-      if(CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL "AMD64")
-        FetchContent_Declare(protoc_binary URL ${DEP_URL_protoc_win64} URL_HASH SHA1=${DEP_SHA1_protoc_win64})
-        FetchContent_Populate(protoc_binary)
-      elseif(CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL "x86")
-        FetchContent_Declare(protoc_binary URL ${DEP_URL_protoc_win32} URL_HASH SHA1=${DEP_SHA1_protoc_win32})
-        FetchContent_Populate(protoc_binary)
-      endif()
-
-      if(protoc_binary_SOURCE_DIR)
-        message(STATUS "Use prebuilt protoc")
-        set(ONNX_CUSTOM_PROTOC_EXECUTABLE ${protoc_binary_SOURCE_DIR}/bin/protoc.exe)
-        set(PROTOC_EXECUTABLE ${ONNX_CUSTOM_PROTOC_EXECUTABLE})
-      endif()
-    elseif(CMAKE_HOST_SYSTEM_NAME STREQUAL "Linux")
-      if(CMAKE_HOST_SYSTEM_PROCESSOR MATCHES "^(x86_64|amd64)$")
-        FetchContent_Declare(protoc_binary URL ${DEP_URL_protoc_linux_x64} URL_HASH SHA1=${DEP_SHA1_protoc_linux_x64})
-        FetchContent_Populate(protoc_binary)
-      elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "^(i.86|x86?)$")
-        FetchContent_Declare(protoc_binary URL ${DEP_URL_protoc_linux_x86} URL_HASH SHA1=${DEP_SHA1_protoc_linux_x86})
-        FetchContent_Populate(protoc_binary)
-      elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "^aarch64.*")
-        FetchContent_Declare(protoc_binary URL ${DEP_URL_protoc_linux_aarch64} URL_HASH SHA1=${DEP_SHA1_protoc_linux_aarch64})
-        FetchContent_Populate(protoc_binary)
-      endif()
-
-      if(protoc_binary_SOURCE_DIR)
-        message(STATUS "Use prebuilt protoc")
-        set(ONNX_CUSTOM_PROTOC_EXECUTABLE ${protoc_binary_SOURCE_DIR}/bin/protoc)
-        set(PROTOC_EXECUTABLE ${ONNX_CUSTOM_PROTOC_EXECUTABLE})
-      endif()
-    endif()
-
-    if(NOT ONNX_CUSTOM_PROTOC_EXECUTABLE)
-      message(FATAL_ERROR "ONNX_CUSTOM_PROTOC_EXECUTABLE must be set to cross-compile.")
-    endif()
-  endif()
-endif()
-
-# if ONNX_CUSTOM_PROTOC_EXECUTABLE is set we don't need to build the protoc binary
-if (ONNX_CUSTOM_PROTOC_EXECUTABLE)
-  if (NOT EXISTS "${ONNX_CUSTOM_PROTOC_EXECUTABLE}")
-    message(FATAL_ERROR "ONNX_CUSTOM_PROTOC_EXECUTABLE is set to '${ONNX_CUSTOM_PROTOC_EXECUTABLE}' "
-                        "but protoc executable was not found there.")
-  endif()
-
-  set(protobuf_BUILD_PROTOC_BINARIES OFF CACHE BOOL "Build protoc" FORCE)
-endif()
-
-#Here we support two build mode:
-#1. if ONNX_CUSTOM_PROTOC_EXECUTABLE is set, build Protobuf from source, except protoc.exe. This mode is mainly
-#   for cross-compiling
-#2. if ONNX_CUSTOM_PROTOC_EXECUTABLE is not set, Compile everything(including protoc) from source code.
-if(Patch_FOUND)
-  set(ONNXRUNTIME_PROTOBUF_PATCH_COMMAND ${Patch_EXECUTABLE} --binary --ignore-whitespace -p1 < ${PROJECT_SOURCE_DIR}/patches/protobuf/protobuf_cmake.patch)
-else()
- set(ONNXRUNTIME_PROTOBUF_PATCH_COMMAND "")
-endif()
-
-#Protobuf depends on absl and utf8_range
-FetchContent_Declare(
-  Protobuf
-  URL ${DEP_URL_protobuf}
-  URL_HASH SHA1=${DEP_SHA1_protobuf}
-  PATCH_COMMAND ${ONNXRUNTIME_PROTOBUF_PATCH_COMMAND}
-  FIND_PACKAGE_ARGS NAMES Protobuf protobuf
-)
-
-set(protobuf_BUILD_TESTS OFF CACHE BOOL "Build protobuf tests" FORCE)
-#TODO: we'd better to turn the following option off. However, it will cause
-# ".\build.bat --config Debug --parallel --skip_submodule_sync --update" fail with an error message:
-# install(EXPORT "ONNXTargets" ...) includes target "onnx_proto" which requires target "libprotobuf-lite" that is
-# not in any export set.
-#set(protobuf_INSTALL OFF CACHE BOOL "Install protobuf binaries and files" FORCE)
-set(protobuf_USE_EXTERNAL_GTEST ON CACHE BOOL "" FORCE)
-
-if (ANDROID)
-  set(protobuf_WITH_ZLIB OFF CACHE BOOL "Build protobuf with zlib support" FORCE)
-endif()
-
-if (onnxruntime_DISABLE_RTTI)
-  set(protobuf_DISABLE_RTTI ON CACHE BOOL "Remove runtime type information in the binaries" FORCE)
+#protobuf begin
+find_package(protobuf REQUIRED)
+if(Protobuf_FOUND)
+  message("Protobuf version: ${Protobuf_VERSION}")
 endif()
 
-include(protobuf_function)
 #protobuf end
 
-onnxruntime_fetchcontent_makeavailable(Protobuf)
-if(Protobuf_FOUND)
-  message(STATUS "Protobuf version: ${Protobuf_VERSION}")
-else()
-  # Adjust warning flags
-  if (TARGET libprotoc)
-    if (NOT MSVC)
-      target_compile_options(libprotoc PRIVATE "-w")
-    endif()
-  endif()
-  if (TARGET protoc)
-    add_executable(protobuf::protoc ALIAS protoc)
-    if (UNIX AND onnxruntime_ENABLE_LTO)
-      #https://github.com/protocolbuffers/protobuf/issues/5923
-      target_link_options(protoc PRIVATE "-Wl,--no-as-needed")
-    endif()
-    if (NOT MSVC)
-      target_compile_options(protoc PRIVATE "-w")
-    endif()
-    get_target_property(PROTOC_OSX_ARCH protoc OSX_ARCHITECTURES)
-    if (PROTOC_OSX_ARCH)
-      if (${CMAKE_HOST_SYSTEM_PROCESSOR} IN_LIST PROTOC_OSX_ARCH)
-        message(STATUS "protoc can run")
-      else()
-        list(APPEND PROTOC_OSX_ARCH ${CMAKE_HOST_SYSTEM_PROCESSOR})
-        set_target_properties(protoc PROPERTIES OSX_ARCHITECTURES "${CMAKE_HOST_SYSTEM_PROCESSOR}")
-        set_target_properties(libprotoc PROPERTIES OSX_ARCHITECTURES "${PROTOC_OSX_ARCH}")
-        set_target_properties(libprotobuf PROPERTIES OSX_ARCHITECTURES "${PROTOC_OSX_ARCH}")
-      endif()
-    endif()
-   endif()
-  if (TARGET libprotobuf AND NOT MSVC)
-    target_compile_options(libprotobuf PRIVATE "-w")
-  endif()
-  if (TARGET libprotobuf-lite AND NOT MSVC)
-    target_compile_options(libprotobuf-lite PRIVATE "-w")
-  endif()
-endif()
 if (onnxruntime_USE_FULL_PROTOBUF)
   set(PROTOBUF_LIB protobuf::libprotobuf)
 else()
@@ -294,32 +127,16 @@ FetchContent_Declare(
   FIND_PACKAGE_ARGS 3...<4 NAMES date
 )
 onnxruntime_fetchcontent_makeavailable(date)
-
-FetchContent_Declare(
-  mp11
-  URL ${DEP_URL_mp11}
-  URL_HASH SHA1=${DEP_SHA1_mp11}
-  FIND_PACKAGE_ARGS NAMES Boost
-)
-onnxruntime_fetchcontent_makeavailable(mp11)
-if(NOT TARGET Boost::mp11)
-  if(onnxruntime_USE_VCPKG)
-    find_package(Boost REQUIRED)
-  endif()
-  message(STATUS "Aliasing Boost::headers to Boost::mp11")
-  add_library(Boost::mp11 ALIAS Boost::headers)
+if (NOT TARGET date::date AND TARGET date::date-tz)
+  add_library(date::date ALIAS date::date-tz)
 endif()
 
+find_package(Boost REQUIRED)
+
 set(JSON_BuildTests OFF CACHE INTERNAL "")
 set(JSON_Install OFF CACHE INTERNAL "")
 
-FetchContent_Declare(
-    nlohmann_json
-    URL ${DEP_URL_json}
-    URL_HASH SHA1=${DEP_SHA1_json}
-    FIND_PACKAGE_ARGS 3.10 NAMES nlohmann_json
-)
-onnxruntime_fetchcontent_makeavailable(nlohmann_json)
+find_package(nlohmann_json REQUIRED)
 
 #TODO: include clog first
 if (onnxruntime_ENABLE_CPUINFO)
@@ -391,6 +208,7 @@ if (CPUINFO_SUPPORTED)
       )
   endif()
   set(ONNXRUNTIME_CPUINFO_PROJ pytorch_cpuinfo)
+  find_package(cpuinfo REQUIRED)
   onnxruntime_fetchcontent_makeavailable(${ONNXRUNTIME_CPUINFO_PROJ})
   if(TARGET cpuinfo::cpuinfo AND NOT TARGET cpuinfo)
     message(STATUS "Aliasing cpuinfo::cpuinfo to cpuinfo")
@@ -398,115 +216,12 @@ if (CPUINFO_SUPPORTED)
   endif()
 endif()
 
-# xnnpack depends on clog
-# Android build should use the system's log library instead of clog
-if ((CPUINFO_SUPPORTED OR onnxruntime_USE_XNNPACK) AND NOT ANDROID)
-  set(CLOG_BUILD_TESTS OFF CACHE BOOL "" FORCE)
-  FetchContent_Declare(
-    pytorch_clog
-    URL ${DEP_URL_pytorch_cpuinfo}
-    URL_HASH SHA1=${DEP_SHA1_pytorch_cpuinfo}
-    SOURCE_SUBDIR deps/clog
-    FIND_PACKAGE_ARGS NAMES cpuinfo
-  )
-  set(ONNXRUNTIME_CLOG_PROJ pytorch_clog)
-  onnxruntime_fetchcontent_makeavailable(${ONNXRUNTIME_CLOG_PROJ})
-  set(ONNXRUNTIME_CLOG_TARGET_NAME clog)
-  # if cpuinfo is from find_package, use it with imported name
-  if(TARGET cpuinfo::clog)
-    set(ONNXRUNTIME_CLOG_TARGET_NAME cpuinfo::clog)
-  elseif(onnxruntime_USE_VCPKG)
-    # however, later cpuinfo versions may not contain clog. use cpuinfo
-    set(ONNXRUNTIME_CLOG_TARGET_NAME cpuinfo::cpuinfo)
-  endif()
-endif()
-
-if(onnxruntime_USE_CUDA)
-  FetchContent_Declare(
-    GSL
-    URL ${DEP_URL_microsoft_gsl}
-    URL_HASH SHA1=${DEP_SHA1_microsoft_gsl}
-    PATCH_COMMAND ${Patch_EXECUTABLE} --binary --ignore-whitespace -p1 < ${PROJECT_SOURCE_DIR}/patches/gsl/1064.patch
-    FIND_PACKAGE_ARGS 4.0 NAMES Microsoft.GSL
-  )
-else()
-  FetchContent_Declare(
-    GSL
-    URL ${DEP_URL_microsoft_gsl}
-    URL_HASH SHA1=${DEP_SHA1_microsoft_gsl}
-    FIND_PACKAGE_ARGS 4.0 NAMES Microsoft.GSL
-  )
-endif()
-set(GSL_TARGET "Microsoft.GSL::GSL")
-set(GSL_INCLUDE_DIR "$<TARGET_PROPERTY:${GSL_TARGET},INTERFACE_INCLUDE_DIRECTORIES>")
-onnxruntime_fetchcontent_makeavailable(GSL)
-
-find_path(safeint_SOURCE_DIR NAMES "SafeInt.hpp")
-if(NOT safeint_SOURCE_DIR)
-  unset(safeint_SOURCE_DIR)
-  FetchContent_Declare(
-      safeint
-      URL ${DEP_URL_safeint}
-      URL_HASH SHA1=${DEP_SHA1_safeint}
-  )
-
-  # use fetch content rather than makeavailable because safeint only includes unconditional test targets
-  FetchContent_Populate(safeint)
-endif()
-add_library(safeint_interface INTERFACE)
-target_include_directories(safeint_interface INTERFACE ${safeint_SOURCE_DIR})
-
+find_package(Microsoft.GSL REQUIRED)
+find_package(safeint REQUIRED)
+add_library(safeint_interface ALIAS safeint::safeint)
 
 # Flatbuffers
-# We do not need to build flatc for iOS or Android Cross Compile
-if (CMAKE_SYSTEM_NAME STREQUAL "iOS" OR CMAKE_SYSTEM_NAME STREQUAL "Android" OR CMAKE_SYSTEM_NAME STREQUAL "Emscripten")
-  set(FLATBUFFERS_BUILD_FLATC OFF CACHE BOOL "FLATBUFFERS_BUILD_FLATC" FORCE)
-endif()
-set(FLATBUFFERS_BUILD_TESTS OFF CACHE BOOL "FLATBUFFERS_BUILD_TESTS" FORCE)
-set(FLATBUFFERS_INSTALL OFF CACHE BOOL "FLATBUFFERS_INSTALL" FORCE)
-set(FLATBUFFERS_BUILD_FLATHASH OFF CACHE BOOL "FLATBUFFERS_BUILD_FLATHASH" FORCE)
-set(FLATBUFFERS_BUILD_FLATLIB ON CACHE BOOL "FLATBUFFERS_BUILD_FLATLIB" FORCE)
-if(Patch_FOUND)
-  set(ONNXRUNTIME_FLATBUFFERS_PATCH_COMMAND ${Patch_EXECUTABLE} --binary --ignore-whitespace -p1 < ${PROJECT_SOURCE_DIR}/patches/flatbuffers/flatbuffers.patch)
-else()
- set(ONNXRUNTIME_FLATBUFFERS_PATCH_COMMAND "")
-endif()
-
-#flatbuffers 1.11.0 does not have flatbuffers::IsOutRange, therefore we require 1.12.0+
-FetchContent_Declare(
-    flatbuffers
-    URL ${DEP_URL_flatbuffers}
-    URL_HASH SHA1=${DEP_SHA1_flatbuffers}
-    PATCH_COMMAND ${ONNXRUNTIME_FLATBUFFERS_PATCH_COMMAND}
-    FIND_PACKAGE_ARGS 23.5.9 NAMES Flatbuffers flatbuffers
-)
-
-onnxruntime_fetchcontent_makeavailable(flatbuffers)
-if(NOT flatbuffers_FOUND)
-  if(NOT TARGET flatbuffers::flatbuffers)
-    add_library(flatbuffers::flatbuffers ALIAS flatbuffers)
-  endif()
-  if(TARGET flatc AND NOT TARGET flatbuffers::flatc)
-    add_executable(flatbuffers::flatc ALIAS flatc)
-  endif()
-  if (GDK_PLATFORM)
-    # cstdlib only defines std::getenv when _CRT_USE_WINAPI_FAMILY_DESKTOP_APP is defined, which
-    # is probably an oversight for GDK/Xbox builds (::getenv exists and works).
-    file(WRITE ${CMAKE_BINARY_DIR}/gdk_cstdlib_wrapper.h [[
-#pragma once
-#ifdef __cplusplus
-#include <cstdlib>
-namespace std { using ::getenv; }
-#endif
-]])
-    if(TARGET flatbuffers)
-      target_compile_options(flatbuffers PRIVATE /FI${CMAKE_BINARY_DIR}/gdk_cstdlib_wrapper.h)
-    endif()
-    if(TARGET flatc)
-      target_compile_options(flatc PRIVATE /FI${CMAKE_BINARY_DIR}/gdk_cstdlib_wrapper.h)
-    endif()
-  endif()
-endif()
+find_package(flatbuffers REQUIRED)
 
 # ONNX
 if (NOT onnxruntime_USE_FULL_PROTOBUF)
@@ -529,7 +244,7 @@ FetchContent_Declare(
   FIND_PACKAGE_ARGS NAMES ONNX onnx
 )
 if (NOT onnxruntime_MINIMAL_BUILD)
-  onnxruntime_fetchcontent_makeavailable(onnx)
+  find_package(ONNX "1.16.1" REQUIRED CONFIG)
 else()
   include(onnx_minimal)
 endif()
@@ -566,6 +281,11 @@ if (onnxruntime_USE_XNNPACK)
   include(xnnpack)
 endif()
 
+if (onnxruntime_USE_ETGLOW)
+  find_package(glow REQUIRED)
+  find_package(et-trace-utils REQUIRED)
+endif()
+
 if (onnxruntime_USE_MIMALLOC)
   add_definitions(-DUSE_MIMALLOC)
 
@@ -583,14 +303,7 @@ set(onnxruntime_EXTERNAL_LIBRARIES ${onnxruntime_EXTERNAL_LIBRARIES_XNNPACK} ${W
 
 # The source code of onnx_proto is generated, we must build this lib first before starting to compile the other source code that uses ONNX protobuf types.
 # The other libs do not have the problem. All the sources are already there. We can compile them in any order.
-set(onnxruntime_EXTERNAL_DEPENDENCIES onnx_proto flatbuffers::flatbuffers)
-
-if(NOT (onnx_FOUND OR ONNX_FOUND)) # building ONNX from source
-  target_compile_definitions(onnx PUBLIC $<TARGET_PROPERTY:onnx_proto,INTERFACE_COMPILE_DEFINITIONS> PRIVATE "__ONNX_DISABLE_STATIC_REGISTRATION")
-  if (NOT onnxruntime_USE_FULL_PROTOBUF)
-    target_compile_definitions(onnx PUBLIC "__ONNX_NO_DOC_STRINGS")
-  endif()
-endif()
+set(onnxruntime_EXTERNAL_DEPENDENCIES onnx_proto flatbuffers::flatbuffers nsync::nsync_cpp)
 
 if (onnxruntime_RUN_ONNX_TESTS)
   add_definitions(-DORT_RUN_EXTERNAL_ONNX_TESTS)
