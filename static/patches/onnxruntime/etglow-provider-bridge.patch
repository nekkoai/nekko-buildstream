diff --git a/onnxruntime/core/session/provider_bridge_ort.cc b/onnxruntime/core/session/provider_bridge_ort.cc
index 1d25ceb..32bf638 100644
--- a/onnxruntime/core/session/provider_bridge_ort.cc
+++ b/onnxruntime/core/session/provider_bridge_ort.cc
@@ -96,6 +96,7 @@ using EtwRegistrationManager_EtwInternalCallback = EtwRegistrationManager::EtwIn
 #include "core/providers/cann/cann_provider_factory_creator.h"
 #include "core/providers/rocm/rocm_provider_factory_creator.h"
 #include "core/providers/dnnl/dnnl_provider_factory_creator.h"
+#include "core/providers/etglow/etglow_provider_factory_creator.h"
 #include "core/providers/migraphx/migraphx_provider_factory_creator.h"
 #include "core/providers/openvino/openvino_provider_factory_creator.h"
 #include "core/providers/tensorrt/tensorrt_provider_factory_creator.h"
@@ -106,6 +107,7 @@ using EtwRegistrationManager_EtwInternalCallback = EtwRegistrationManager::EtwIn
 #include "core/providers/cann/cann_provider_factory.h"
 #include "core/providers/rocm/rocm_provider_factory.h"
 #include "core/providers/dnnl/dnnl_provider_factory.h"
+#include "core/providers/etglow/etglow_provider_factory.h"
 #include "core/providers/migraphx/migraphx_provider_factory.h"
 #include "core/providers/openvino/openvino_provider_factory.h"
 #include "core/providers/tensorrt/tensorrt_provider_factory.h"
@@ -149,6 +151,8 @@ ProviderInfo_ROCM& GetProviderInfo_ROCM();
 ProviderHostCPU& GetProviderHostCPU();
 ProviderInfo_MIGraphX* TryGetProviderInfo_MIGraphX();
 ProviderInfo_MIGraphX& GetProviderInfo_MIGraphX();
+ProviderInfo_EtGlow* TryGetProviderInfo_EtGlow();
+ProviderInfo_EtGlow& GetProviderInfo_EtGlow();
 ONNX_NAMESPACE::OpSchema CreateSchema(const std::string& domain, const std::vector<const OrtCustomOp*>& ops);
 struct TensorShapeProto_Dimension_Iterator_Impl : TensorShapeProto_Dimension_Iterator {
   TensorShapeProto_Dimension_Iterator_Impl(google::protobuf::internal::RepeatedPtrIterator<const onnx::TensorShapeProto_Dimension>&& v) : v_{std::move(v)} {}
@@ -1770,6 +1774,8 @@ static ProviderLibrary s_library_vitisai(LIBRARY_PREFIX ORT_TSTR("onnxruntime_pr
                                          false /* unload - On Linux if we unload the vitisai shared provider we crash */
 #endif
 );
+static ProviderLibrary s_library_etglow(LIBRARY_PREFIX ORT_TSTR("onnxruntime_providers_etglow") LIBRARY_EXTENSION);
+static ProviderLibrary s_library_etglow_test(LIBRARY_PREFIX ORT_TSTR("onnxruntime_providers_etglow_ut") LIBRARY_EXTENSION, false);
 static ProviderLibrary s_library_openvino(LIBRARY_PREFIX ORT_TSTR("onnxruntime_providers_openvino") LIBRARY_EXTENSION);
 static ProviderLibrary s_library_tensorrt(LIBRARY_PREFIX ORT_TSTR("onnxruntime_providers_tensorrt") LIBRARY_EXTENSION
 #ifndef _WIN32
@@ -1802,6 +1808,8 @@ static ProviderLibrary s_library_qnn(LIBRARY_PREFIX ORT_TSTR("onnxruntime_provid
 void UnloadSharedProviders() {
   s_library_dnnl.Unload();
   s_library_vitisai.Unload();
+  s_library_etglow.Unload();
+  s_library_etglow_test.Unload();
   s_library_openvino.Unload();
   s_library_tensorrt.Unload();
   s_library_cuda.Unload();
@@ -1875,6 +1883,31 @@ std::shared_ptr<IExecutionProviderFactory> DnnlProviderFactoryCreator::Create(in
   return s_library_dnnl.Get().CreateExecutionProviderFactory(use_arena);
 }
 
+void ORTSessionOptionsToOrtEtGlowProviderOptions(ProviderOptions& etglow_options,
+                                                 const SessionOptions* session_options) {
+  /* todo */
+  bool disable_cpu_fallback = session_options->config_options.GetConfigOrDefault(
+                                  kOrtSessionOptionsDisableCPUEPFallback, "0") == "1";
+  if (disable_cpu_fallback)
+    etglow_options["disable_cpu_fallback"] = "true";
+}
+
+std::shared_ptr<IExecutionProviderFactory> EtGlowProviderFactoryCreator::Create(ProviderOptions* provider_options_map,
+                                                                                const SessionOptions* session_options) {  // Append session options applicable for EP to EP Provider options.
+  if (session_options) {
+    onnxruntime::ORTSessionOptionsToOrtEtGlowProviderOptions(*provider_options_map, session_options);
+  }
+  OrtEtGlowProviderOptions *etglow_options;
+  auto options = std::make_unique<OrtEtGlowProviderOptions>();
+  etglow_options = options.release();
+  s_library_etglow.Get().UpdateProviderOptions(reinterpret_cast<void*>(etglow_options), *provider_options_map);
+  return s_library_etglow.Get().CreateExecutionProviderFactory(etglow_options);
+}
+
+std::shared_ptr<IExecutionProviderFactory> EtGlowProviderFactoryCreator::Create(const OrtEtGlowProviderOptions* provider_options) {
+  return s_library_etglow.Get().CreateExecutionProviderFactory(provider_options);
+}
+
 std::shared_ptr<IExecutionProviderFactory> MIGraphXProviderFactoryCreator::Create(int device_id) {
   return s_library_migraphx.Get().CreateExecutionProviderFactory(device_id);
 }
@@ -2114,6 +2147,34 @@ ProviderInfo_MIGraphX& GetProviderInfo_MIGraphX() {
   ORT_THROW("MIGraphX Provider not available, can't get interface for it");
 }
 
+ProviderInfo_EtGlow* TryGetProviderInfo_EtGlow() try {
+  return reinterpret_cast<ProviderInfo_EtGlow*>(s_library_etglow.Get().GetInfo());
+} catch (const std::exception& exception) {
+  LOGS_DEFAULT(ERROR) << exception.what();
+  return nullptr;
+}
+
+ProviderInfo_EtGlow& GetProviderInfo_EtGlow() {
+  if (auto* info = TryGetProviderInfo_EtGlow())
+    return *info;
+
+  ORT_THROW("EtGlow Provider not available, can't get interface for it");
+}
+
+ProviderInfo_EtGlow* TryGetProviderInfo_EtGlow_Test() try {
+  return reinterpret_cast<ProviderInfo_EtGlow*>(s_library_etglow_test.Get().GetInfo());
+} catch (const std::exception& exception) {
+  LOGS_DEFAULT(ERROR) << exception.what();
+  return nullptr;
+}
+
+ProviderInfo_EtGlow& GetProviderInfo_EtGlow_Test() {
+  if (auto* info = TryGetProviderInfo_EtGlow_Test())
+    return *info;
+
+  ORT_THROW("EtGlow test Provider not available, can't get interface for it");
+}
+
 void CopyGpuToCpu(
     void* dst_ptr,
     const void* src_ptr,
@@ -3000,3 +3061,99 @@ ORT_API_STATUS_IMPL(OrtApis::SessionOptionsAppendExecutionProvider_VitisAI, _In_
   return nullptr;
   API_IMPL_END
 }
+
+ORT_API_STATUS_IMPL(OrtApis::SessionOptionsAppendExecutionProvider_ETGLOW,
+                    _In_ OrtSessionOptions* options, _In_ const OrtEtGlowProviderOptions* etglow_options) {
+  API_IMPL_BEGIN
+  auto factory = onnxruntime::EtGlowProviderFactoryCreator::Create(etglow_options);
+  if (!factory) {
+    return OrtApis::CreateStatus(ORT_FAIL, "SessionOptionsAppendExecutionProvider_ETGLOW: Failed to load shared library");
+  }
+
+  options->provider_factories.push_back(factory);
+  return nullptr;
+  API_IMPL_END
+}
+
+ORT_API_STATUS_IMPL(OrtApis::CreateEtGlowProviderOptions, _Outptr_ OrtEtGlowProviderOptions** out) {
+  API_IMPL_BEGIN
+#ifdef USE_ETGLOW
+  auto options = std::make_unique<OrtEtGlowProviderOptions>();
+  *out = options.release();
+  return nullptr;
+#else
+  ORT_UNUSED_PARAMETER(out);
+  return CreateStatus(ORT_FAIL, "ETGLOW execution provider is not enabled in this build.");
+#endif
+  API_IMPL_END
+}
+
+ORT_API_STATUS_IMPL(OrtApis::UpdateEtGlowProviderOptions,
+                    _Inout_ OrtEtGlowProviderOptions* etglow_options,
+                    _In_reads_(num_keys) const char* const* provider_options_keys,
+                    _In_reads_(num_keys) const char* const* provider_options_values,
+                    size_t num_keys) {
+  API_IMPL_BEGIN
+#ifdef USE_ETGLOW
+  onnxruntime::ProviderOptions provider_options_map;
+  for (size_t i = 0; i != num_keys; ++i) {
+    if (provider_options_keys[i] == nullptr || provider_options_keys[i][0] == '\0' ||
+        provider_options_values[i] == nullptr || provider_options_values[i][0] == '\0') {
+      return OrtApis::CreateStatus(ORT_INVALID_ARGUMENT, "key/value cannot be empty");
+    }
+
+    provider_options_map[provider_options_keys[i]] = provider_options_values[i];
+  }
+
+  onnxruntime::s_library_etglow.Get().UpdateProviderOptions(reinterpret_cast<void*>(etglow_options), provider_options_map);
+  return nullptr;
+#else
+  ORT_UNUSED_PARAMETER(etglow_options);
+  ORT_UNUSED_PARAMETER(provider_options_keys);
+  ORT_UNUSED_PARAMETER(provider_options_values);
+  ORT_UNUSED_PARAMETER(num_keys);
+  return CreateStatus(ORT_FAIL, "ETGLOW execution provider is not enabled in this build.");
+#endif
+  API_IMPL_END
+}
+
+ORT_API_STATUS_IMPL(OrtApis::GetEtGlowProviderOptionsAsString,
+                    _In_ const OrtEtGlowProviderOptions* etglow_options, _Inout_ OrtAllocator* allocator,
+                    _Outptr_ char** ptr) {
+  API_IMPL_BEGIN
+#ifdef USE_ETGLOW
+  onnxruntime::ProviderOptions options =
+      onnxruntime::s_library_etglow.Get().GetProviderOptions(reinterpret_cast<const void*>(etglow_options));
+  auto it = options.begin();
+  std::string options_str;
+
+  while (it != options.end()) {
+    if (!it->second.empty()) {
+      if (!options_str.empty()) {
+        options_str += ";";
+      }
+      options_str += it->first;
+      options_str += "=";
+      options_str += it->second;
+    }
+    it++;
+  }
+
+  *ptr = onnxruntime::StrDup(options_str, allocator);
+  return nullptr;
+#else
+  ORT_UNUSED_PARAMETER(etglow_options);
+  ORT_UNUSED_PARAMETER(allocator);
+  ORT_UNUSED_PARAMETER(ptr);
+  return CreateStatus(ORT_FAIL, "ETGLOW execution provider is not enabled in this build.");
+#endif
+  API_IMPL_END
+}
+
+ORT_API(void, OrtApis::ReleaseEtGlowProviderOptions, _Frees_ptr_opt_ OrtEtGlowProviderOptions* ptr) {
+#ifdef USE_ETGLOW
+  std::unique_ptr<OrtEtGlowProviderOptions> p(ptr);
+#else
+  ORT_UNUSED_PARAMETER(ptr);
+#endif
+}
