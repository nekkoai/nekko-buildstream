diff --git a/device-management/.clang-format b/device-management/.clang-format
new file mode 100644
index 00000000..6b902d87
--- /dev/null
+++ b/device-management/.clang-format
@@ -0,0 +1,108 @@
+---
+Language:        Cpp
+# BasedOnStyle:  LLVM
+AccessModifierOffset: -2
+AlignAfterOpenBracket: Align
+AlignConsecutiveAssignments: false
+AlignConsecutiveDeclarations: false
+AlignEscapedNewlines: Right
+AlignOperands:   true
+AlignTrailingComments: true
+AllowAllParametersOfDeclarationOnNextLine: true
+AllowShortBlocksOnASingleLine: false
+AllowShortCaseLabelsOnASingleLine: false
+AllowShortFunctionsOnASingleLine: false
+AllowShortIfStatementsOnASingleLine: false
+AllowShortLoopsOnASingleLine: false
+AlwaysBreakAfterDefinitionReturnType: None
+AlwaysBreakAfterReturnType: None
+AlwaysBreakBeforeMultilineStrings: false
+AlwaysBreakTemplateDeclarations: false
+BinPackArguments: true
+BinPackParameters: true
+BraceWrapping:
+  AfterClass:      false
+  AfterControlStatement: false
+  AfterEnum:       false
+  AfterFunction:   false
+  AfterNamespace:  false
+  AfterObjCDeclaration: false
+  AfterStruct:     false
+  AfterUnion:      false
+  BeforeCatch:     false
+  BeforeElse:      false
+  IndentBraces:    false
+  SplitEmptyFunction: true
+  SplitEmptyRecord: true
+  SplitEmptyNamespace: true
+BreakBeforeBinaryOperators: None
+BreakBeforeBraces: Attach
+BreakBeforeInheritanceComma: false
+BreakBeforeTernaryOperators: true
+BreakConstructorInitializersBeforeComma: false
+BreakConstructorInitializers: BeforeComma
+BreakAfterJavaFieldAnnotations: false
+BreakStringLiterals: true
+ColumnLimit:     120
+CommentPragmas:  '^ IWYU pragma:'
+CompactNamespaces: false
+ConstructorInitializerAllOnOneLineOrOnePerLine: false
+ConstructorInitializerIndentWidth: 2
+ContinuationIndentWidth: 2
+Cpp11BracedListStyle: true
+DerivePointerAlignment: false
+DisableFormat:   false
+ExperimentalAutoDetectBinPacking: false
+FixNamespaceComments: true
+ForEachMacros:
+  - foreach
+  - Q_FOREACH
+  - BOOST_FOREACH
+IncludeCategories:
+  - Regex:           '^"(llvm|llvm-c|clang|clang-c)/'
+    Priority:        2
+  - Regex:           '^(<|"(gtest|gmock|isl|json)/)'
+    Priority:        3
+  - Regex:           '.*'
+    Priority:        1
+IncludeIsMainRegex: '(Test)?$'
+IndentCaseLabels: false
+IndentWidth:     2
+IndentWrappedFunctionNames: false
+JavaScriptQuotes: Leave
+JavaScriptWrapImports: true
+KeepEmptyLinesAtTheStartOfBlocks: true
+MacroBlockBegin: ''
+MacroBlockEnd:   ''
+MaxEmptyLinesToKeep: 1
+NamespaceIndentation: None
+ObjCBlockIndentWidth: 2
+ObjCSpaceAfterProperty: false
+ObjCSpaceBeforeProtocolList: true
+PenaltyBreakAssignment: 2
+PenaltyBreakBeforeFirstCallParameter: 19
+PenaltyBreakComment: 300
+PenaltyBreakFirstLessLess: 120
+PenaltyBreakString: 1000
+PenaltyExcessCharacter: 1000000
+PenaltyReturnTypeOnItsOwnLine: 60
+PointerAlignment: Left
+ReflowComments:  true
+SortIncludes:    true
+SortUsingDeclarations: true
+SpaceAfterCStyleCast: false
+SpaceAfterTemplateKeyword: true
+SpaceBeforeAssignmentOperators: true
+SpaceBeforeParens: ControlStatements
+SpaceInEmptyParentheses: false
+SpacesBeforeTrailingComments: 1
+SpacesInAngles:  false
+SpacesInContainerLiterals: true
+SpacesInCStyleCastParentheses: false
+SpacesInParentheses: false
+SpacesInSquareBrackets: false
+Standard:        C++11
+TabWidth:        2
+UseTab:          Never
+...
+
diff --git a/device-management/.gitignore b/device-management/.gitignore
new file mode 100644
index 00000000..666f992d
--- /dev/null
+++ b/device-management/.gitignore
@@ -0,0 +1,7 @@
+build
+cmake-build-*
+
+test_package/build
+*.lock
+
+lockfiles_info.json
\ No newline at end of file
diff --git a/device-management/.gitlab-ci.yml b/device-management/.gitlab-ci.yml
new file mode 100644
index 00000000..fa5790fa
--- /dev/null
+++ b/device-management/.gitlab-ci.yml
@@ -0,0 +1,202 @@
+include:
+  - project: 'esperantotech/software/gitlab-ci-common'
+    ref: 1be8a1ec31da665910e1b2b193fcfa1d05866299
+    file:
+      - rules/generic-workflow-conan.yaml
+      - pods/nano-pod.yaml
+      - pods/large-pod.yaml
+      - jobs/generic-k8s-job.yaml
+      - jobs/sonarqube-job.yaml
+      - rules/exec_maybe_interactively.yaml
+      - jobs/check-top-of-master-template.yaml
+      - jobs/sw-platform-trigger-template.yaml
+  - project: esperantotech/software/gitlab-ci-common
+    ref: master
+    file:
+      - jobs/conan-jobs.yaml
+
+  - project: 'esperantotech/software/sw-platform'
+    ref: develop/system-sw
+    file:
+      - 'gitlab-ci/system-sw/misc/verify-merge-request.yaml'
+
+stages:
+  - generate_build
+  - build
+  - test
+  - deploy
+
+default:
+  interruptible: true
+
+variables:
+  # These two variables are consumed by the jobs from /jobs/sw-platform-trigger.yaml
+  SW_PLATFORM_BRANCH: develop/system-sw
+  PIPELINE_CI_SUBPROJECT: device-management
+
+
+# Only run job in these cases:
+# - if it's a tag pipeline
+# - if there is a commit pushed or merged to the default branch (pre-release)
+.release_job:
+  rules:
+    - &release_job_rule
+      if: $CI_COMMIT_TAG || ($CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH)
+
+# Only run job in these cases:
+# - if it's a tag pipeline
+# - if there is a commit pushed or merged to the default branch (pre-release)
+# - if there is a MR open (pre-release, unstable)
+.release_or_development_job:
+  rules:
+    - &release_or_development_job_rule
+      if: $CI_COMMIT_TAG || ($CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH) || ($CI_PIPELINE_SOURCE == "merge_request_event")
+
+# Only run job in these cases:
+# - if there is a MR open
+.development_job:
+  rules:
+    - &development_job_rule
+      if: ($CI_PIPELINE_SOURCE == "merge_request_event") && ($CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_DEFAULT_BRANCH)
+
+###############################################################################
+###############################################################################
+###############################################################################
+
+verify_project_changes:
+  extends:
+    - .template_job
+    - .pod_nano
+    - .verify_merge_request
+  image: docker-sw-team.sc-artifactory1.esperanto.ai/convoke/ubuntu-22.04-et-sw-platform:0.0.12
+  stage: .pre
+  rules:
+    - *development_job_rule
+  variables:
+    PROJ_VER_FILE_NAME: CMakeLists.txt
+
+####
+
+clang-format:
+  extends:
+    - .template_job
+    - .pod_nano
+  image: docker-sw-team.sc-artifactory1.esperanto.ai/convoke/ubuntu-22.04-et-sw-platform:0.0.12
+  stage: .pre
+  rules:
+    - *development_job_rule
+  variables:
+    CMD_SCRIPT: |
+      git fetch origin master
+      git clang-format --style file --diff origin/master --extensions cc,cpp,h
+      git clang-format --style file --diff origin/master --extensions cc,cpp,h | grep -q -e "clang-format did not modify any files$" -e "^no modified files to format$"
+
+###############################################################################
+###############################################################################
+###############################################################################
+
+create-sw-platform-branch:
+  extends: .create-sw-platform-branch
+  stage: generate_build
+  needs:
+    - verify_project_changes
+    - clang-format
+  rules:
+    - *development_job_rule
+
+generate_build:conan:
+  extends:
+    - .pod_nano
+    - .template_job
+    - .template-conan-linux-ubuntu22.04-gcc11
+  stage: generate_build
+  rules:
+    - *release_or_development_job_rule
+  needs:
+    - job: verify_project_changes
+      optional: true
+    - job: clang-format
+      optional: true
+  variables:
+    TIMEOUT: 15m
+    PYTHONIOENCODING: utf-8
+    CMD_BUILD: |
+      cd conan
+      python3 -m pip install "ecpt>=2.0.0,<3.0.0" --index-url https://sc-artifactory1.esperanto.ai/artifactory/api/pypi/pypi-virtual/simple
+      python3 -m ci_build
+  artifacts:
+    expire_in: 4h
+    paths:
+      - conan/build_pipeline.yml
+      - conan/lockfiles_info.json
+
+###############################################################################
+###############################################################################
+###############################################################################
+
+create-sw-platform-trigger:
+  extends: .create-sw-platform-trigger
+  stage: build
+  needs:
+    - create-sw-platform-branch
+  rules:
+    - *development_job_rule
+
+build:conan:
+  extends:
+    - .exec_maybe_interactively
+  stage: build
+  rules:
+    - *release_or_development_job_rule
+  needs:
+    - generate_build:conan
+  trigger:
+    include:
+      - artifact: conan/build_pipeline.yml
+        job: generate_build:conan
+    strategy: depend
+
+###############################################################################
+###############################################################################
+###############################################################################
+
+tests:integration-repo:
+  extends: .meta-trigger
+  stage: test
+  needs:
+    - create-sw-platform-trigger
+    - build:conan
+  rules:
+    - *development_job_rule
+  trigger:
+    strategy: depend
+    include:
+      - artifact: generated-trigger-job.yaml
+        job: create-sw-platform-trigger
+
+###############################################################################
+###############################################################################
+###############################################################################
+
+on_success:promote:
+  extends:
+    - .pod_nano
+    - .template_job
+    - .template-conan-linux-ubuntu22.04-gcc11
+  stage: deploy
+  rules:
+    - *release_job_rule
+  needs:
+    - generate_build:conan
+    - build:conan
+  variables:
+    PYTHONIOENCODING: utf-8
+    CMD_BUILD: |
+      cd conan
+      python3 -m pip install "ecpt>=2.0.0,<3.0.0" --index-url https://sc-artifactory1.esperanto.ai/artifactory/api/pypi/pypi-virtual/simple
+      python3 -m ci_promote
+
+
+###############################################################################
+###############################################################################
+###############################################################################
diff --git a/device-management/.gitmodules b/device-management/.gitmodules
new file mode 100644
index 00000000..e69de29b
diff --git a/device-management/CHANGELOG.md b/device-management/CHANGELOG.md
new file mode 100644
index 00000000..38a001c5
--- /dev/null
+++ b/device-management/CHANGELOG.md
@@ -0,0 +1,295 @@
+# Changelog
+All notable changes to this project will be documented in this file.
+
+The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
+and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
+
+[[_TOC_]]
+
+## [Unreleased]
+### Added
+### Changed
+- [CI] updated docker to ubuntu 22.04
+### Deprecated
+### Removed
+### Fixed
+### Security
+
+## [0.18.0] - 2024-04-29
+### Added
+- [SW-19030] Add new commands DM_CMD_SET_VMIN_LUT and DM_CMD_GET_VMIN_LUT to the commandCodeTable
+### Changed
+### Deprecated
+### Removed
+### Fixed
+- [SW-19030] Fix memcpy size
+- [SW-20671]: add missing return statement
+- Updated rules for test which require multi device
+### Security
+
+## [0.17.0] - 2024-03-27
+### Added
+- [CS-226] Add support for FRU commands 
+- Add GET/SET FRU tests
+### Changed
+- Initialize FRU test data
+### Deprecated
+### Removed
+- Removing UpdateFirmware to reduce execution time, improve survivability of Flash
+### Fixed
+- Fix type casting in utest
+- Fix tests/TestDevMgmtApiSyncCmds.cpp gcc11 compatibility
+### Security
+
+## [0.16.0] - 2024-01-30
+### Added
+- [SW-19638] Add control option to dump bin traces in files
+### Changed
+- [SW-19638] Disabled dump of raw traces to bin files
+- [SW-20169] Double fw update test timeout for multiple devices 
+### Deprecated
+### Removed
+### Fixed
+### Security
+
+## [0.15.0] - 2023-12-15
+### Added
+- [SW-19470] Added memory sanitizers support
+- [SW-18613] Added support to change the PMIC FW metadata in the flash image and re-generate it for testing.
+- Adding updateFirmwareImageAndResetMultiDevice test.
+- Generate packages with linux-ubuntu22.04-x86_64-gcc11-release
+### Changed
+- Disabling setModuleActivePowerManagement since the DVFS is not stable.
+- [SW-18613] Change the test to modify PMIC FW hash instead of PMIC FW version.
+- (Conan) Use Conan 2.0 imports
+### Deprecated
+### Removed
+### Fixed
+- [SW-19324] Fixed nullptr dereference issue in dumpRawTraceBuffer function causing exception when SP trace buffer full event is processed
+- [SW-19698] Extended library to support FMTlib V10
+### Security
+
+## [0.14.0] - 2023-11-07
+### Added
+- [SW-18590] Added firmware update functional and stress tests.
+- [SW-15748] Handling DM events in userspace
+  - Adding DM event processing thread for each device
+### Changed
+- [SW-18398b] Update DevErrorEvent implementation for the skipList usage to add/remove EventType entry from the default skipList without requiring to replace the complete skipList.
+[SW-18797] Improvements for event processor
+  * Do not run event processor during ETSOC reset
+  * Run the thread in detach mode to exit immediately when test completes
+  * Add {init|cleanup}DMTestFramework() calls to reduce code duplication
+### Deprecated
+- [SW-15748] Marked getEvent() API as deprecated, will be replaced with getMDIEvents()
+### Removed
+### Fixed
+- [SW-18926] Fixed trace filter mask in DM tests
+### Security
+
+## [0.13.0] - 2023-09-01
+### Added
+- [SW-18352] Add support to check device error events
+### Changed
+- [SW-18398] Restrict check for device error events
+### Deprecated
+### Removed
+### Fixed
+- [SW-18352b] Fix check device error events logic when isCheckList set to false
+### Security
+
+## [0.12.0] - 2023-08-03
+### Added
+### Changed
+- Adapt CI to gitlab-ci v15
+- [SW-17593] update conan dependency for deviceApi
+- Updating the conan dependencies versions to released components
+### Deprecated
+### Removed
+### Fixed
+- [CI] Adapt pipeline and conanfile.py to gitlab.com
+- [SW-17936] Fixed Temperature threshold test case to restore threshold value at the end
+### Security
+
+## [0.11.0] - 2023-06-02
+### Added
+### Changed
+### Deprecated
+### Removed
+### Fixed
+- Increase resetSOC tests timeout for multi-card (8) machines
+- [SW-17936] Fixed TDP test case to restore TDP value at the end
+### Security
+
+## [0.10.0] - 2023-04-19
+### Added
+### Changed
+- [SW-16558] Updated setPCIELaneWidth test to restore the default lane width
+- [SW-16538] Disabled setAndGetModuleVoltage test
+### Deprecated
+### Removed
+### Fixed
+- [SW-16851] Save trace logs when service request times out
+  * Updated the service request timeout to be relatively less than the test timeout to ensure teardown path always executes
+  * Change service request return code checks from EXPECT to ASSERT to immediately get out of test body
+### Security
+
+## [0.9.0] - 2023-03-15
+### Added
+- [SW-16234] Added test to verify shire cache get/set configuration command
+  - Modify Shire cache configuration test to use scp, l2 and l3 sizes in MB
+### Changed
+- (Conan) Generate full SemVer versions only when tagging the project. Generate pre-release otherwise.
+- (CI) Enable tags pipelines and filter out MR "development/testing" jobs from release pipeline
+- [SW-16237] Enabled MDI commands in release mode and fixed MDI tests
+- [SW-16237] Added MDI privileged region access validation tests
+### Deprecated
+### Removed
+- (Conan) Remove setting CMAKE_MODULE_PATH with cmake-modules
+### Fixed
+- [SW-15389] Fixed MDI tests
+### Security
+
+## [0.8.0] - 2023-01-10
+### Added
+- Updating the test plan for resetSOC tests.
+- Added NOPARALLEL label for tests which should not be run in parallel regression.
+- [SW-15160] Added resetSOC stress tests.
+- [SW-15161] Added resetSOCWithOpsInUse test
+### Changed
+- [SW-14288] Enabled back setAndGetModuleVoltage test.
+- Updated deviceApi version in Conan requirements.
+- Replaced NOPARALLEL label with PARALLEL env variable. The setAndGetModuleVoltage test will be skipped when PARALLEL env is set.
+### Deprecated
+### Removed
+- Removed device-fw-test-plan.ods.
+- [SW-14210] Fixed bug in setThrottlePowerStatus test
+### Fixed
+- [SW-15493] Fixed getModuleMemorySizeMB test to expect multiple values
+### Security
+
+## [0.7.0] - 2022-10-21
+### Added
+- [SW-13832] Add new command DM_CMD_GET_MM_STATS to the commandCodeTable
+- [SW-13851] Add test for command DM_CMD_SET_DM_STATS_RUN_CONTROL
+- [SW-14061] Added DM_CMD_GET_ASIC_VOLTAGE test.
+- [SW-14337] Add ETSOC reset handling and its test case.
+- [SW-14409] Add ETSOC reset per device handling.
+### Changed
+- [SW-14061] Enabled back setAndGetModuleVoltage test.
+- [SW-14288] Disabled the test until SW-14288 is resolved.
+- [SW-14288] Changing voltage percentage drop to zero in setAndGetModuleVoltage test.
+- [FV-317] Updating asic_voltage elements to be 16bits
+### Deprecated
+### Removed
+### Fixed
+- [SW-14061] Fixing the convertion of binary to mV and mV to binary voltage values.
+### Security
+
+## [0.6.0] - 2022-09-05
+### Added
+- [SW-13954] Added setAndGetModulePartNumber
+- [SW-13954] Added setAndGetModuleVoltage
+- Ranges for conan packages version requirements.
+### Changed
+- [SW-13850] Disabling setThrottlePowerStatus test on silicon until SW-13953 is resolved
+- [SW-13850] Disabling setAndGetModuleFrequency test until SW-13952 is resolved
+- [SW-13953] Removing workarrounds for trace related tests and fixed SP trace log levels
+- [SW-13954] updated getFirmwareRevisions test to also print pmic_v
+- [SW-14044] Updating power value to remove hex conversion
+- Moved setAndGetModuleFrequency test to Ops node dependent category of tests.
+- [SW-14115] Converting module power from 10mW to W.
+### Deprecated
+### Removed
+### Fixed
+- [SW-13978] Enabling back setAndGetModuleFrequency
+- Fixed setTraceControl test and fixed a log.
+### Security
+
+## [0.5.0] - 2022-08-15
+### Added
+- [SW-6111] Add basic info to Device Management Overview section.
+
+### Changed
+- Updated `setModuleFrequency` test to revert back to original frequencies and
+  check by setting a list of test frequencies.
+- Renamed `setModuleFrequency` to `setAndGetModuleFrequency` because now this
+  test sets the frequency and validates it by reading back those frequencies.
+- [SW-13583] Enabled getFWBootstatus test
+- [SW-13620] Add new command DM_CMD_GET_SP_STATS to the commandCodeTable
+- Show output on failure for mix tests.
+- Disabled getFWBootstatus test. To be fixed under SW-13807.
+### Deprecated
+### Removed
+### Fixed
+- Conanfile .libs specification
+### Security
+
+## [0.4.0] - 2022-07-07
+### Added
+### Changed
+- Disabled `getModuleVoltage` test on Target::Silicon. The test runs fine in the
+  beginning but in longer runs of ops + mgmt regression, it times out.
+- Compare received speed with either GEN3 or GEN4 speed in test
+  `getModulePCIEPortsMaxSpeed`. This will be revert back to comparing the speed
+  with max_link_speed sysfs attribute once fixed in SW-13272.
+- Adding a delay in getSpTraceBuffer test as a temporary workaround.
+- Disable getModulePower test on SysEMU.
+- `setThrottlePowerStatus` Removed trace enable/disable within test.
+-  Updated test `getModuleSerialNumber`. Enabled test on silicon
+- [SW-13282] Enabled `getModulePower` and `getModuleVoltage` on silicon and SysEMU.
+### Deprecated
+### Removed
+### Fixed
+- [SW-13282] Skipped validation in `getModulePower` and `getModuleVoltage` for SysEMU and Loopback.
+### Security
+
+## [0.3.0] - 2022-07-4
+### Added
+- Added .clang-format file based on LLVM style.
+- Enforce updation of CHANGELOG.md and patch version in merge request pipelines.
+### Changed
+- `getModuleFWRevision` test now prints out extracted firmware versions instead
+  of comparing with hard-coded versions. Included package fmt for formatting of
+  these prints.
+- `getDeviceErrorEvents` test allows passing of test with warning message if
+  dmesg is inaccessible.
+- Disable only the un-supported tests for Target::Silicon instead of all tests
+  of that management service.
+- [SW-13218] Re-enabling the getModuleMemorySizeMB and getModuleMemoryVendorPartNumber tests for silicon.
+- `getModulePCIENumPortsMaxSpeed` test renamed to `getModulePCIEPortsMaxSpeed`.
+- Disabled getModulePCIEPortsMaxSpeed test on SysEMU.
+- Disabled setPCIELinkSpeed test on Silicon. To be enabled back in SW-13272
+- Disable active power management before exiting test setModuleActivePowerManagement.
+### Deprecated
+### Removed
+- Workaround for SP Trace
+### Fixed
+- `getDeviceErrorEvents` test now reads error events information from sysfs
+  counters instead of reading it from dmesg. Enabling this test back for
+  Target::Silicon.
+- `getModulePCIEPortsMaxSpeed` test now compare the received max link speed with
+  sysfs attribute file `max_link_speed`. Enabling this test back for
+  Target::Silicon.
+- Include .cc file types scan in clang CI job.
+### Security
+
+## [0.2.0] - 2022-06-24
+### Added
+- Added new test for MM stat buffer under Ops node dependant tests category.
+- Added a local copy of trace buffer data.
+### Changed
+### Deprecated
+### Removed
+### Fixed
+- Catching exception from waitForEpollEventsServiceProcessor().
+### Security
+
+## [0.1.2] - 2022-06-20
+### Added
+- This CHANGELOG file.
+### Changed
+### Deprecated
+### Removed
+### Fixed
+### Security
diff --git a/device-management/CMakeLists.txt b/device-management/CMakeLists.txt
new file mode 100644
index 00000000..171890aa
--- /dev/null
+++ b/device-management/CMakeLists.txt
@@ -0,0 +1,131 @@
+#------------------------------------------------------------------------------
+# Copyright (C) 2020, Esperanto Technologies Inc.
+# The copyright to the computer program(s) herein is the
+# property of Esperanto Technologies, Inc. All Rights Reserved.
+# The program(s) may be used and/or copied only with
+# the written permission of Esperanto Technologies and
+# in accordance with the terms and conditions stipulated in the
+# agreement/contract under which the program(s) have been supplied.
+#------------------------------------------------------------------------------
+
+cmake_minimum_required(VERSION 3.17)
+project(deviceManagement VERSION 0.19.0 LANGUAGES C CXX)
+
+include(GNUInstallDirs)
+
+find_package(deviceApi REQUIRED)
+find_package(deviceLayer REQUIRED)
+find_package(hostUtils REQUIRED)
+
+option(BUILD_TESTS "Build tests" ON)
+option(BUILD_DOC "Build documentation" ON)
+
+add_library(DM_obj OBJECT
+    src/DeviceManagement.cc
+    src/utils.h
+)
+target_compile_features(DM_obj PUBLIC cxx_std_17)
+target_include_directories(DM_obj
+    PUBLIC
+        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
+        $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
+    PRIVATE
+        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/src>
+)
+
+if(CMAKE_BUILD_TYPE STREQUAL "Debug")
+    target_compile_options(DM_obj
+        PUBLIC
+            -DMINION_DEBUG_INTERFACE
+            -UNDEBUG
+    )
+else()
+    target_compile_options(DM_obj
+        PUBLIC
+            -UMINION_DEBUG_INTERFACE
+            -DNDEBUG
+    )
+endif()
+
+set_target_properties(DM_obj PROPERTIES
+    PUBLIC_HEADER "include/deviceManagement/DeviceManagement.h;include/deviceManagement/dm.h"
+    POSITION_INDEPENDENT_CODE TRUE
+)
+#TODO: target_link_directories should be forbidden
+target_link_directories(DM_obj PUBLIC ${CMAKE_INSTALL_PREFIX}/lib)
+target_link_libraries(DM_obj
+    PUBLIC
+        deviceApi::deviceApi
+        deviceLayer::deviceLayer
+    PRIVATE
+        hostUtils::logging
+)
+
+# Generate shared library
+add_library(DM SHARED)
+add_library(deviceManagement::DM ALIAS DM)
+target_link_libraries(DM PUBLIC DM_obj)
+
+# Generate static library
+add_library(DM_static STATIC)
+add_library(deviceManagement::DM_static ALIAS DM_static)
+target_link_libraries(DM_static PUBLIC DM_obj)
+
+install(TARGETS DM_obj DM DM_static
+    EXPORT deviceManagementTargets
+    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
+    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
+    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
+    PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/deviceManagement
+)
+
+# Install the export set for use with the install-tree
+install(EXPORT deviceManagementTargets
+    DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/deviceManagement
+    NAMESPACE deviceManagement::
+)
+
+if (BUILD_TESTS)
+    add_subdirectory(tests)
+endif()
+
+if (BUILD_DOC)
+    set(DOCUMENTATION_INSTALL_DIR  "${CMAKE_INSTALL_PREFIX}" CACHE STRING "Documentation installation path")
+
+    # check if Doxygen is installed
+    find_package(Doxygen)
+    if (DOXYGEN_FOUND)
+        add_subdirectory(doc)
+    else (DOXYGEN_FOUND)
+        message("Doxygen need to be installed to generate the doxygen documentation")
+    endif (DOXYGEN_FOUND)
+endif()
+
+##### Package
+
+# Add package information
+include(CMakePackageConfigHelpers)
+
+configure_package_config_file(
+    ${CMAKE_CURRENT_SOURCE_DIR}/deviceManagementConfig.cmake.in
+    ${CMAKE_CURRENT_BINARY_DIR}/deviceManagementConfig.cmake
+    INSTALL_DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/deviceManagement
+)
+
+write_basic_package_version_file(
+    ${CMAKE_CURRENT_BINARY_DIR}/deviceManagementConfigVersion.cmake
+    VERSION ${CMAKE_PROJECT_VERSION}
+    COMPATIBILITY SameMajorVersion
+)
+
+install(FILES
+    ${CMAKE_CURRENT_BINARY_DIR}/deviceManagementConfig.cmake
+    ${CMAKE_CURRENT_BINARY_DIR}/deviceManagementConfigVersion.cmake
+    DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/deviceManagement
+)
+
+# export targets from the build tree (this allows consuming generated deviceManagementTargets.cmake without having to install first - not relocatable)
+export(TARGETS DM_obj DM DM_static
+    FILE "${PROJECT_BINARY_DIR}/deviceManagementTargets.cmake"
+    NAMESPACE deviceManagement::
+)
diff --git a/device-management/README.md b/device-management/README.md
new file mode 100644
index 00000000..e69de29b
diff --git a/device-management/cmake/FindSphinx.cmake b/device-management/cmake/FindSphinx.cmake
new file mode 100644
index 00000000..9d252e8b
--- /dev/null
+++ b/device-management/cmake/FindSphinx.cmake
@@ -0,0 +1,27 @@
+# CMake find_package() Module for Sphinx documentation generator
+# http://sphinx-doc.org/
+#
+# Example usage:
+#
+# find_package(Sphinx)
+#
+# If successful the following variables will be defined
+# SPHINX_FOUND
+# SPHINX_EXECUTABLE
+
+find_program(SPHINX_EXECUTABLE
+             NAMES sphinx-build sphinx-build2
+             DOC "Path to sphinx-build executable")
+
+# Handle REQUIRED and QUIET arguments
+# this will also set SPHINX_FOUND to true if SPHINX_EXECUTABLE exists
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(Sphinx
+                                  "Failed to locate sphinx-build executable"
+                                  SPHINX_EXECUTABLE)
+
+# Provide options for controlling different types of output
+option(SPHINX_OUTPUT_HTML "Output standalone HTML files" ON)
+option(SPHINX_OUTPUT_MAN "Output man pages" ON)
+
+option(SPHINX_WARNINGS_AS_ERRORS "When building documentation treat warnings as errors" ON)
diff --git a/device-management/conan/ci_build.py b/device-management/conan/ci_build.py
new file mode 100644
index 00000000..d658e316
--- /dev/null
+++ b/device-management/conan/ci_build.py
@@ -0,0 +1,21 @@
+#!/usr/bin/env python3
+import os
+
+from ecpt.packager import Packager
+
+
+def main():
+    conanfile_path = os.path.join(os.path.dirname(__file__), "..", "conanfile.py")
+    
+    build = Packager(ci_build=True)
+    build.add_package(conanfile_path)
+    #build.add_consumer("ss/0.11.0@")
+    build.add_configuration("default", "linux-ubuntu18.04-x86_64-gcc7-release")
+    build.add_configuration("default", "linux-ubuntu22.04-x86_64-gcc11-release")
+    build.report()
+
+    build.run()
+
+
+if __name__ == '__main__':
+    main()
diff --git a/device-management/conan/ci_promote.py b/device-management/conan/ci_promote.py
new file mode 100644
index 00000000..ebf0f537
--- /dev/null
+++ b/device-management/conan/ci_promote.py
@@ -0,0 +1,15 @@
+#!/usr/bin/env python3
+import os
+
+from ecpt.packager import Packager
+
+
+def main():
+    conanfile_path = os.path.join(os.path.dirname(__file__), "..", "conanfile.py")
+    
+    build = Packager()
+    build.promote("lockfiles_info.json")
+
+
+if __name__ == '__main__':
+    main()
diff --git a/device-management/conanfile.py b/device-management/conanfile.py
new file mode 100644
index 00000000..9b9bb802
--- /dev/null
+++ b/device-management/conanfile.py
@@ -0,0 +1,99 @@
+from conan import ConanFile
+from conan.errors import ConanInvalidConfiguration
+from conan.tools.cmake import CMake, CMakeToolchain
+from conan.tools.layout import cmake_layout
+from conan.tools.files import rmdir
+import os
+
+
+class DeviceManagementConan(ConanFile):
+    name = "deviceManagement"
+    url = "git@gitlab.com:esperantotech/software/devicemanagement.git"
+    homepage = "https://gitlab.com/esperantotech/software/devicemanagement"
+    description = ""
+    license = "Esperanto Technologies"
+
+    settings = "os", "arch", "compiler", "build_type"
+    options = {
+        "fPIC": [True, False],
+        "with_tests": [True, False],
+    }
+    default_options = {
+        "fPIC": True,
+        "with_tests": False,
+    }
+
+    generators = "CMakeDeps"
+
+    python_requires = "conan-common/[>=1.1.0 <2.0.0]"
+
+    def set_version(self):
+        get_version = self.python_requires["conan-common"].module.get_version
+        self.version = get_version(self, self.name)
+
+    def requirements(self):
+        self.requires("deviceApi/2.3.0")
+        self.requires("deviceLayer/2.2.0")
+        self.requires("hostUtils/0.3.0")
+
+    def validate(self):
+        check_req_min_cppstd = self.python_requires["conan-common"].module.check_req_min_cppstd
+        check_req_min_cppstd(self, "17")
+
+        if self.options.with_tests:
+            raise ConanInvalidConfiguration("Support for building with tests not yet implemented.")
+
+    def export(self):
+        register_scm_coordinates = self.python_requires["conan-common"].module.register_scm_coordinates
+        register_scm_coordinates(self)
+
+    def layout(self):
+        cmake_layout(self)
+        self.folders.source = "."
+
+    def export_sources(self):
+        copy_sources_if_scm_dirty = self.python_requires["conan-common"].module.copy_sources_if_scm_dirty
+        copy_sources_if_scm_dirty(self)
+
+    def source(self):
+        get_sources_if_scm_pristine = self.python_requires["conan-common"].module.get_sources_if_scm_pristine
+        get_sources_if_scm_pristine(self)
+
+    def generate(self):
+        tc = CMakeToolchain(self)
+        tc.variables["BUILD_TESTS"] = self.options.with_tests
+        tc.variables["BUILD_DOC"] = False
+        tc.variables["CMAKE_INSTALL_LIBDIR"] = "lib"
+        tc.generate()
+
+    def build(self):
+        cmake = CMake(self)
+        cmake.configure()
+        cmake.build()
+
+    def package(self):
+        cmake = CMake(self)
+        cmake.install()
+        rmdir(self, os.path.join(self.package_folder, "lib", "cmake"))
+
+    def package_info(self):
+        # library components
+        self.cpp_info.components["DM"].set_property("cmake_target_name", "deviceManagement::DM")
+        self.cpp_info.components["DM"].requires = ["deviceApi::deviceApi", "deviceLayer::deviceLayer", "hostUtils::logging"]
+        self.cpp_info.components["DM"].libs = ["DM"]
+        self.cpp_info.components["DM"].includedirs = ["include"]
+        self.cpp_info.components["DM"].libdirs = ["lib"]
+        if self.settings.build_type != "Debug":
+            self.cpp_info.components["DM"].defines.append("NDEBUG")
+
+        self.cpp_info.components["DM_static"].set_property("cmake_target_name", "deviceManagement::DM_static")
+        self.cpp_info.components["DM_static"].requires = ["deviceApi::deviceApi", "deviceLayer::deviceLayer", "hostUtils::logging"]
+        self.cpp_info.components["DM_static"].libs = ["DM_static"]
+        self.cpp_info.components["DM_static"].includedirs = ["include"]
+        self.cpp_info.components["DM_static"].libdirs = ["lib"]
+        if self.settings.build_type != "Debug":
+            self.cpp_info.components["DM"].defines.append("NDEBUG")
+
+        bin_path = os.path.join(self.package_folder, "bin")
+        self.output.info("Appending PATH environment variable: {}".format(bin_path))
+        self.env_info.PATH.append(bin_path)
diff --git a/device-management/deviceManagementConfig.cmake.in b/device-management/deviceManagementConfig.cmake.in
new file mode 100644
index 00000000..42c3490b
--- /dev/null
+++ b/device-management/deviceManagementConfig.cmake.in
@@ -0,0 +1,18 @@
+#------------------------------------------------------------------------------
+# Copyright (C) 2020, Esperanto Technologies Inc.
+# The copyright to the computer program(s) herein is the
+# property of Esperanto Technologies, Inc. All Rights Reserved.
+# The program(s) may be used and/or copied only with
+# the written permission of Esperanto Technologies and
+# in accordance with the terms and conditions stipulated in the
+# agreement/contract under which the program(s) have been supplied.
+#------------------------------------------------------------------------------
+
+@PACKAGE_INIT@
+
+find_dependency(deviceApi REQUIRED)
+find_dependency(deviceLayer REQUIRED)
+find_dependency(fmt REQUIRED)
+
+include(${CMAKE_CURRENT_LIST_DIR}/deviceManagementTargets.cmake)
+check_required_components(deviceManagement)
diff --git a/device-management/doc/CMakeLists.txt b/device-management/doc/CMakeLists.txt
new file mode 100644
index 00000000..efcab261
--- /dev/null
+++ b/device-management/doc/CMakeLists.txt
@@ -0,0 +1,106 @@
+#------------------------------------------------------------------------------
+# Copyright (C) 2020, Esperanto Technologies Inc.
+# The copyright to the computer program(s) herein is the
+# property of Esperanto Technologies, Inc. All Rights Reserved.
+# The program(s) may be used and/or copied only with
+# the written permission of Esperanto Technologies and
+# in accordance with the terms and conditions stipulated in the
+# agreement/contract under which the program(s) have been supplied.
+#------------------------------------------------------------------------------
+
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/../cmake")
+find_package(Sphinx REQUIRED)
+
+if(NOT DEFINED SPHINX_THEME)
+    set(SPHINX_THEME default)
+endif()
+
+if(NOT DEFINED SPHINX_THEME_DIR)
+    set(SPHINX_THEME_DIR)
+endif()
+
+# configured documentation tools and intermediate build results
+set(BINARY_BUILD_DIR "${CMAKE_CURRENT_BINARY_DIR}/_build")
+
+# Sphinx cache with pickled ReST documents
+set(SPHINX_CACHE_DIR "${CMAKE_CURRENT_BINARY_DIR}/_doctrees")
+
+# HTML output directory
+set(SPHINX_HTML_DIR "${CMAKE_CURRENT_BINARY_DIR}/html")
+
+configure_file(
+    "${CMAKE_CURRENT_SOURCE_DIR}/Doxyfile.in"
+    "${CMAKE_CURRENT_BINARY_DIR}/Doxyfile"
+    @ONLY)
+
+configure_file(
+    "${CMAKE_CURRENT_SOURCE_DIR}/conf.py.in"
+    "${CMAKE_CURRENT_BINARY_DIR}/conf.py"
+    @ONLY)
+
+file(GLOB_RECURSE DOC_FILES RELATIVE ${CMAKE_CURRENT_SOURCE_DIR}} *.rst *.png)
+
+set(DOC_FILES_DST "")
+foreach(DOC_FILE ${DOC_FILES})
+  add_custom_command(
+    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${DOC_FILE}
+    COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/${DOC_FILE} ${CMAKE_CURRENT_BINARY_DIR}/${DOC_FILE}
+    DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/${DOC_FILE}
+    )
+  list(APPEND DOC_FILES_DST ${CMAKE_CURRENT_BINARY_DIR}/${DOC_FILE})
+endforeach()
+
+
+add_custom_target(doc-html
+    ${SPHINX_EXECUTABLE}
+        -q -b html
+        -d "${SPHINX_CACHE_DIR}"
+        -j auto
+        "${CMAKE_CURRENT_BINARY_DIR}"
+        "${SPHINX_HTML_DIR}"
+    COMMENT "Building HTML documentation with Sphinx"
+    DEPENDS Doxyfile.in
+            conf.py.in
+            ${DOC_FILES_DST}
+  )
+
+install(
+    DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/html
+    DESTINATION ${DOCUMENTATION_INSTALL_DIR}
+    COMPONENT documentation
+    EXCLUDE_FROM_ALL
+    )
+
+set(SPHINX_PDF_DIR "${CMAKE_CURRENT_BINARY_DIR}/latex")
+
+add_custom_target(doc-pdf
+  ${SPHINX_EXECUTABLE}
+        -M latexpdf
+        "${CMAKE_CURRENT_BINARY_DIR}"
+        "${SPHINX_PDF_DIR}"
+  COMMENT "Building PDF documentation with Sphinx"
+  DEPENDS Doxyfile.in
+          conf.py.in
+          ${DOC_FILES_DST}
+)
+
+install(
+    FILES ${CMAKE_CURRENT_BINARY_DIR}/latex/latex/esperantodevicemanagement.pdf
+    DESTINATION ${DOCUMENTATION_INSTALL_DIR}
+    COMPONENT documentation
+    EXCLUDE_FROM_ALL
+  )
+
+add_custom_target(doc-all
+  DEPENDS doc-html doc-pdf
+  )
+
+# Temporary alias to preserve the existing interface
+add_custom_target(doc
+  DEPENDS doc-all
+)
+
+add_custom_target(doc-install
+  COMMAND ${CMAKE_COMMAND} -DCOMPONENT="documentation" -P ${CMAKE_CURRENT_BINARY_DIR}/cmake_install.cmake
+  DEPENDS doc-all
+)
diff --git a/device-management/doc/Doxyfile.in b/device-management/doc/Doxyfile.in
new file mode 100644
index 00000000..713dae97
--- /dev/null
+++ b/device-management/doc/Doxyfile.in
@@ -0,0 +1,2479 @@
+# Doxyfile 1.8.13
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project.
+#
+# All text after a double hash (##) is considered a comment and is placed in
+# front of the TAG it is preceding.
+#
+# All text after a single hash (#) is considered a comment and will be ignored.
+# The format is:
+# TAG = value [value, ...]
+# For lists, items can also be appended using:
+# TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (\" \").
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# This tag specifies the encoding used for all characters in the config file
+# that follow. The default is UTF-8 which is also the encoding used for all text
+# before the first occurrence of this tag. Doxygen uses libiconv (or the iconv
+# built into libc) for the transcoding. See
+# https://www.gnu.org/software/libiconv/ for the list of possible encodings.
+# The default value is: UTF-8.
+
+DOXYFILE_ENCODING      = UTF-8
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded by
+# double-quotes, unless you are using Doxywizard) that should identify the
+# project for which the documentation is generated. This name is used in the
+# title of most generated pages and in a few other places.
+# The default value is: My Project.
+
+PROJECT_NAME           = "Esperanto Software"
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. This
+# could be handy for archiving the generated documentation or if some version
+# control system is used.
+
+PROJECT_NUMBER         = 0.1.0
+
+# Using the PROJECT_BRIEF tag one can provide an optional one line description
+# for a project that appears at the top of each page and should give viewer a
+# quick idea about the purpose of the project. Keep the description short.
+
+PROJECT_BRIEF          = "Software associated with the Esperanto SoC"
+
+# With the PROJECT_LOGO tag one can specify a logo or an icon that is included
+# in the documentation. The maximum height of the logo should not exceed 55
+# pixels and the maximum width should not exceed 200 pixels. Doxygen will copy
+# the logo to the output directory.
+
+PROJECT_LOGO           = @CMAKE_CURRENT_SOURCE_DIR@/etLogo.png
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path
+# into which the generated documentation will be written. If a relative path is
+# entered, it will be relative to the location where doxygen was started. If
+# left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       = @CMAKE_CURRENT_BINARY_DIR@/docs
+
+# If the CREATE_SUBDIRS tag is set to YES then doxygen will create 4096 sub-
+# directories (in 2 levels) under the output directory of each output format and
+# will distribute the generated files over these directories. Enabling this
+# option can be useful when feeding doxygen a huge amount of source files, where
+# putting all generated files in the same directory would otherwise causes
+# performance problems for the file system.
+# The default value is: NO.
+
+CREATE_SUBDIRS         = NO
+
+# If the ALLOW_UNICODE_NAMES tag is set to YES, doxygen will allow non-ASCII
+# characters to appear in the names of generated files. If set to NO, non-ASCII
+# characters will be escaped, for example _xE3_x81_x84 will be used for Unicode
+# U+3044.
+# The default value is: NO.
+
+ALLOW_UNICODE_NAMES    = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all
+# documentation generated by doxygen is written. Doxygen will use this
+# information to generate all constant output in the proper language.
+# Possible values are: Afrikaans, Arabic, Armenian, Brazilian, Catalan, Chinese,
+# Chinese-Traditional, Croatian, Czech, Danish, Dutch, English (United States),
+# Esperanto, Farsi (Persian), Finnish, French, German, Greek, Hungarian,
+# Indonesian, Italian, Japanese, Japanese-en (Japanese with English messages),
+# Korean, Korean-en (Korean with English messages), Latvian, Lithuanian,
+# Macedonian, Norwegian, Persian (Farsi), Polish, Portuguese, Romanian, Russian,
+# Serbian, Serbian-Cyrillic, Slovak, Slovene, Spanish, Swedish, Turkish,
+# Ukrainian and Vietnamese.
+# The default value is: English.
+
+OUTPUT_LANGUAGE        = English
+
+# If the BRIEF_MEMBER_DESC tag is set to YES, doxygen will include brief member
+# descriptions after the members that are listed in the file and class
+# documentation (similar to Javadoc). Set to NO to disable this.
+# The default value is: YES.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES, doxygen will prepend the brief
+# description of a member or function before the detailed description
+#
+# Note: If both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
+# brief descriptions will be completely suppressed.
+# The default value is: YES.
+
+REPEAT_BRIEF           = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator that is
+# used to form the text in various listings. Each string in this list, if found
+# as the leading text of the brief description, will be stripped from the text
+# and the result, after processing the whole list, is used as the annotated
+# text. Otherwise, the brief description is used as-is. If left blank, the
+# following values are used ($name is automatically replaced with the name of
+# the entity):The $name class, The $name widget, The $name file, is, provides,
+# specifies, contains, represents, a, an and the.
+
+ABBREVIATE_BRIEF       = "The $name class" \
+                         "The $name widget" \
+                         "The $name file" \
+                         is \
+                         provides \
+                         specifies \
+                         contains \
+                         represents \
+                         a \
+                         an \
+                         the
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
+# doxygen will generate a detailed section even if there is only a brief
+# description.
+# The default value is: NO.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
+# inherited members of a class in the documentation of that class as if those
+# members were ordinary class members. Constructors, destructors and assignment
+# operators of the base classes will not be shown.
+# The default value is: NO.
+
+INLINE_INHERITED_MEMB  = NO
+
+# If the FULL_PATH_NAMES tag is set to YES, doxygen will prepend the full path
+# before files name in the file list and in the header files. If set to NO the
+# shortest path that makes the file name unique will be used
+# The default value is: YES.
+
+FULL_PATH_NAMES        = YES
+
+# The STRIP_FROM_PATH tag can be used to strip a user-defined part of the path.
+# Stripping is only done if one of the specified strings matches the left-hand
+# part of the path. The tag can be used to show relative paths in the file list.
+# If left blank the directory from which doxygen is run is used as the path to
+# strip.
+#
+# Note that you can specify absolute paths here, but also relative paths, which
+# will be relative from the directory where doxygen is started.
+# This tag requires that the tag FULL_PATH_NAMES is set to YES.
+
+STRIP_FROM_PATH        = @PROJECT_BINARY_DIR@ @PROJECT_SOURCE_DIR@
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the
+# path mentioned in the documentation of a class, which tells the reader which
+# header file to include in order to use a class. If left blank only the name of
+# the header file containing the class definition is used. Otherwise one should
+# specify the list of include paths that are normally passed to the compiler
+# using the -I flag.
+
+STRIP_FROM_INC_PATH    =
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter (but
+# less readable) file names. This can be useful is your file systems doesn't
+# support long names like on DOS, Mac, or CD-ROM.
+# The default value is: NO.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then doxygen will interpret the
+# first line (until the first dot) of a Javadoc-style comment as the brief
+# description. If set to NO, the Javadoc-style will behave just like regular Qt-
+# style comments (thus requiring an explicit @brief command for a brief
+# description.)
+# The default value is: NO.
+
+JAVADOC_AUTOBRIEF      = NO
+
+# If the QT_AUTOBRIEF tag is set to YES then doxygen will interpret the first
+# line (until the first dot) of a Qt-style comment as the brief description. If
+# set to NO, the Qt-style will behave just like regular Qt-style comments (thus
+# requiring an explicit \brief command for a brief description.)
+# The default value is: NO.
+
+QT_AUTOBRIEF           = NO
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make doxygen treat a
+# multi-line C++ special comment block (i.e. a block of //! or /// comments) as
+# a brief description. This used to be the default behavior. The new default is
+# to treat a multi-line C++ comment block as a detailed description. Set this
+# tag to YES if you prefer the old behavior instead.
+#
+# Note that setting this tag to YES also means that rational rose comments are
+# not recognized any more.
+# The default value is: NO.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the
+# documentation from any documented member that it re-implements.
+# The default value is: YES.
+
+INHERIT_DOCS           = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES then doxygen will produce a new
+# page for each member. If set to NO, the documentation of a member will be part
+# of the file/class/namespace that contains it.
+# The default value is: NO.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. Doxygen
+# uses this value to replace tabs by spaces in code fragments.
+# Minimum value: 1, maximum value: 16, default value: 4.
+
+TAB_SIZE               = 4
+
+# This tag can be used to specify a number of aliases that act as commands in
+# the documentation. An alias has the form:
+# name=value
+# For example adding
+# "sideeffect=@par Side Effects:\n"
+# will allow you to put the command \sideeffect (or @sideeffect) in the
+# documentation, which will result in a user-defined paragraph with heading
+# "Side Effects:". You can put \n's in the value part of an alias to insert
+# newlines.
+
+ALIASES                = "rst=\verbatim embed:rst:leading-asterisk"
+ALIASES                += "endrst=\endverbatim"
+
+# This tag can be used to specify a number of word-keyword mappings (TCL only).
+# A mapping has the form "name=value". For example adding "class=itcl::class"
+# will allow you to use the command class in the itcl::class meaning.
+
+TCL_SUBST              =
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources
+# only. Doxygen will then generate output that is more tailored for C. For
+# instance, some of the names that are used will be different. The list of all
+# members will be omitted, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_FOR_C  = NO
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java or
+# Python sources only. Doxygen will then generate output that is more tailored
+# for that language. For instance, namespaces will be presented as packages,
+# qualified scopes will look different, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
+# sources. Doxygen will then generate output that is tailored for Fortran.
+# The default value is: NO.
+
+OPTIMIZE_FOR_FORTRAN   = NO
+
+# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
+# sources. Doxygen will then generate output that is tailored for VHDL.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_VHDL   = NO
+
+# Doxygen selects the parser to use depending on the extension of the files it
+# parses. With this tag you can assign which parser to use for a given
+# extension. Doxygen has a built-in mapping, but you can override or extend it
+# using this tag. The format is ext=language, where ext is a file extension, and
+# language is one of the parsers supported by doxygen: IDL, Java, Javascript,
+# C#, C, C++, D, PHP, Objective-C, Python, Fortran (fixed format Fortran:
+# FortranFixed, free formatted Fortran: FortranFree, unknown formatted Fortran:
+# Fortran. In the later case the parser tries to guess whether the code is fixed
+# or free formatted code, this is the default for Fortran type files), VHDL. For
+# instance to make doxygen treat .inc files as Fortran files (default is PHP),
+# and .f files as C (default is Fortran), use: inc=Fortran f=C.
+#
+# Note: For files without extension you can use no_extension as a placeholder.
+#
+# Note that for custom extensions you also need to set FILE_PATTERNS otherwise
+# the files are not read by doxygen.
+
+EXTENSION_MAPPING      =
+
+# If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments
+# according to the Markdown format, which allows for more readable
+# documentation. See http://daringfireball.net/projects/markdown/ for details.
+# The output of markdown processing is further processed by doxygen, so you can
+# mix doxygen, HTML, and XML commands with Markdown formatting. Disable only in
+# case of backward compatibilities issues.
+# The default value is: YES.
+
+MARKDOWN_SUPPORT       = YES
+
+# When the TOC_INCLUDE_HEADINGS tag is set to a non-zero value, all headings up
+# to that level are automatically included in the table of contents, even if
+# they do not have an id attribute.
+# Note: This feature currently applies only to Markdown headings.
+# Minimum value: 0, maximum value: 99, default value: 0.
+# This tag requires that the tag MARKDOWN_SUPPORT is set to YES.
+
+TOC_INCLUDE_HEADINGS   = 0
+
+# When enabled doxygen tries to link words that correspond to documented
+# classes, or namespaces to their corresponding documentation. Such a link can
+# be prevented in individual cases by putting a % sign in front of the word or
+# globally by setting AUTOLINK_SUPPORT to NO.
+# The default value is: YES.
+
+AUTOLINK_SUPPORT       = YES
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
+# to include (a tag file for) the STL sources as input, then you should set this
+# tag to YES in order to let doxygen match functions declarations and
+# definitions whose arguments contain STL classes (e.g. func(std::string);
+# versus func(std::string) {}). This also make the inheritance and collaboration
+# diagrams that involve STL classes more complete and accurate.
+# The default value is: NO.
+
+BUILTIN_STL_SUPPORT    = NO
+
+# If you use Microsoft's C++/CLI language, you should set this option to YES to
+# enable parsing support.
+# The default value is: NO.
+
+CPP_CLI_SUPPORT        = NO
+
+# Set the SIP_SUPPORT tag to YES if your project consists of sip (see:
+# https://www.riverbankcomputing.com/software/sip/intro) sources only. Doxygen
+# will parse them like normal C++ but will assume all classes use public instead
+# of private inheritance when no explicit protection keyword is present.
+# The default value is: NO.
+
+SIP_SUPPORT            = NO
+
+# For Microsoft's IDL there are propget and propput attributes to indicate
+# getter and setter methods for a property. Setting this option to YES will make
+# doxygen to replace the get and set methods by a property in the documentation.
+# This will only work if the methods are indeed getting or setting a simple
+# type. If this is not the case, or you want to show the methods anyway, you
+# should set this option to NO.
+# The default value is: YES.
+
+IDL_PROPERTY_SUPPORT   = YES
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
+# tag is set to YES then doxygen will reuse the documentation of the first
+# member in the group (if any) for the other members of the group. By default
+# all members of a group must be documented explicitly.
+# The default value is: NO.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# If one adds a struct or class to a group and this option is enabled, then also
+# any nested class or struct is added to the same group. By default this option
+# is disabled and one has to add nested compounds explicitly via \ingroup.
+# The default value is: NO.
+
+GROUP_NESTED_COMPOUNDS = NO
+
+# Set the SUBGROUPING tag to YES to allow class member groups of the same type
+# (for instance a group of public functions) to be put as a subgroup of that
+# type (e.g. under the Public Functions section). Set it to NO to prevent
+# subgrouping. Alternatively, this can be done per class using the
+# \nosubgrouping command.
+# The default value is: YES.
+
+SUBGROUPING            = YES
+
+# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and unions
+# are shown inside the group in which they are included (e.g. using \ingroup)
+# instead of on a separate page (for HTML and Man pages) or section (for LaTeX
+# and RTF).
+#
+# Note that this feature does not work in combination with
+# SEPARATE_MEMBER_PAGES.
+# The default value is: NO.
+
+INLINE_GROUPED_CLASSES = NO
+
+# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and unions
+# with only public data fields or simple typedef fields will be shown inline in
+# the documentation of the scope in which they are defined (i.e. file,
+# namespace, or group documentation), provided this scope is documented. If set
+# to NO, structs, classes, and unions are shown on a separate page (for HTML and
+# Man pages) or section (for LaTeX and RTF).
+# The default value is: NO.
+
+INLINE_SIMPLE_STRUCTS  = NO
+
+# When TYPEDEF_HIDES_STRUCT tag is enabled, a typedef of a struct, union, or
+# enum is documented as struct, union, or enum with the name of the typedef. So
+# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
+# with name TypeT. When disabled the typedef will appear as a member of a file,
+# namespace, or class. And the struct will be named TypeS. This can typically be
+# useful for C code in case the coding convention dictates that all compound
+# types are typedef'ed and only the typedef is referenced, never the tag name.
+# The default value is: NO.
+
+TYPEDEF_HIDES_STRUCT   = NO
+
+# The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This
+# cache is used to resolve symbols given their name and scope. Since this can be
+# an expensive process and often the same symbol appears multiple times in the
+# code, doxygen keeps a cache of pre-resolved symbols. If the cache is too small
+# doxygen will become slower. If the cache is too large, memory is wasted. The
+# cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range
+# is 0..9, the default is 0, corresponding to a cache size of 2^16=65536
+# symbols. At the end of a run doxygen will report the cache usage and suggest
+# the optimal cache size from a speed point of view.
+# Minimum value: 0, maximum value: 9, default value: 0.
+
+LOOKUP_CACHE_SIZE      = 0
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES, doxygen will assume all entities in
+# documentation are documented, even if no documentation was available. Private
+# class members and static file members will be hidden unless the
+# EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES.
+# Note: This will also disable the warnings about undocumented members that are
+# normally produced when WARNINGS is set to YES.
+# The default value is: NO.
+
+EXTRACT_ALL            = YES
+
+# If the EXTRACT_PRIVATE tag is set to YES, all private members of a class will
+# be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PRIVATE        = YES
+
+# If the EXTRACT_PACKAGE tag is set to YES, all members with package or internal
+# scope will be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PACKAGE        = YES
+
+# If the EXTRACT_STATIC tag is set to YES, all static members of a file will be
+# included in the documentation.
+# The default value is: NO.
+
+EXTRACT_STATIC         = YES
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES, classes (and structs) defined
+# locally in source files will be included in the documentation. If set to NO,
+# only classes defined in header files are included. Does not have any effect
+# for Java sources.
+# The default value is: YES.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. If set to YES, local methods,
+# which are defined in the implementation section but not in the interface are
+# included in the documentation. If set to NO, only methods in the interface are
+# included.
+# The default value is: NO.
+
+EXTRACT_LOCAL_METHODS  = NO
+
+# If this flag is set to YES, the members of anonymous namespaces will be
+# extracted and appear in the documentation as a namespace called
+# 'anonymous_namespace{file}', where file will be replaced with the base name of
+# the file that contains the anonymous namespace. By default anonymous namespace
+# are hidden.
+# The default value is: NO.
+
+EXTRACT_ANON_NSPACES   = NO
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, doxygen will hide all
+# undocumented members inside documented classes or files. If set to NO these
+# members will be included in the various overviews, but no documentation
+# section is generated. This option has no effect if EXTRACT_ALL is enabled.
+# The default value is: NO.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, doxygen will hide all
+# undocumented classes that are normally visible in the class hierarchy. If set
+# to NO, these classes will be included in the various overviews. This option
+# has no effect if EXTRACT_ALL is enabled.
+# The default value is: NO.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, doxygen will hide all friend
+# (class|struct|union) declarations. If set to NO, these declarations will be
+# included in the documentation.
+# The default value is: NO.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, doxygen will hide any
+# documentation blocks found inside the body of a function. If set to NO, these
+# blocks will be appended to the function's detailed documentation block.
+# The default value is: NO.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation that is typed after a
+# \internal command is included. If the tag is set to NO then the documentation
+# will be excluded. Set it to YES to include the internal documentation.
+# The default value is: NO.
+
+INTERNAL_DOCS          = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then doxygen will only generate file
+# names in lower-case letters. If set to YES, upper-case letters are also
+# allowed. This is useful if you have classes or files whose names only differ
+# in case and if your file system supports case sensitive file names. Windows
+# and Mac users are advised to set this option to NO.
+# The default value is: system dependent.
+
+CASE_SENSE_NAMES       = YES
+
+# If the HIDE_SCOPE_NAMES tag is set to NO then doxygen will show members with
+# their full class and namespace scopes in the documentation. If set to YES, the
+# scope will be hidden.
+# The default value is: NO.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the HIDE_COMPOUND_REFERENCE tag is set to NO (default) then doxygen will
+# append additional text to a page's title, such as Class Reference. If set to
+# YES the compound reference will be hidden.
+# The default value is: NO.
+
+HIDE_COMPOUND_REFERENCE= NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES then doxygen will put a list of
+# the files that are included by a file in the documentation of that file.
+# The default value is: YES.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the SHOW_GROUPED_MEMB_INC tag is set to YES then Doxygen will add for each
+# grouped member an include statement to the documentation, telling the reader
+# which file to include in order to use the member.
+# The default value is: NO.
+
+SHOW_GROUPED_MEMB_INC  = NO
+
+# If the FORCE_LOCAL_INCLUDES tag is set to YES then doxygen will list include
+# files with double quotes in the documentation rather than with sharp brackets.
+# The default value is: NO.
+
+FORCE_LOCAL_INCLUDES   = NO
+
+# If the INLINE_INFO tag is set to YES then a tag [inline] is inserted in the
+# documentation for inline members.
+# The default value is: YES.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES then doxygen will sort the
+# (detailed) documentation of file and class members alphabetically by member
+# name. If set to NO, the members will appear in declaration order.
+# The default value is: YES.
+
+SORT_MEMBER_DOCS       = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the brief
+# descriptions of file, namespace and class members alphabetically by member
+# name. If set to NO, the members will appear in declaration order. Note that
+# this will also influence the order of the classes in the class list.
+# The default value is: NO.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen will sort the
+# (brief and detailed) documentation of class members so that constructors and
+# destructors are listed first. If set to NO the constructors will appear in the
+# respective orders defined by SORT_BRIEF_DOCS and SORT_MEMBER_DOCS.
+# Note: If SORT_BRIEF_DOCS is set to NO this option is ignored for sorting brief
+# member documentation.
+# Note: If SORT_MEMBER_DOCS is set to NO this option is ignored for sorting
+# detailed member documentation.
+# The default value is: NO.
+
+SORT_MEMBERS_CTORS_1ST = NO
+
+# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the hierarchy
+# of group names into alphabetical order. If set to NO the group names will
+# appear in their defined order.
+# The default value is: NO.
+
+SORT_GROUP_NAMES       = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be sorted by
+# fully-qualified names, including namespaces. If set to NO, the class list will
+# be sorted only by class name, not including the namespace part.
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
+# Note: This option applies only to the class list, not to the alphabetical
+# list.
+# The default value is: NO.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to do proper
+# type resolution of all parameters of a function it will reject a match between
+# the prototype and the implementation of a member function even if there is
+# only one candidate or it is obvious which candidate to choose by doing a
+# simple string match. By disabling STRICT_PROTO_MATCHING doxygen will still
+# accept a match between prototype and implementation in such cases.
+# The default value is: NO.
+
+STRICT_PROTO_MATCHING  = NO
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or disable (NO) the todo
+# list. This list is created by putting \todo commands in the documentation.
+# The default value is: YES.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or disable (NO) the test
+# list. This list is created by putting \test commands in the documentation.
+# The default value is: YES.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or disable (NO) the bug
+# list. This list is created by putting \bug commands in the documentation.
+# The default value is: YES.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or disable (NO)
+# the deprecated list. This list is created by putting \deprecated commands in
+# the documentation.
+# The default value is: YES.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional documentation
+# sections, marked by \if <section_label> ... \endif and \cond <section_label>
+# ... \endcond blocks.
+
+ENABLED_SECTIONS       =
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines that the
+# initial value of a variable or macro / define can have for it to appear in the
+# documentation. If the initializer consists of more lines than specified here
+# it will be hidden. Use a value of 0 to hide initializers completely. The
+# appearance of the value of individual variables and macros / defines can be
+# controlled using \showinitializer or \hideinitializer command in the
+# documentation regardless of this setting.
+# Minimum value: 0, maximum value: 10000, default value: 30.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated at
+# the bottom of the documentation of classes and structs. If set to YES, the
+# list will mention the files that were used to generate the documentation.
+# The default value is: YES.
+
+SHOW_USED_FILES        = YES
+
+# Set the SHOW_FILES tag to NO to disable the generation of the Files page. This
+# will remove the Files entry from the Quick Index and from the Folder Tree View
+# (if specified).
+# The default value is: YES.
+
+SHOW_FILES             = YES
+
+# Set the SHOW_NAMESPACES tag to NO to disable the generation of the Namespaces
+# page. This will remove the Namespaces entry from the Quick Index and from the
+# Folder Tree View (if specified).
+# The default value is: YES.
+
+SHOW_NAMESPACES        = YES
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that
+# doxygen should invoke to get the current version for each file (typically from
+# the version control system). Doxygen will invoke the program by executing (via
+# popen()) the command command input-file, where command is the value of the
+# FILE_VERSION_FILTER tag, and input-file is the name of an input file provided
+# by doxygen. Whatever the program writes to standard output is used as the file
+# version. For an example see the documentation.
+
+FILE_VERSION_FILTER    =
+
+# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
+# by doxygen. The layout file controls the global structure of the generated
+# output files in an output format independent way. To create the layout file
+# that represents doxygen's defaults, run doxygen with the -l option. You can
+# optionally specify a file name after the option, if omitted DoxygenLayout.xml
+# will be used as the name of the layout file.
+#
+# Note that if you run doxygen from a directory containing a file called
+# DoxygenLayout.xml, doxygen will parse it automatically even if the LAYOUT_FILE
+# tag is left empty.
+
+LAYOUT_FILE            = DoxygenLayout.xml
+
+# The CITE_BIB_FILES tag can be used to specify one or more bib files containing
+# the reference definitions. This must be a list of .bib files. The .bib
+# extension is automatically appended if omitted. This requires the bibtex tool
+# to be installed. See also https://en.wikipedia.org/wiki/BibTeX for more info.
+# For LaTeX the style of the bibliography can be controlled using
+# LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the
+# search path. See also \cite for info how to create references.
+
+CITE_BIB_FILES         =
+
+#---------------------------------------------------------------------------
+# Configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated to
+# standard output by doxygen. If QUIET is set to YES this implies that the
+# messages are off.
+# The default value is: NO.
+
+QUIET                  = NO
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are
+# generated to standard error (stderr) by doxygen. If WARNINGS is set to YES
+# this implies that the warnings are on.
+#
+# Tip: Turn warnings on while writing the documentation.
+# The default value is: YES.
+
+WARNINGS               = YES
+
+# If the WARN_IF_UNDOCUMENTED tag is set to YES then doxygen will generate
+# warnings for undocumented members. If EXTRACT_ALL is set to YES then this flag
+# will automatically be disabled.
+# The default value is: YES.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If the WARN_IF_DOC_ERROR tag is set to YES, doxygen will generate warnings for
+# potential errors in the documentation, such as not documenting some parameters
+# in a documented function, or documenting parameters that don't exist or using
+# markup commands wrongly.
+# The default value is: YES.
+
+WARN_IF_DOC_ERROR      = YES
+
+# This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that
+# are documented, but have no documentation for their parameters or return
+# value. If set to NO, doxygen will only warn about wrong or incomplete
+# parameter documentation, but not about the absence of documentation.
+# The default value is: NO.
+
+WARN_NO_PARAMDOC       = NO
+
+# If the WARN_AS_ERROR tag is set to YES then doxygen will immediately stop when
+# a warning is encountered.
+# The default value is: NO.
+
+WARN_AS_ERROR          = NO
+
+# The WARN_FORMAT tag determines the format of the warning messages that doxygen
+# can produce. The string should contain the $file, $line, and $text tags, which
+# will be replaced by the file and line number from which the warning originated
+# and the warning text. Optionally the format may contain $version, which will
+# be replaced by the version of the file (if it could be obtained via
+# FILE_VERSION_FILTER)
+# The default value is: $file:$line: $text.
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning and error
+# messages should be written. If left blank the output is written to standard
+# error (stderr).
+
+WARN_LOGFILE           =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag is used to specify the files and/or directories that contain
+# documented source files. You may enter file names like myfile.cpp or
+# directories like /usr/src/myproject. Separate the files or directories with
+# spaces. See also FILE_PATTERNS and EXTENSION_MAPPING
+# Note: If this tag is empty the current directory is searched.
+
+INPUT                  = @CMAKE_CURRENT_SOURCE_DIR@/ \
+                         @PROJECT_SOURCE_DIR@/shared/include/ \
+                         @PROJECT_SOURCE_DIR@/shared/src/ \
+                         @PROJECT_SOURCE_DIR@/ServiceProcessorBL1/include/ \
+                         @PROJECT_SOURCE_DIR@/ServiceProcessorBL1/src/ \
+                         @PROJECT_SOURCE_DIR@/ServiceProcessorBL2/include/ \
+                         @PROJECT_SOURCE_DIR@/ServiceProcessorBL2/ \
+                         @PROJECT_BINARY_DIR@/ServiceProcessorBL2/ \
+                         @PROJECT_SOURCE_DIR@/include \
+
+# This tag can be used to specify the character encoding of the source files
+# that doxygen parses. Internally doxygen uses the UTF-8 encoding. Doxygen uses
+# libiconv (or the iconv built into libc) for the transcoding. See the libiconv
+# documentation (see: https://www.gnu.org/software/libiconv/) for the list of
+# possible encodings.
+# The default value is: UTF-8.
+
+INPUT_ENCODING         = UTF-8
+
+# If the value of the INPUT tag contains directories, you can use the
+# FILE_PATTERNS tag to specify one or more wildcard patterns (like *.cpp and
+# *.h) to filter out the source-files in the directories.
+#
+# Note that for custom extensions or not directly supported extensions you also
+# need to set EXTENSION_MAPPING for the extension otherwise the files are not
+# read by doxygen.
+#
+# If left blank the following patterns are tested:*.c, *.cc, *.cxx, *.cpp,
+# *.c++, *.java, *.ii, *.ixx, *.ipp, *.i++, *.inl, *.idl, *.ddl, *.odl, *.h,
+# *.hh, *.hxx, *.hpp, *.h++, *.cs, *.d, *.php, *.php4, *.php5, *.phtml, *.inc,
+# *.m, *.markdown, *.md, *.mm, *.dox, *.py, *.pyw, *.f90, *.f95, *.f03, *.f08,
+# *.f, *.for, *.tcl, *.vhd, *.vhdl, *.ucf and *.qsf.
+
+FILE_PATTERNS          = *.c \
+                         *.cc \
+                         *.cxx \
+                         *.cpp \
+                         *.c++ \
+                         *.java \
+                         *.ii \
+                         *.ixx \
+                         *.ipp \
+                         *.i++ \
+                         *.inl \
+                         *.idl \
+                         *.ddl \
+                         *.odl \
+                         *.h \
+                         *.hh \
+                         *.hxx \
+                         *.hpp \
+                         *.h++ \
+                         *.cs \
+                         *.d \
+                         *.php \
+                         *.php4 \
+                         *.php5 \
+                         *.phtml \
+                         *.inc \
+                         *.m \
+                         *.markdown \
+                         *.md \
+                         *.mm \
+                         *.dox \
+                         *.py \
+                         *.pyw \
+                         *.f90 \
+                         *.f95 \
+                         *.f03 \
+                         *.f08 \
+                         *.f \
+                         *.for \
+                         *.tcl \
+                         *.vhd \
+                         *.vhdl \
+                         *.ucf \
+                         *.qsf
+
+# The RECURSIVE tag can be used to specify whether or not subdirectories should
+# be searched for input files as well.
+# The default value is: NO.
+
+RECURSIVE              = YES
+
+# The EXCLUDE tag can be used to specify files and/or directories that should be
+# excluded from the INPUT source files. This way you can easily exclude a
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+#
+# Note that relative paths are relative to the directory from which doxygen is
+# run.
+
+EXCLUDE                =
+
+# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
+# directories that are symbolic links (a Unix file system feature) are excluded
+# from the input.
+# The default value is: NO.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
+# certain files from those directories.
+#
+# Note that the wildcards are matched against the file with absolute path, so to
+# exclude all test directories for example use the pattern */test/*
+
+EXCLUDE_PATTERNS       = */elfio/*
+
+# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
+# (namespaces, classes, functions, etc.) that should be excluded from the
+# output. The symbol name can be a fully qualified name, a word, or if the
+# wildcard * is used, a substring. Examples: ANamespace, AClass,
+# AClass::ANamespace, ANamespace::*Test
+#
+# Note that the wildcards are matched against the file with absolute path, so to
+# exclude all test directories use the pattern */test/*
+
+EXCLUDE_SYMBOLS        =
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or directories
+# that contain example code fragments that are included (see the \include
+# command).
+
+EXAMPLE_PATH           =
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp and
+# *.h) to filter out the source-files in the directories. If left blank all
+# files are included.
+
+EXAMPLE_PATTERNS       = *
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
+# searched for input files to be used with the \include or \dontinclude commands
+# irrespective of the value of the RECURSIVE tag.
+# The default value is: NO.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or directories
+# that contain images that are to be included in the documentation (see the
+# \image command).
+
+IMAGE_PATH             = @CMAKE_CURRENT_SOURCE_DIR@
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should
+# invoke to filter for each input file. Doxygen will invoke the filter program
+# by executing (via popen()) the command:
+#
+# <filter> <input-file>
+#
+# where <filter> is the value of the INPUT_FILTER tag, and <input-file> is the
+# name of an input file. Doxygen will then use the output that the filter
+# program writes to standard output. If FILTER_PATTERNS is specified, this tag
+# will be ignored.
+#
+# Note that the filter must not add or remove lines; it is applied before the
+# code is scanned, but not when the output code is generated. If lines are added
+# or removed, the anchors will not be placed correctly.
+#
+# Note that for custom extensions or not directly supported extensions you also
+# need to set EXTENSION_MAPPING for the extension otherwise the files are not
+# properly processed by doxygen.
+
+INPUT_FILTER           =
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
+# basis. Doxygen will compare the file name with each pattern and apply the
+# filter if there is a match. The filters are a list of the form: pattern=filter
+# (like *.cpp=my_cpp_filter). See INPUT_FILTER for further information on how
+# filters are used. If the FILTER_PATTERNS tag is empty or if none of the
+# patterns match the file name, INPUT_FILTER is applied.
+#
+# Note that for custom extensions or not directly supported extensions you also
+# need to set EXTENSION_MAPPING for the extension otherwise the files are not
+# properly processed by doxygen.
+
+FILTER_PATTERNS        =
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
+# INPUT_FILTER) will also be used to filter the input files that are used for
+# producing the source files to browse (i.e. when SOURCE_BROWSER is set to YES).
+# The default value is: NO.
+
+FILTER_SOURCE_FILES    = NO
+
+# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
+# pattern. A pattern will override the setting for FILTER_PATTERN (if any) and
+# it is also possible to disable source filtering for a specific pattern using
+# *.ext= (so without naming a filter).
+# This tag requires that the tag FILTER_SOURCE_FILES is set to YES.
+
+FILTER_SOURCE_PATTERNS =
+
+# If the USE_MDFILE_AS_MAINPAGE tag refers to the name of a markdown file that
+# is part of the input, its contents will be placed on the main page
+# (index.html). This can be useful if you have a project on for instance GitHub
+# and want to reuse the introduction page also for the doxygen output.
+
+USE_MDFILE_AS_MAINPAGE = @CMAKE_CURRENT_SOURCE_DIR@/../README.md
+
+#---------------------------------------------------------------------------
+# Configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will be
+# generated. Documented entities will be cross-referenced with these sources.
+#
+# Note: To get rid of all source code in the generated output, make sure that
+# also VERBATIM_HEADERS is set to NO.
+# The default value is: NO.
+
+SOURCE_BROWSER         = YES
+
+# Setting the INLINE_SOURCES tag to YES will include the body of functions,
+# classes and enums directly into the documentation.
+# The default value is: NO.
+
+INLINE_SOURCES         = YES
+
+# Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any
+# special comment blocks from generated source code fragments. Normal C, C++ and
+# Fortran comments will always remain visible.
+# The default value is: YES.
+
+STRIP_CODE_COMMENTS    = YES
+
+# If the REFERENCED_BY_RELATION tag is set to YES then for each documented
+# function all documented functions referencing it will be listed.
+# The default value is: NO.
+
+REFERENCED_BY_RELATION = NO
+
+# If the REFERENCES_RELATION tag is set to YES then for each documented function
+# all documented entities called/used by that function will be listed.
+# The default value is: NO.
+
+REFERENCES_RELATION    = NO
+
+# If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set
+# to YES then the hyperlinks from functions in REFERENCES_RELATION and
+# REFERENCED_BY_RELATION lists will link to the source code. Otherwise they will
+# link to the documentation.
+# The default value is: YES.
+
+REFERENCES_LINK_SOURCE = YES
+
+# If SOURCE_TOOLTIPS is enabled (the default) then hovering a hyperlink in the
+# source code will show a tooltip with additional information such as prototype,
+# brief description and links to the definition and documentation. Since this
+# will make the HTML file larger and loading of large files a bit slower, you
+# can opt to disable this feature.
+# The default value is: YES.
+# This tag requires that the tag SOURCE_BROWSER is set to YES.
+
+SOURCE_TOOLTIPS        = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code will
+# point to the HTML generated by the htags(1) tool instead of doxygen built-in
+# source browser. The htags tool is part of GNU's global source tagging system
+# (see https://www.gnu.org/software/global/global.html). You will need version
+# 4.8.6 or higher.
+#
+# To use it do the following:
+# - Install the latest version of global
+# - Enable SOURCE_BROWSER and USE_HTAGS in the config file
+# - Make sure the INPUT points to the root of the source tree
+# - Run doxygen as normal
+#
+# Doxygen will invoke htags (and that will in turn invoke gtags), so these
+# tools must be available from the command line (i.e. in the search path).
+#
+# The result: instead of the source browser generated by doxygen, the links to
+# source code will now point to the output of htags.
+# The default value is: NO.
+# This tag requires that the tag SOURCE_BROWSER is set to YES.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set the YES then doxygen will generate a
+# verbatim copy of the header file for each class for which an include is
+# specified. Set to NO to disable this.
+# See also: Section \class.
+# The default value is: YES.
+
+VERBATIM_HEADERS       = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index of all
+# compounds will be generated. Enable this if the project contains a lot of
+# classes, structs, unions or interfaces.
+# The default value is: YES.
+
+ALPHABETICAL_INDEX     = YES
+
+# The COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns in
+# which the alphabetical index list will be split.
+# Minimum value: 1, maximum value: 20, default value: 5.
+# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all classes will
+# be put under the same header in the alphabetical index. The IGNORE_PREFIX tag
+# can be used to specify a prefix (or a list of prefixes) that should be ignored
+# while generating the index headers.
+# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
+
+IGNORE_PREFIX          =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES, doxygen will generate HTML output
+# The default value is: YES.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: html.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_OUTPUT            = html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for each
+# generated HTML page (for example: .htm, .php, .asp).
+# The default value is: .html.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a user-defined HTML header file for
+# each generated HTML page. If the tag is left blank doxygen will generate a
+# standard header.
+#
+# To get valid HTML the header file that includes any scripts and style sheets
+# that doxygen needs, which is dependent on the configuration options used (e.g.
+# the setting GENERATE_TREEVIEW). It is highly recommended to start with a
+# default header using
+# doxygen -w html new_header.html new_footer.html new_stylesheet.css
+# YourConfigFile
+# and then modify the file new_header.html. See also section "Doxygen usage"
+# for information on how to generate the default header that doxygen normally
+# uses.
+# Note: The header is subject to change so you typically have to regenerate the
+# default header when upgrading to a newer version of doxygen. For a description
+# of the possible markers and block names see the documentation.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_HEADER            =
+
+# The HTML_FOOTER tag can be used to specify a user-defined HTML footer for each
+# generated HTML page. If the tag is left blank doxygen will generate a standard
+# footer. See HTML_HEADER for more information on how to generate a default
+# footer and what special commands can be used inside the footer. See also
+# section "Doxygen usage" for information on how to generate the default footer
+# that doxygen normally uses.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_FOOTER            =
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading style
+# sheet that is used by each HTML page. It can be used to fine-tune the look of
+# the HTML output. If left blank doxygen will generate a default style sheet.
+# See also section "Doxygen usage" for information on how to generate the style
+# sheet that doxygen normally uses.
+# Note: It is recommended to use HTML_EXTRA_STYLESHEET instead of this tag, as
+# it is more robust and this tag (HTML_STYLESHEET) will in the future become
+# obsolete.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_STYLESHEET        =
+
+# The HTML_EXTRA_STYLESHEET tag can be used to specify additional user-defined
+# cascading style sheets that are included after the standard style sheets
+# created by doxygen. Using this option one can overrule certain style aspects.
+# This is preferred over using HTML_STYLESHEET since it does not replace the
+# standard style sheet and is therefore more robust against future updates.
+# Doxygen will copy the style sheet files to the output directory.
+# Note: The order of the extra style sheet files is of importance (e.g. the last
+# style sheet in the list overrules the setting of the previous ones in the
+# list). For an example see the documentation.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_EXTRA_STYLESHEET  =
+
+# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
+# other source files which should be copied to the HTML output directory. Note
+# that these files will be copied to the base HTML output directory. Use the
+# $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
+# files. In the HTML_STYLESHEET file, use the file name only. Also note that the
+# files will be copied as-is; there are no commands or markers available.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_EXTRA_FILES       =
+
+# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen
+# will adjust the colors in the style sheet and background images according to
+# this color. Hue is specified as an angle on a colorwheel, see
+# https://en.wikipedia.org/wiki/Hue for more information. For instance the value
+# 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300
+# purple, and 360 is red again.
+# Minimum value: 0, maximum value: 359, default value: 220.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_HUE    = 220
+
+# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of the colors
+# in the HTML output. For a value of 0 the output will use grayscales only. A
+# value of 255 will produce the most vivid colors.
+# Minimum value: 0, maximum value: 255, default value: 100.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_SAT    = 100
+
+# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to the
+# luminance component of the colors in the HTML output. Values below 100
+# gradually make the output lighter, whereas values above 100 make the output
+# darker. The value divided by 100 is the actual gamma applied, so 80 represents
+# a gamma of 0.8, The value 220 represents a gamma of 2.2, and 100 does not
+# change the gamma.
+# Minimum value: 40, maximum value: 240, default value: 80.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_GAMMA  = 80
+
+# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
+# page will contain the date and time when the page was generated. Setting this
+# to YES can help to show when doxygen was last run and thus if the
+# documentation is up to date.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_TIMESTAMP         = NO
+
+# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
+# documentation will contain sections that can be hidden and shown after the
+# page has loaded.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_DYNAMIC_SECTIONS  = NO
+
+# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of entries
+# shown in the various tree structured indices initially; the user can expand
+# and collapse entries dynamically later on. Doxygen will expand the tree to
+# such a level that at most the specified number of entries are visible (unless
+# a fully collapsed tree already exceeds this amount). So setting the number of
+# entries 1 will produce a full collapsed tree by default. 0 is a special value
+# representing an infinite number of entries and will result in a full expanded
+# tree by default.
+# Minimum value: 0, maximum value: 9999, default value: 100.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_INDEX_NUM_ENTRIES = 100
+
+# If the GENERATE_DOCSET tag is set to YES, additional index files will be
+# generated that can be used as input for Apple's Xcode 3 integrated development
+# environment (see: https://developer.apple.com/tools/xcode/), introduced with
+# OSX 10.5 (Leopard). To create a documentation set, doxygen will generate a
+# Makefile in the HTML output directory. Running make will produce the docset in
+# that directory and running make install will install the docset in
+# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at
+# startup. See https://developer.apple.com/tools/creatingdocsetswithdoxygen.html
+# for more information.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_DOCSET        = NO
+
+# This tag determines the name of the docset feed. A documentation feed provides
+# an umbrella under which multiple documentation sets from a single provider
+# (such as a company or product suite) can be grouped.
+# The default value is: Doxygen generated docs.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_FEEDNAME        = "Doxygen generated docs"
+
+# This tag specifies a string that should uniquely identify the documentation
+# set bundle. This should be a reverse domain-name style string, e.g.
+# com.mycompany.MyDocSet. Doxygen will append .docset to the name.
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_BUNDLE_ID       = org.doxygen.Project
+
+# The DOCSET_PUBLISHER_ID tag specifies a string that should uniquely identify
+# the documentation publisher. This should be a reverse domain-name style
+# string, e.g. com.mycompany.MyDocSet.documentation.
+# The default value is: org.doxygen.Publisher.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_PUBLISHER_ID    = org.doxygen.Publisher
+
+# The DOCSET_PUBLISHER_NAME tag identifies the documentation publisher.
+# The default value is: Publisher.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_PUBLISHER_NAME  = Publisher
+
+# If the GENERATE_HTMLHELP tag is set to YES then doxygen generates three
+# additional HTML index files: index.hhp, index.hhc, and index.hhk. The
+# index.hhp is a project file that can be read by Microsoft's HTML Help Workshop
+# (see: http://www.microsoft.com/en-us/download/details.aspx?id=21138) on
+# Windows.
+#
+# The HTML Help Workshop contains a compiler that can convert all HTML output
+# generated by doxygen into a single compiled HTML file (.chm). Compiled HTML
+# files are now used as the Windows 98 help format, and will replace the old
+# Windows help format (.hlp) on all Windows platforms in the future. Compressed
+# HTML files also contain an index, a table of contents, and you can search for
+# words in the documentation. The HTML workshop also contains a viewer for
+# compressed HTML files.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_HTMLHELP      = NO
+
+# The CHM_FILE tag can be used to specify the file name of the resulting .chm
+# file. You can add a path in front of the file if the result should not be
+# written to the html output directory.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+CHM_FILE               =
+
+# The HHC_LOCATION tag can be used to specify the location (absolute path
+# including file name) of the HTML help compiler (hhc.exe). If non-empty,
+# doxygen will try to run the HTML help compiler on the generated index.hhp.
+# The file has to be specified with full path.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+HHC_LOCATION           =
+
+# The GENERATE_CHI flag controls if a separate .chi index file is generated
+# (YES) or that it should be included in the master .chm file (NO).
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+GENERATE_CHI           = NO
+
+# The CHM_INDEX_ENCODING is used to encode HtmlHelp index (hhk), content (hhc)
+# and project file content.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+CHM_INDEX_ENCODING     =
+
+# The BINARY_TOC flag controls whether a binary table of contents is generated
+# (YES) or a normal table of contents (NO) in the .chm file. Furthermore it
+# enables the Previous and Next buttons.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members to
+# the table of contents of the HTML help documentation and to the tree view.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+TOC_EXPAND             = NO
+
+# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
+# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated that
+# can be used as input for Qt's qhelpgenerator to generate a Qt Compressed Help
+# (.qch) of the generated HTML documentation.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_QHP           = NO
+
+# If the QHG_LOCATION tag is specified, the QCH_FILE tag can be used to specify
+# the file name of the resulting .qch file. The path specified is relative to
+# the HTML output folder.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QCH_FILE               =
+
+# The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help
+# Project output. For more information please see Qt Help Project / Namespace
+# (see: http://doc.qt.io/qt-4.8/qthelpproject.html#namespace).
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_NAMESPACE          = org.doxygen.Project
+
+# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt
+# Help Project output. For more information please see Qt Help Project / Virtual
+# Folders (see: http://doc.qt.io/qt-4.8/qthelpproject.html#virtual-folders).
+# The default value is: doc.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_VIRTUAL_FOLDER     = doc
+
+# If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom
+# filter to add. For more information please see Qt Help Project / Custom
+# Filters (see: http://doc.qt.io/qt-4.8/qthelpproject.html#custom-filters).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_CUST_FILTER_NAME   =
+
+# The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the
+# custom filter to add. For more information please see Qt Help Project / Custom
+# Filters (see: http://doc.qt.io/qt-4.8/qthelpproject.html#custom-filters).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_CUST_FILTER_ATTRS  =
+
+# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
+# project's filter section matches. Qt Help Project / Filter Attributes (see:
+# http://doc.qt.io/qt-4.8/qthelpproject.html#filter-attributes).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_SECT_FILTER_ATTRS  =
+
+# The QHG_LOCATION tag can be used to specify the location of Qt's
+# qhelpgenerator. If non-empty doxygen will try to run qhelpgenerator on the
+# generated .qhp file.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHG_LOCATION           =
+
+# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files will be
+# generated, together with the HTML files, they form an Eclipse help plugin. To
+# install this plugin and make it available under the help contents menu in
+# Eclipse, the contents of the directory containing the HTML and XML files needs
+# to be copied into the plugins directory of eclipse. The name of the directory
+# within the plugins directory should be the same as the ECLIPSE_DOC_ID value.
+# After copying Eclipse needs to be restarted before the help appears.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_ECLIPSEHELP   = NO
+
+# A unique identifier for the Eclipse help plugin. When installing the plugin
+# the directory name containing the HTML and XML files should also have this
+# name. Each documentation set should have its own identifier.
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_ECLIPSEHELP is set to YES.
+
+ECLIPSE_DOC_ID         = org.doxygen.Project
+
+# If you want full control over the layout of the generated HTML pages it might
+# be necessary to disable the index and replace it with your own. The
+# DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs) at top
+# of each HTML page. A value of NO enables the index and the value YES disables
+# it. Since the tabs in the index contain the same information as the navigation
+# tree, you can set this option to YES if you also set GENERATE_TREEVIEW to YES.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+DISABLE_INDEX          = NO
+
+# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
+# structure should be generated to display hierarchical information. If the tag
+# value is set to YES, a side panel will be generated containing a tree-like
+# index structure (just like the one that is generated for HTML Help). For this
+# to work a browser that supports JavaScript, DHTML, CSS and frames is required
+# (i.e. any modern browser). Windows users are probably better off using the
+# HTML help feature. Via custom style sheets (see HTML_EXTRA_STYLESHEET) one can
+# further fine-tune the look of the index. As an example, the default style
+# sheet generated by doxygen has an example that shows how to put an image at
+# the root of the tree instead of the PROJECT_NAME. Since the tree basically has
+# the same information as the tab index, you could consider setting
+# DISABLE_INDEX to YES when enabling this option.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_TREEVIEW      = YES
+
+# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that
+# doxygen will group on one line in the generated HTML documentation.
+#
+# Note that a value of 0 will completely suppress the enum values from appearing
+# in the overview section.
+# Minimum value: 0, maximum value: 20, default value: 4.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+ENUM_VALUES_PER_LINE   = 4
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be used
+# to set the initial width (in pixels) of the frame in which the tree is shown.
+# Minimum value: 0, maximum value: 1500, default value: 250.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+TREEVIEW_WIDTH         = 250
+
+# If the EXT_LINKS_IN_WINDOW option is set to YES, doxygen will open links to
+# external symbols imported via tag files in a separate window.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+EXT_LINKS_IN_WINDOW    = NO
+
+# Use this tag to change the font size of LaTeX formulas included as images in
+# the HTML documentation. When you change the font size after a successful
+# doxygen run you need to manually remove any form_*.png images from the HTML
+# output directory to force them to be regenerated.
+# Minimum value: 8, maximum value: 50, default value: 10.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+FORMULA_FONTSIZE       = 10
+
+# Use the FORMULA_TRANPARENT tag to determine whether or not the images
+# generated for formulas are transparent PNGs. Transparent PNGs are not
+# supported properly for IE 6.0, but are supported on all modern browsers.
+#
+# Note that when changing this option you need to delete any form_*.png files in
+# the HTML output directory before the changes have effect.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+FORMULA_TRANSPARENT    = YES
+
+# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see
+# https://www.mathjax.org) which uses client side Javascript for the rendering
+# instead of using pre-rendered bitmaps. Use this if you do not have LaTeX
+# installed or if you want to formulas look prettier in the HTML output. When
+# enabled you may also need to install MathJax separately and configure the path
+# to it using the MATHJAX_RELPATH option.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+USE_MATHJAX            = NO
+
+# When MathJax is enabled you can set the default output format to be used for
+# the MathJax output. See the MathJax site (see:
+# http://docs.mathjax.org/en/latest/output.html) for more details.
+# Possible values are: HTML-CSS (which is slower, but has the best
+# compatibility), NativeMML (i.e. MathML) and SVG.
+# The default value is: HTML-CSS.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_FORMAT         = HTML-CSS
+
+# When MathJax is enabled you need to specify the location relative to the HTML
+# output directory using the MATHJAX_RELPATH option. The destination directory
+# should contain the MathJax.js script. For instance, if the mathjax directory
+# is located at the same level as the HTML output directory, then
+# MATHJAX_RELPATH should be ../mathjax. The default value points to the MathJax
+# Content Delivery Network so you can quickly see the result without installing
+# MathJax. However, it is strongly recommended to install a local copy of
+# MathJax from https://www.mathjax.org before deployment.
+# The default value is: http://cdn.mathjax.org/mathjax/latest.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_RELPATH        = http://cdn.mathjax.org/mathjax/latest
+
+# The MATHJAX_EXTENSIONS tag can be used to specify one or more MathJax
+# extension names that should be enabled during MathJax rendering. For example
+# MATHJAX_EXTENSIONS = TeX/AMSmath TeX/AMSsymbols
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_EXTENSIONS     =
+
+# The MATHJAX_CODEFILE tag can be used to specify a file with javascript pieces
+# of code that will be used on startup of the MathJax code. See the MathJax site
+# (see: http://docs.mathjax.org/en/latest/output.html) for more details. For an
+# example see the documentation.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_CODEFILE       =
+
+# When the SEARCHENGINE tag is enabled doxygen will generate a search box for
+# the HTML output. The underlying search engine uses javascript and DHTML and
+# should work on any modern browser. Note that when using HTML help
+# (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET)
+# there is already a search function so this one should typically be disabled.
+# For large projects the javascript based search engine can be slow, then
+# enabling SERVER_BASED_SEARCH may provide a better solution. It is possible to
+# search using the keyboard; to jump to the search box use <access key> + S
+# (what the <access key> is depends on the OS and browser, but it is typically
+# <CTRL>, <ALT>/<option>, or both). Inside the search box use the <cursor down
+# key> to jump into the search results window, the results can be navigated
+# using the <cursor keys>. Press <Enter> to select an item or <escape> to cancel
+# the search. The filter options can be selected when the cursor is inside the
+# search box by pressing <Shift>+<cursor down>. Also here use the <cursor keys>
+# to select a filter and <Enter> or <escape> to activate or cancel the filter
+# option.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+SEARCHENGINE           = YES
+
+# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
+# implemented using a web server instead of a web client using Javascript. There
+# are two flavors of web server based searching depending on the EXTERNAL_SEARCH
+# setting. When disabled, doxygen will generate a PHP script for searching and
+# an index file used by the script. When EXTERNAL_SEARCH is enabled the indexing
+# and searching needs to be provided by external tools. See the section
+# "External Indexing and Searching" for details.
+# The default value is: NO.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SERVER_BASED_SEARCH    = NO
+
+# When EXTERNAL_SEARCH tag is enabled doxygen will no longer generate the PHP
+# script for searching. Instead the search results are written to an XML file
+# which needs to be processed by an external indexer. Doxygen will invoke an
+# external search engine pointed to by the SEARCHENGINE_URL option to obtain the
+# search results.
+#
+# Doxygen ships with an example indexer (doxyindexer) and search engine
+# (doxysearch.cgi) which are based on the open source search engine library
+# Xapian (see: https://xapian.org/).
+#
+# See the section "External Indexing and Searching" for details.
+# The default value is: NO.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTERNAL_SEARCH        = NO
+
+# The SEARCHENGINE_URL should point to a search engine hosted by a web server
+# which will return the search results when EXTERNAL_SEARCH is enabled.
+#
+# Doxygen ships with an example indexer (doxyindexer) and search engine
+# (doxysearch.cgi) which are based on the open source search engine library
+# Xapian (see: https://xapian.org/). See the section "External Indexing and
+# Searching" for details.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SEARCHENGINE_URL       =
+
+# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed
+# search data is written to a file for indexing by an external tool. With the
+# SEARCHDATA_FILE tag the name of this file can be specified.
+# The default file is: searchdata.xml.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SEARCHDATA_FILE        = searchdata.xml
+
+# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the
+# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is
+# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple
+# projects and redirect the results back to the right project.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTERNAL_SEARCH_ID     =
+
+# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen
+# projects other than the one defined by this configuration file, but that are
+# all added to the same external search index. Each project needs to have a
+# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id of
+# to a relative location where the documentation can be found. The format is:
+# EXTRA_SEARCH_MAPPINGS = tagname1=loc1 tagname2=loc2 ...
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTRA_SEARCH_MAPPINGS  =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES, doxygen will generate LaTeX output.
+# The default value is: YES.
+
+GENERATE_LATEX         = YES
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: latex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
+# invoked.
+#
+# Note that when enabling USE_PDFLATEX this option is only used for generating
+# bitmaps for formulas in the HTML output, but not in the Makefile that is
+# written to the output directory.
+# The default file is: latex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_CMD_NAME         = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate
+# index for LaTeX.
+# The default file is: makeindex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# If the COMPACT_LATEX tag is set to YES, doxygen generates more compact LaTeX
+# documents. This may be useful for small projects and may help to save some
+# trees in general.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+COMPACT_LATEX          = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used by the
+# printer.
+# Possible values are: a4 (210 x 297 mm), letter (8.5 x 11 inches), legal (8.5 x
+# 14 inches) and executive (7.25 x 10.5 inches).
+# The default value is: a4.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+PAPER_TYPE             = a4
+
+# The EXTRA_PACKAGES tag can be used to specify one or more LaTeX package names
+# that should be included in the LaTeX output. The package can be specified just
+# by its name or with the correct syntax as to be used with the LaTeX
+# \usepackage command. To get the times font for instance you can specify :
+# EXTRA_PACKAGES=times or EXTRA_PACKAGES={times}
+# To use the option intlimits with the amsmath package you can specify:
+# EXTRA_PACKAGES=[intlimits]{amsmath}
+# If left blank no extra packages will be included.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+EXTRA_PACKAGES         =
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for the
+# generated LaTeX document. The header should contain everything until the first
+# chapter. If it is left blank doxygen will generate a standard header. See
+# section "Doxygen usage" for information on how to let doxygen write the
+# default header to a separate file.
+#
+# Note: Only use a user-defined header if you know what you are doing! The
+# following commands have a special meaning inside the header: $title,
+# $datetime, $date, $doxygenversion, $projectname, $projectnumber,
+# $projectbrief, $projectlogo. Doxygen will replace $title with the empty
+# string, for the replacement values of the other commands the user is referred
+# to HTML_HEADER.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_HEADER           =
+
+# The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for the
+# generated LaTeX document. The footer should contain everything after the last
+# chapter. If it is left blank doxygen will generate a standard footer. See
+# LATEX_HEADER for more information on how to generate a default footer and what
+# special commands can be used inside the footer.
+#
+# Note: Only use a user-defined footer if you know what you are doing!
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_FOOTER           =
+
+# The LATEX_EXTRA_STYLESHEET tag can be used to specify additional user-defined
+# LaTeX style sheets that are included after the standard style sheets created
+# by doxygen. Using this option one can overrule certain style aspects. Doxygen
+# will copy the style sheet files to the output directory.
+# Note: The order of the extra style sheet files is of importance (e.g. the last
+# style sheet in the list overrules the setting of the previous ones in the
+# list).
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_EXTRA_STYLESHEET =
+
+# The LATEX_EXTRA_FILES tag can be used to specify one or more extra images or
+# other source files which should be copied to the LATEX_OUTPUT output
+# directory. Note that the files will be copied as-is; there are no commands or
+# markers available.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_EXTRA_FILES      =
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated is
+# prepared for conversion to PDF (using ps2pdf or pdflatex). The PDF file will
+# contain links (just like the HTML output) instead of page references. This
+# makes the output suitable for online browsing using a PDF viewer.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+PDF_HYPERLINKS         = YES
+
+# If the USE_PDFLATEX tag is set to YES, doxygen will use pdflatex to generate
+# the PDF file directly from the LaTeX files. Set this option to YES, to get a
+# higher quality PDF documentation.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+USE_PDFLATEX           = YES
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \batchmode
+# command to the generated LaTeX files. This will instruct LaTeX to keep running
+# if errors occur, instead of asking the user for help. This option is also used
+# when generating formulas in HTML.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_BATCHMODE        = NO
+
+# If the LATEX_HIDE_INDICES tag is set to YES then doxygen will not include the
+# index chapters (such as File Index, Compound Index, etc.) in the output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_HIDE_INDICES     = NO
+
+# If the LATEX_SOURCE_CODE tag is set to YES then doxygen will include source
+# code with syntax highlighting in the LaTeX output.
+#
+# Note that which sources are shown also depends on other settings such as
+# SOURCE_BROWSER.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_SOURCE_CODE      = NO
+
+# The LATEX_BIB_STYLE tag can be used to specify the style to use for the
+# bibliography, e.g. plainnat, or ieeetr. See
+# https://en.wikipedia.org/wiki/BibTeX and \cite for more info.
+# The default value is: plain.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_BIB_STYLE        = plain
+
+# If the LATEX_TIMESTAMP tag is set to YES then the footer of each generated
+# page will contain the date and time when the page was generated. Setting this
+# to NO can help when comparing the output of multiple runs.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_TIMESTAMP        = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES, doxygen will generate RTF output. The
+# RTF output is optimized for Word 97 and may not look too pretty with other RTF
+# readers/editors.
+# The default value is: NO.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: rtf.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES, doxygen generates more compact RTF
+# documents. This may be useful for small projects and may help to save some
+# trees in general.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated will
+# contain hyperlink fields. The RTF file will contain links (just like the HTML
+# output) instead of page references. This makes the output suitable for online
+# browsing using Word or some other Word compatible readers that support those
+# fields.
+#
+# Note: WordPad (write) and others do not support links.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's config
+# file, i.e. a series of assignments. You only have to provide replacements,
+# missing definitions are set to their default value.
+#
+# See also section "Doxygen usage" for information on how to generate the
+# default style sheet that doxygen normally uses.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_STYLESHEET_FILE    =
+
+# Set optional variables used in the generation of an RTF document. Syntax is
+# similar to doxygen's config file. A template extensions file can be generated
+# using doxygen -e rtf extensionFile.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_EXTENSIONS_FILE    =
+
+# If the RTF_SOURCE_CODE tag is set to YES then doxygen will include source code
+# with syntax highlighting in the RTF output.
+#
+# Note that which sources are shown also depends on other settings such as
+# SOURCE_BROWSER.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_SOURCE_CODE        = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES, doxygen will generate man pages for
+# classes and files.
+# The default value is: NO.
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it. A directory man3 will be created inside the directory specified by
+# MAN_OUTPUT.
+# The default directory is: man.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to the generated
+# man pages. In case the manual section does not start with a number, the number
+# 3 is prepended. The dot (.) at the beginning of the MAN_EXTENSION tag is
+# optional.
+# The default value is: .3.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_EXTENSION          = .3
+
+# The MAN_SUBDIR tag determines the name of the directory created within
+# MAN_OUTPUT in which the man pages are placed. If defaults to man followed by
+# MAN_EXTENSION with the initial . removed.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_SUBDIR             =
+
+# If the MAN_LINKS tag is set to YES and doxygen generates man output, then it
+# will generate one additional man file for each entity documented in the real
+# man page(s). These additional files only source the real man page, but without
+# them the man command would be unable to find the correct page.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES, doxygen will generate an XML file that
+# captures the structure of the code including all documentation.
+# The default value is: NO.
+
+GENERATE_XML           = YES
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: xml.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_OUTPUT             = xml
+
+# If the XML_PROGRAMLISTING tag is set to YES, doxygen will dump the program
+# listings (including syntax highlighting and cross-referencing information) to
+# the XML output. Note that enabling this will significantly increase the size
+# of the XML output.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_PROGRAMLISTING     = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to the DOCBOOK output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_DOCBOOK tag is set to YES, doxygen will generate Docbook files
+# that can be used to generate PDF.
+# The default value is: NO.
+
+GENERATE_DOCBOOK       = NO
+
+# The DOCBOOK_OUTPUT tag is used to specify where the Docbook pages will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be put in
+# front of it.
+# The default directory is: docbook.
+# This tag requires that the tag GENERATE_DOCBOOK is set to YES.
+
+DOCBOOK_OUTPUT         = docbook
+
+# If the DOCBOOK_PROGRAMLISTING tag is set to YES, doxygen will include the
+# program listings (including syntax highlighting and cross-referencing
+# information) to the DOCBOOK output. Note that enabling this will significantly
+# increase the size of the DOCBOOK output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_DOCBOOK is set to YES.
+
+DOCBOOK_PROGRAMLISTING = NO
+
+#---------------------------------------------------------------------------
+# Configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES, doxygen will generate an
+# AutoGen Definitions (see http://autogen.sourceforge.net/) file that captures
+# the structure of the code including all documentation. Note that this feature
+# is still experimental and incomplete at the moment.
+# The default value is: NO.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES, doxygen will generate a Perl module
+# file that captures the structure of the code including all documentation.
+#
+# Note that this feature is still experimental and incomplete at the moment.
+# The default value is: NO.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES, doxygen will generate the necessary
+# Makefile rules, Perl scripts and LaTeX code to be able to generate PDF and DVI
+# output from the Perl module output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES, the Perl module output will be nicely
+# formatted so it can be parsed by a human reader. This is useful if you want to
+# understand what is going on. On the other hand, if this tag is set to NO, the
+# size of the Perl module output will be much smaller and Perl will parse it
+# just the same.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file are
+# prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. This is useful
+# so different doxyrules.make files included by the same Makefile don't
+# overwrite each other's variables.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_MAKEVAR_PREFIX =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES, doxygen will evaluate all
+# C-preprocessor directives found in the sources and include files.
+# The default value is: YES.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES, doxygen will expand all macro names
+# in the source code. If set to NO, only conditional compilation will be
+# performed. Macro expansion can be done in a controlled way by setting
+# EXPAND_ONLY_PREDEF to YES.
+# The default value is: NO.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+MACRO_EXPANSION        = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES then
+# the macro expansion is limited to the macros specified with the PREDEFINED and
+# EXPAND_AS_DEFINED tags.
+# The default value is: NO.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES, the include files in the
+# INCLUDE_PATH will be searched if a #include is found.
+# The default value is: YES.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that
+# contain include files that are not input files but should be processed by the
+# preprocessor.
+# This tag requires that the tag SEARCH_INCLUDES is set to YES.
+
+INCLUDE_PATH           =
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
+# patterns (like *.h and *.hpp) to filter out the header-files in the
+# directories. If left blank, the patterns specified with FILE_PATTERNS will be
+# used.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+INCLUDE_FILE_PATTERNS  =
+
+# The PREDEFINED tag can be used to specify one or more macro names that are
+# defined before the preprocessor is started (similar to the -D option of e.g.
+# gcc). The argument of the tag is a list of macros of the form: name or
+# name=definition (no spaces). If the definition and the "=" are omitted, "=1"
+# is assumed. To prevent a macro definition from being undefined via #undef or
+# recursively expanded use the := operator instead of the = operator.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+PREDEFINED             =
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then this
+# tag can be used to specify a list of macro names that should be expanded. The
+# macro definition that is found in the sources will be used. Use the PREDEFINED
+# tag if you want to use a different macro definition that overrules the
+# definition found in the source code.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+EXPAND_AS_DEFINED      =
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES then doxygen's preprocessor will
+# remove all references to function-like macros that are alone on a line, have
+# an all uppercase name, and do not end with a semicolon. Such function macros
+# are typically used for boiler-plate code, and will confuse the parser if not
+# removed.
+# The default value is: YES.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to external references
+#---------------------------------------------------------------------------
+
+# The TAGFILES tag can be used to specify one or more tag files. For each tag
+# file the location of the external documentation should be added. The format of
+# a tag file without this location is as follows:
+# TAGFILES = file1 file2 ...
+# Adding location for the tag files is done as follows:
+# TAGFILES = file1=loc1 "file2 = loc2" ...
+# where loc1 and loc2 can be relative or absolute paths or URLs. See the
+# section "Linking to external documentation" for more information about the use
+# of tag files.
+# Note: Each tag file must have a unique name (where the name does NOT include
+# the path). If a tag file is not located in the directory in which doxygen is
+# run, you must also specify the path to the tagfile here.
+
+TAGFILES               =
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create a
+# tag file that is based on the input files it reads. See section "Linking to
+# external documentation" for more information about the usage of tag files.
+
+GENERATE_TAGFILE       =
+
+# If the ALLEXTERNALS tag is set to YES, all external class will be listed in
+# the class index. If set to NO, only the inherited external classes will be
+# listed.
+# The default value is: NO.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES, all external groups will be listed
+# in the modules index. If set to NO, only the current project's groups will be
+# listed.
+# The default value is: YES.
+
+EXTERNAL_GROUPS        = YES
+
+# If the EXTERNAL_PAGES tag is set to YES, all external pages will be listed in
+# the related pages index. If set to NO, only the current project's pages will
+# be listed.
+# The default value is: YES.
+
+EXTERNAL_PAGES         = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script
+# interpreter (i.e. the result of 'which perl').
+# The default file (with absolute path) is: /usr/bin/perl.
+
+PERL_PATH              = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES, doxygen will generate a class diagram
+# (in HTML and LaTeX) for classes with base or super classes. Setting the tag to
+# NO turns the diagrams off. Note that this option also works with HAVE_DOT
+# disabled, but it is recommended to install and use dot, since it yields more
+# powerful graphs.
+# The default value is: YES.
+
+CLASS_DIAGRAMS         = YES
+
+# You can define message sequence charts within doxygen comments using the \msc
+# command. Doxygen will then run the mscgen tool (see:
+# http://www.mcternan.me.uk/mscgen/)) to produce the chart and insert it in the
+# documentation. The MSCGEN_PATH tag allows you to specify the directory where
+# the mscgen tool resides. If left empty the tool is assumed to be found in the
+# default search path.
+
+MSCGEN_PATH            =
+
+# You can include diagrams made with dia in doxygen documentation. Doxygen will
+# then run dia to produce the diagram and insert it in the documentation. The
+# DIA_PATH tag allows you to specify the directory where the dia binary resides.
+# If left empty dia is assumed to be found in the default search path.
+
+DIA_PATH               =
+
+# If set to YES the inheritance and collaboration graphs will hide inheritance
+# and usage relations if the target is undocumented or is not a class.
+# The default value is: YES.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
+# available from the path. This tool is part of Graphviz (see:
+# http://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent
+# Bell Labs. The other options in this section have no effect if this option is
+# set to NO
+# The default value is: NO.
+
+HAVE_DOT               = NO
+
+# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is allowed
+# to run in parallel. When set to 0 doxygen will base this on the number of
+# processors available in the system. You can set it explicitly to a value
+# larger than 0 to get control over the balance between CPU load and processing
+# speed.
+# Minimum value: 0, maximum value: 32, default value: 0.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_NUM_THREADS        = 0
+
+# When you want a differently looking font in the dot files that doxygen
+# generates you can specify the font name using DOT_FONTNAME. You need to make
+# sure dot is able to find the font, which can be done by putting it in a
+# standard location or by setting the DOTFONTPATH environment variable or by
+# setting DOT_FONTPATH to the directory containing the font.
+# The default value is: Helvetica.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTNAME           = Helvetica
+
+# The DOT_FONTSIZE tag can be used to set the size (in points) of the font of
+# dot graphs.
+# Minimum value: 4, maximum value: 24, default value: 10.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTSIZE           = 10
+
+# By default doxygen will tell dot to use the default font as specified with
+# DOT_FONTNAME. If you specify a different font using DOT_FONTNAME you can set
+# the path where dot can find it using this tag.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTPATH           =
+
+# If the CLASS_GRAPH tag is set to YES then doxygen will generate a graph for
+# each documented class showing the direct and indirect inheritance relations.
+# Setting this tag to YES will force the CLASS_DIAGRAMS tag to NO.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH tag is set to YES then doxygen will generate a
+# graph for each documented class showing the direct and indirect implementation
+# dependencies (inheritance, containment, and class references variables) of the
+# class with other documented classes.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS tag is set to YES then doxygen will generate a graph for
+# groups, showing the direct groups dependencies.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES, doxygen will generate inheritance and
+# collaboration diagrams in a style similar to the OMG's Unified Modeling
+# Language.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+UML_LOOK               = NO
+
+# If the UML_LOOK tag is enabled, the fields and methods are shown inside the
+# class node. If there are many fields or methods and many nodes the graph may
+# become too big to be useful. The UML_LIMIT_NUM_FIELDS threshold limits the
+# number of items for each type to make the size more manageable. Set this to 0
+# for no limit. Note that the threshold may be exceeded by 50% before the limit
+# is enforced. So when you set the threshold to 10, up to 15 fields may appear,
+# but if the number exceeds 15, the total amount of fields shown is limited to
+# 10.
+# Minimum value: 0, maximum value: 100, default value: 10.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+UML_LIMIT_NUM_FIELDS   = 10
+
+# If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and
+# collaboration graphs will show the relations between templates and their
+# instances.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+TEMPLATE_RELATIONS     = NO
+
+# If the INCLUDE_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are set to
+# YES then doxygen will generate a graph for each documented file showing the
+# direct and indirect include dependencies of the file with other documented
+# files.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INCLUDE_GRAPH          = YES
+
+# If the INCLUDED_BY_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are
+# set to YES then doxygen will generate a graph for each documented file showing
+# the direct and indirect include dependencies of the file with other documented
+# files.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH tag is set to YES then doxygen will generate a call
+# dependency graph for every global function or class method.
+#
+# Note that enabling this option will significantly increase the time of a run.
+# So in most cases it will be better to enable call graphs for selected
+# functions only using the \callgraph command. Disabling a call graph can be
+# accomplished by means of the command \hidecallgraph.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CALL_GRAPH             = NO
+
+# If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller
+# dependency graph for every global function or class method.
+#
+# Note that enabling this option will significantly increase the time of a run.
+# So in most cases it will be better to enable caller graphs for selected
+# functions only using the \callergraph command. Disabling a caller graph can be
+# accomplished by means of the command \hidecallergraph.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CALLER_GRAPH           = NO
+
+# If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical
+# hierarchy of all classes instead of a textual one.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH tag is set to YES then doxygen will show the
+# dependencies a directory has on other directories in a graphical way. The
+# dependency relations are determined by the #include relations between the
+# files in the directories.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
+# generated by dot. For an explanation of the image formats see the section
+# output formats in the documentation of the dot tool (Graphviz (see:
+# http://www.graphviz.org/)).
+# Note: If you choose svg you need to set HTML_FILE_EXTENSION to xhtml in order
+# to make the SVG files visible in IE 9+ (other browsers do not have this
+# requirement).
+# Possible values are: png, jpg, gif, svg, png:gd, png:gd:gd, png:cairo,
+# png:cairo:gd, png:cairo:cairo, png:cairo:gdiplus, png:gdiplus and
+# png:gdiplus:gdiplus.
+# The default value is: png.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_IMAGE_FORMAT       = png
+
+# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
+# enable generation of interactive SVG images that allow zooming and panning.
+#
+# Note that this requires a modern browser other than Internet Explorer. Tested
+# and working are Firefox, Chrome, Safari, and Opera.
+# Note: For IE 9+ you need to set HTML_FILE_EXTENSION to xhtml in order to make
+# the SVG files visible. Older versions of IE do not have SVG support.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INTERACTIVE_SVG        = NO
+
+# The DOT_PATH tag can be used to specify the path where the dot tool can be
+# found. If left blank, it is assumed the dot tool can be found in the path.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_PATH               =
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that
+# contain dot files that are included in the documentation (see the \dotfile
+# command).
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOTFILE_DIRS           =
+
+# The MSCFILE_DIRS tag can be used to specify one or more directories that
+# contain msc files that are included in the documentation (see the \mscfile
+# command).
+
+MSCFILE_DIRS           =
+
+# The DIAFILE_DIRS tag can be used to specify one or more directories that
+# contain dia files that are included in the documentation (see the \diafile
+# command).
+
+DIAFILE_DIRS           =
+
+# When using plantuml, the PLANTUML_JAR_PATH tag should be used to specify the
+# path where java can find the plantuml.jar file. If left blank, it is assumed
+# PlantUML is not used or called during a preprocessing step. Doxygen will
+# generate a warning when it encounters a \startuml command in this case and
+# will not generate output for the diagram.
+
+PLANTUML_JAR_PATH      =
+
+# When using plantuml, the PLANTUML_CFG_FILE tag can be used to specify a
+# configuration file for plantuml.
+
+PLANTUML_CFG_FILE      =
+
+# When using plantuml, the specified paths are searched for files specified by
+# the !include statement in a plantuml block.
+
+PLANTUML_INCLUDE_PATH  =
+
+# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of nodes
+# that will be shown in the graph. If the number of nodes in a graph becomes
+# larger than this value, doxygen will truncate the graph, which is visualized
+# by representing a node as a red box. Note that doxygen if the number of direct
+# children of the root node in a graph is already larger than
+# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note that
+# the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
+# Minimum value: 0, maximum value: 10000, default value: 50.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_GRAPH_MAX_NODES    = 50
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the graphs
+# generated by dot. A depth value of 3 means that only nodes reachable from the
+# root by following a path via at most 3 edges will be shown. Nodes that lay
+# further from the root node will be omitted. Note that setting this option to 1
+# or 2 may greatly reduce the computation time needed for large code bases. Also
+# note that the size of a graph can be further restricted by
+# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
+# Minimum value: 0, maximum value: 1000, default value: 0.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
+# background. This is disabled by default, because dot on Windows does not seem
+# to support this out of the box.
+#
+# Warning: Depending on the platform used, enabling this option may lead to
+# badly anti-aliased labels on the edges of a graph (i.e. they become hard to
+# read).
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_TRANSPARENT        = NO
+
+# Set the DOT_MULTI_TARGETS tag to YES to allow dot to generate multiple output
+# files in one run (i.e. multiple -o and -T options on the command line). This
+# makes dot run faster, but since only newer versions of dot (>1.8.10) support
+# this, this feature is disabled by default.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES doxygen will generate a legend page
+# explaining the meaning of the various boxes and arrows in the dot generated
+# graphs.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES, doxygen will remove the intermediate dot
+# files that are used to generate the various graphs.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_CLEANUP            = YES
diff --git a/device-management/doc/Overview.rst b/device-management/doc/Overview.rst
new file mode 100644
index 00000000..2f2c9d1e
--- /dev/null
+++ b/device-management/doc/Overview.rst
@@ -0,0 +1,4 @@
+Device Management Overview
+==========================
+
+The Device Management library provides an interface to manage the core functionality of the ET-SOC.  This is accomplished by issuing commands to the service processor primarily via the **serviceRequest** method to modify the configuration of the device.  There is a large number of such configuration commands, and these command arguments contain "set" or "reset" in their name (e.g., set module frequency).  There is also a large number of commands to retrieve status from the device, such as current configuration or various aspects of the health and performance of the device.  These command arguments contain "get" in their name (e.g., get asic utilization).  One other notable method for retrieving status from the device is the **getTraceBufferServiceProcessor** method to get various trace data and statistics continuously maintained by the device.
diff --git a/device-management/doc/conf.py.in b/device-management/doc/conf.py.in
new file mode 100644
index 00000000..8e2a749c
--- /dev/null
+++ b/device-management/doc/conf.py.in
@@ -0,0 +1,115 @@
+# Configuration file for the Sphinx documentation builder.
+#
+# This file only contains a selection of the most common options. For a full
+# list see the documentation:
+# http://www.sphinx-doc.org/en/master/config
+
+# -- Path setup --------------------------------------------------------------
+
+# If extensions (or modules to document with autodoc) are in another directory,
+# add these directories to sys.path here. If the directory is relative to the
+# documentation root, use os.path.abspath to make it absolute, like shown here.
+#
+# import os
+# import sys
+# sys.path.insert(0, os.path.abspath('.'))
+
+from exhale import utils
+
+# -- Project information -----------------------------------------------------
+
+project = 'Esperanto Device Management'
+copyright = '2020, Esperanto'
+author = 'Esperanto'
+
+
+# -- General configuration ---------------------------------------------------
+
+# Add any Sphinx extension module names here, as strings. They can be
+# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
+# ones.
+extensions = [
+    'breathe',
+    'exhale'
+]
+
+def specificationsForKind(kind):
+    '''
+    For a given input ``kind``, return the list of reStructuredText specifications
+    for the associated Breathe directive.
+    '''
+    # Change the defaults for .. doxygenclass:: and .. doxygenstruct::
+    if kind == "class" or kind == "struct":
+        return [
+          ":members:",
+          ":protected-members:",
+          ":private-members:",
+          ":undoc-members:"
+        ]
+    else:
+        return []
+
+
+# Setup the breathe extension
+breathe_projects = {
+    "Esperanto Device Management": "./docs/xml"
+}
+breathe_default_project = "Esperanto Device Management"
+
+# Setup the exhale extension
+exhale_args = {
+    # These arguments are required
+    "containmentFolder":     "@CMAKE_CURRENT_BINARY_DIR@/api",
+    "rootFileName":          "EsperantoDeviceManagement_root.rst",
+    "rootFileTitle":         "Esperanto Device Management Architecture",
+    "doxygenStripFromPath":   "@PROJECT_SOURCE_DIR@",
+    # Suggested optional arguments
+    "createTreeView":        True,
+    "treeViewIsBootstrap": True,
+    # TIP: if using the sphinx-bootstrap-theme, you need
+    # "treeViewIsBootstrap": True,
+    "exhaleExecutesDoxygen": True,
+    "exhaleUseDoxyfile": True,
+    # For now use the Doxygenfile directly and not the following
+    # configuration string
+    # "exhaleDoxygenStdin":
+    # """INPUT = @CMAKE_CURRENT_BINARY_DIR@/../include/ \
+    #            @CMAKE_CURRENT_SOURCE_DIR@/../src/ \
+    # FILE_PATTERN = *.h *.cc
+    # """
+    # ... required arguments / other configs ...
+    "customSpecificationsMapping": utils.makeCustomSpecificationsMapping(
+        specificationsForKind
+    )
+}
+
+# Tell sphinx what the primary language being documented is.
+primary_domain = 'c'
+
+# Tell sphinx what the pygments highlight language should be.
+highlight_language = 'c'
+
+
+# Add any paths that contain templates here, relative to this directory.
+templates_path = ['@CMAKE_CURRENT_SOURCE_DIR@/_templates']
+
+# List of patterns, relative to source directory, that match files and
+# directories to ignore when looking for source files.
+# This pattern also affects html_static_path and html_extra_path.
+exclude_patterns = []
+
+
+# -- Options for HTML output -------------------------------------------------
+
+# The theme to use for HTML and HTML Help pages.  See the documentation for
+# a list of builtin themes.
+#
+#html_theme = 'alabaster'
+import sphinx_rtd_theme
+html_theme = 'sphinx_rtd_theme'
+html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]
+
+# Add any paths that contain custom static files (such as style sheets) here,
+# relative to this directory. They are copied after the builtin static files,
+# so a file named "default.css" will overwrite the builtin "default.css".
+htm2l_static_path = ['@CMAKE_CURRENT_SOURCE_DIR@/_static']
diff --git a/device-management/doc/contents.rst b/device-management/doc/contents.rst
new file mode 100644
index 00000000..f3aa8bb7
--- /dev/null
+++ b/device-management/doc/contents.rst
@@ -0,0 +1,12 @@
+Welcome to Esperanto Device Management documentation!
+===========================================================
+.. toctree::
+   :maxdepth: 2
+
+
+Indices and tables
+==================
+
+* :ref:`genindex`
+* :ref:`modindex`
+* :ref:`search`
diff --git a/device-management/doc/index.rst b/device-management/doc/index.rst
new file mode 100644
index 00000000..f65dac84
--- /dev/null
+++ b/device-management/doc/index.rst
@@ -0,0 +1,22 @@
+.. Esperanto Device Management documentation master file
+   This file is the main template which inclues sub pages.This 
+   file should remain `toctree` directive.
+
+###########################################################
+Welcome to Esperanto Device Management documentation!
+###########################################################
+
+
+.. toctree::
+   :maxdepth: 3
+   :caption: Contents:
+
+   Overview
+   api/EsperantoDeviceManagement_root
+
+Indices and tables
+==================
+
+* :ref:`genindex`
+* :ref:`modindex`
+* :ref:`search`
diff --git a/device-management/include/deviceManagement/DeviceManagement.h b/device-management/include/deviceManagement/DeviceManagement.h
new file mode 100644
index 00000000..b6835eaa
--- /dev/null
+++ b/device-management/include/deviceManagement/DeviceManagement.h
@@ -0,0 +1,396 @@
+//******************************************************************************
+// Copyright (C) 2020, Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the2
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#ifndef ET_DEVICEMANAGEMENT_H
+#define ET_DEVICEMANAGAMENT_H
+
+/// @file
+
+#include "device-layer/IDeviceLayer.h"
+#include "deviceManagement/dm.h"
+
+#include <atomic>
+#include <cstdint>
+#include <memory>
+#include <mutex>
+#include <string>
+#include <tuple>
+#include <unordered_map>
+#include <vector>
+
+using namespace dev;
+
+namespace device_management {
+
+static std::unordered_map<std::string, device_mgmt_api::DM_CMD> const commandCodeTable = {
+  {"DM_CMD_GET_MODULE_MANUFACTURE_NAME", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MANUFACTURE_NAME},
+  {"DM_CMD_GET_MODULE_PART_NUMBER", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_PART_NUMBER},
+  {"DM_CMD_SET_MODULE_PART_NUMBER", device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_PART_NUMBER},
+  {"DM_CMD_GET_MODULE_SERIAL_NUMBER", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_SERIAL_NUMBER},
+  {"DM_CMD_GET_ASIC_CHIP_REVISION", device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_CHIP_REVISION},
+  {"DM_CMD_GET_MODULE_PCIE_ADDR", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_PCIE_ADDR},
+  {"DM_CMD_GET_MODULE_PCIE_NUM_PORTS_MAX_SPEED", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_PCIE_NUM_PORTS_MAX_SPEED},
+  {"DM_CMD_GET_MODULE_MEMORY_SIZE_MB", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MEMORY_SIZE_MB},
+  {"DM_CMD_GET_MODULE_REVISION", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_REVISION},
+  {"DM_CMD_GET_MODULE_FORM_FACTOR", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_FORM_FACTOR},
+  {"DM_CMD_GET_MODULE_MEMORY_VENDOR_PART_NUMBER", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MEMORY_VENDOR_PART_NUMBER},
+  {"DM_CMD_GET_MODULE_MEMORY_TYPE", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MEMORY_TYPE},
+  {"DM_CMD_GET_FUSED_PUBLIC_KEYS", device_mgmt_api::DM_CMD::DM_CMD_GET_FUSED_PUBLIC_KEYS},
+  {"DM_CMD_GET_MODULE_FIRMWARE_REVISIONS", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_FIRMWARE_REVISIONS},
+  {"DM_CMD_SET_FIRMWARE_UPDATE", device_mgmt_api::DM_CMD::DM_CMD_SET_FIRMWARE_UPDATE},
+  {"DM_CMD_GET_FIRMWARE_BOOT_STATUS", device_mgmt_api::DM_CMD::DM_CMD_GET_FIRMWARE_BOOT_STATUS},
+  {"DM_CMD_SET_SP_BOOT_ROOT_CERT", device_mgmt_api::DM_CMD::DM_CMD_SET_SP_BOOT_ROOT_CERT},
+  {"DM_CMD_SET_SW_BOOT_ROOT_CERT", device_mgmt_api::DM_CMD::DM_CMD_SET_SW_BOOT_ROOT_CERT},
+  {"DM_CMD_SET_FRU", device_mgmt_api::DM_CMD::DM_CMD_SET_FRU},
+  {"DM_CMD_GET_FRU", device_mgmt_api::DM_CMD::DM_CMD_GET_FRU},
+  {"DM_CMD_RESET_ETSOC", device_mgmt_api::DM_CMD::DM_CMD_RESET_ETSOC},
+  {"DM_CMD_SET_FIRMWARE_VERSION_COUNTER", device_mgmt_api::DM_CMD::DM_CMD_SET_FIRMWARE_VERSION_COUNTER},
+  {"DM_CMD_SET_FIRMWARE_VALID", device_mgmt_api::DM_CMD::DM_CMD_SET_FIRMWARE_VALID},
+  {"DM_CMD_GET_MODULE_TEMPERATURE_THRESHOLDS", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_TEMPERATURE_THRESHOLDS},
+  {"DM_CMD_SET_MODULE_TEMPERATURE_THRESHOLDS", device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_TEMPERATURE_THRESHOLDS},
+  {"DM_CMD_GET_MODULE_POWER_STATE", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_POWER_STATE},
+  {"DM_CMD_SET_MODULE_ACTIVE_POWER_MANAGEMENT", device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_ACTIVE_POWER_MANAGEMENT},
+  {"DM_CMD_GET_MODULE_STATIC_TDP_LEVEL", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_STATIC_TDP_LEVEL},
+  {"DM_CMD_SET_MODULE_STATIC_TDP_LEVEL", device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_STATIC_TDP_LEVEL},
+  {"DM_CMD_GET_MODULE_CURRENT_TEMPERATURE", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_CURRENT_TEMPERATURE},
+  {"DM_CMD_GET_MODULE_RESIDENCY_THROTTLE_STATES", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_RESIDENCY_THROTTLE_STATES},
+  {"DM_CMD_GET_MODULE_UPTIME", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_UPTIME},
+  {"DM_CMD_GET_ASIC_VOLTAGE", device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_VOLTAGE},
+  {"DM_CMD_GET_MODULE_VOLTAGE", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_VOLTAGE},
+  {"DM_CMD_SET_MODULE_VOLTAGE", device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_VOLTAGE},
+  {"DM_CMD_GET_MODULE_POWER", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_POWER},
+  {"DM_CMD_GET_MODULE_MAX_TEMPERATURE", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MAX_TEMPERATURE},
+  {"DM_CMD_GET_MODULE_RESIDENCY_POWER_STATES", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_RESIDENCY_POWER_STATES},
+  {"DM_CMD_GET_MODULE_MAX_DDR_BW", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MAX_DDR_BW},
+  {"DM_CMD_GET_MAX_MEMORY_ERROR", device_mgmt_api::DM_CMD::DM_CMD_GET_MAX_MEMORY_ERROR},
+  {"DM_CMD_SET_DDR_ECC_COUNT", device_mgmt_api::DM_CMD::DM_CMD_SET_DDR_ECC_COUNT},
+  {"DM_CMD_SET_PCIE_ECC_COUNT", device_mgmt_api::DM_CMD::DM_CMD_SET_PCIE_ECC_COUNT},
+  {"DM_CMD_SET_SRAM_ECC_COUNT", device_mgmt_api::DM_CMD::DM_CMD_SET_SRAM_ECC_COUNT},
+  {"DM_CMD_SET_PCIE_RESET", device_mgmt_api::DM_CMD::DM_CMD_SET_PCIE_RESET},
+  {"DM_CMD_GET_MODULE_PCIE_ECC_UECC", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_PCIE_ECC_UECC},
+  {"DM_CMD_GET_MODULE_DDR_BW_COUNTER", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_DDR_BW_COUNTER},
+  {"DM_CMD_GET_MODULE_DDR_ECC_UECC", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_DDR_ECC_UECC},
+  {"DM_CMD_GET_MODULE_SRAM_ECC_UECC", device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_SRAM_ECC_UECC},
+  {"DM_CMD_SET_PCIE_MAX_LINK_SPEED", device_mgmt_api::DM_CMD::DM_CMD_SET_PCIE_MAX_LINK_SPEED},
+  {"DM_CMD_SET_PCIE_LANE_WIDTH", device_mgmt_api::DM_CMD::DM_CMD_SET_PCIE_LANE_WIDTH},
+  {"DM_CMD_SET_PCIE_RETRAIN_PHY", device_mgmt_api::DM_CMD::DM_CMD_SET_PCIE_RETRAIN_PHY},
+  {"DM_CMD_GET_ASIC_FREQUENCIES", device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_FREQUENCIES},
+  {"DM_CMD_SET_FREQUENCY", device_mgmt_api::DM_CMD::DM_CMD_SET_FREQUENCY},
+  {"DM_CMD_GET_DRAM_BANDWIDTH", device_mgmt_api::DM_CMD::DM_CMD_GET_DRAM_BANDWIDTH},
+  {"DM_CMD_GET_DRAM_CAPACITY_UTILIZATION", device_mgmt_api::DM_CMD::DM_CMD_GET_DRAM_CAPACITY_UTILIZATION},
+  {"DM_CMD_GET_ASIC_PER_CORE_DATAPATH_UTILIZATION",
+   device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_PER_CORE_DATAPATH_UTILIZATION},
+  {"DM_CMD_GET_ASIC_UTILIZATION", device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_UTILIZATION},
+  {"DM_CMD_GET_ASIC_STALLS", device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_STALLS},
+  {"DM_CMD_GET_ASIC_LATENCY", device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_LATENCY},
+  {"DM_CMD_GET_MM_ERROR_COUNT", device_mgmt_api::DM_CMD::DM_CMD_GET_MM_ERROR_COUNT},
+  {"DM_CMD_MM_RESET", device_mgmt_api::DM_CMD::DM_CMD_MM_RESET},
+  {"DM_CMD_GET_DEVICE_ERROR_EVENTS", device_mgmt_api::DM_CMD::DM_CMD_GET_DEVICE_ERROR_EVENTS},
+  {"DM_CMD_SET_DM_TRACE_RUN_CONTROL", device_mgmt_api::DM_CMD::DM_CMD_SET_DM_TRACE_RUN_CONTROL},
+  {"DM_CMD_SET_DM_TRACE_CONFIG", device_mgmt_api::DM_CMD::DM_CMD_SET_DM_TRACE_CONFIG},
+  {"DM_CMD_SET_THROTTLE_POWER_STATE_TEST", device_mgmt_api::DM_CMD::DM_CMD_SET_THROTTLE_POWER_STATE_TEST},
+  {"DM_CMD_GET_SP_STATS", device_mgmt_api::DM_CMD::DM_CMD_GET_SP_STATS},
+  {"DM_CMD_GET_MM_STATS", device_mgmt_api::DM_CMD::DM_CMD_GET_MM_STATS},
+  {"DM_CMD_SET_STATS_RUN_CONTROL", device_mgmt_api::DM_CMD::DM_CMD_SET_STATS_RUN_CONTROL},
+  {"DM_CMD_SET_SHIRE_CACHE_CONFIG", device_mgmt_api::DM_CMD::DM_CMD_SET_SHIRE_CACHE_CONFIG},
+  {"DM_CMD_GET_SHIRE_CACHE_CONFIG", device_mgmt_api::DM_CMD::DM_CMD_GET_SHIRE_CACHE_CONFIG},
+  {"DM_CMD_SET_VMIN_LUT", device_mgmt_api::DM_CMD::DM_CMD_SET_VMIN_LUT},
+  {"DM_CMD_GET_VMIN_LUT", device_mgmt_api::DM_CMD::DM_CMD_GET_VMIN_LUT},
+  {"DM_CMD_MDI_SELECT_HART", device_mgmt_api::DM_CMD::DM_CMD_MDI_SELECT_HART},
+  {"DM_CMD_MDI_UNSELECT_HART", device_mgmt_api::DM_CMD::DM_CMD_MDI_UNSELECT_HART},
+  {"DM_CMD_MDI_RESET_HART", device_mgmt_api::DM_CMD::DM_CMD_MDI_RESET_HART},
+  {"DM_CMD_MDI_HALT_HART", device_mgmt_api::DM_CMD::DM_CMD_MDI_HALT_HART},
+  {"DM_CMD_MDI_RESUME_HART", device_mgmt_api::DM_CMD::DM_CMD_MDI_RESUME_HART},
+  {"DM_CMD_MDI_GET_HART_STATUS", device_mgmt_api::DM_CMD::DM_CMD_MDI_GET_HART_STATUS},
+  {"DM_CMD_MDI_SET_BREAKPOINT", device_mgmt_api::DM_CMD::DM_CMD_MDI_SET_BREAKPOINT},
+  {"DM_CMD_MDI_UNSET_BREAKPOINT", device_mgmt_api::DM_CMD::DM_CMD_MDI_UNSET_BREAKPOINT},
+  {"DM_CMD_MDI_ENABLE_SINGLE_STEP", device_mgmt_api::DM_CMD::DM_CMD_MDI_ENABLE_SINGLE_STEP},
+  {"DM_CMD_MDI_DISABLE_SINGLE_STEP", device_mgmt_api::DM_CMD::DM_CMD_MDI_DISABLE_SINGLE_STEP},
+  {"DM_CMD_MDI_READ_GPR", device_mgmt_api::DM_CMD::DM_CMD_MDI_READ_GPR},
+  {"DM_CMD_MDI_DUMP_GPR", device_mgmt_api::DM_CMD::DM_CMD_MDI_DUMP_GPR},
+  {"DM_CMD_MDI_WRITE_GPR", device_mgmt_api::DM_CMD::DM_CMD_MDI_WRITE_GPR},
+  {"DM_CMD_MDI_READ_CSR", device_mgmt_api::DM_CMD::DM_CMD_MDI_READ_CSR},
+  {"DM_CMD_MDI_WRITE_CSR", device_mgmt_api::DM_CMD::DM_CMD_MDI_WRITE_CSR},
+  {"DM_CMD_MDI_READ_MEM", device_mgmt_api::DM_CMD::DM_CMD_MDI_READ_MEM},
+  {"DM_CMD_MDI_WRITE_MEM", device_mgmt_api::DM_CMD::DM_CMD_MDI_WRITE_MEM}};
+
+static std::unordered_map<std::string, device_mgmt_api::ACTIVE_POWER_MANAGEMENT> const activePowerManagementTable = {
+  {"ACTIVE_POWER_MANAGEMENT_TURN_OFF", device_mgmt_api::ACTIVE_POWER_MANAGEMENT::ACTIVE_POWER_MANAGEMENT_TURN_OFF},
+  {"ACTIVE_POWER_MANAGEMENT_TURN_ON", device_mgmt_api::ACTIVE_POWER_MANAGEMENT::ACTIVE_POWER_MANAGEMENT_TURN_ON},
+  {"ACTIVE_POWER_MANAGEMENT_INVALID", device_mgmt_api::ACTIVE_POWER_MANAGEMENT::ACTIVE_POWER_MANAGEMENT_INVALID}};
+
+static std::unordered_map<std::string, device_mgmt_api::PCIE_RESET> const pcieResetTable = {
+  {"PCIE_RESET_FLR", device_mgmt_api::PCIE_RESET::PCIE_RESET_FLR},
+  {"PCIE_RESET_HOT", device_mgmt_api::PCIE_RESET::PCIE_RESET_HOT},
+  {"PCIE_RESET_WARM", device_mgmt_api::PCIE_RESET::PCIE_RESET_WARM}};
+
+static std::unordered_map<std::string, device_mgmt_api::PCIE_LINK_SPEED> const pcieLinkSpeedTable = {
+  {"PCIE_LINK_SPEED_GEN3", device_mgmt_api::PCIE_LINK_SPEED::PCIE_LINK_SPEED_GEN3},
+  {"PCIE_LINK_SPEED_GEN4", device_mgmt_api::PCIE_LINK_SPEED::PCIE_LINK_SPEED_GEN4}};
+
+static std::unordered_map<std::string, device_mgmt_api::PCIE_LANE_W_SPLIT> const pcieLaneWidthTable = {
+  {"PCIE_LANE_W_SPLIT_x4", device_mgmt_api::PCIE_LANE_W_SPLIT::PCIE_LANE_W_SPLIT_x4},
+  {"PCIE_LANE_W_SPLIT_x8", device_mgmt_api::PCIE_LANE_W_SPLIT::PCIE_LANE_W_SPLIT_x8}};
+
+struct lockable_;
+
+struct dm_cmd {
+  device_mgmt_api::dev_mgmt_cmd_header_t info;
+  std::unique_ptr<char[]> payload;
+};
+
+struct dm_rsp {
+  device_mgmt_api::dev_mgmt_rsp_header_t info;
+  char payload[1];
+};
+
+struct dm_evt {
+  device_mgmt_api::evt_header_t info;
+  char payload[1];
+};
+
+typedef std::unordered_map<std::string, device_mgmt_api::DM_CMD>::const_iterator itCmd;
+
+/// @class DeviceManagement
+class DeviceManagement {
+public:
+  /// @brief Get instance to DeviceManagement
+  ///
+  /// @return DeviceManagement object
+  static DeviceManagement& getInstance(IDeviceLayer* devLayer);
+
+  /// @brief  Get total number of devices in system
+  ///
+  /// @return Total number of devices
+  int getDevicesCount();
+
+  /// @brief Send service request to device and wait for response
+  ///
+  /// @param[in] device_node  device index to use
+  /// @param[in] cmd_code  Command code to service
+  /// @param[inout] input_buff  pointer to data to send to device accompanying
+  /// the command to service
+  /// @param[in] input_size  size in bytes of the input_buff data
+  /// @param[inout] output_buff  pointer to data received from the device after
+  /// servicing the request
+  /// @param[in] output_size  size in bytes of the output_buff data
+  /// @param[inout] host_latency  Total time in miliseconds spent on the
+  /// host side servicing a request; inclusive of dev_latency_micros
+  /// @param[inout] dev_latency  Total time in microseconds spent on the
+  /// device side servicing a request
+  /// @param[in] timeout  Time to wait for the request to complete, i.e.
+  /// to receive a message.
+  ///
+  /// @return Success of the request. Zero if the read was succesfull.
+  int serviceRequest(const uint32_t device_node, uint32_t cmd_code, const char* input_buff, const uint32_t input_size,
+                     char* output_buff, const uint32_t output_size, uint32_t* host_latency, uint64_t* dev_latency,
+                     uint32_t timeout);
+
+  /// @brief Get Service Process's trace buffer
+  ///
+  /// @param[in] device_node  device index to use
+  /// @param[inout] response  trace buffer received from the device after
+  /// servicing the request
+  ///
+  /// @return Zero if the call was succesfull.
+  int getTraceBufferServiceProcessor(const uint32_t device_node, TraceBufferType buf_type,
+                                     std::vector<std::byte>& response);
+
+  /// @brief Gets the MDI event type
+  ///
+  /// @param[in] device_node  device index to use
+  /// @param[out] event  A vector containing the complete event message
+  /// @param[in] timeout  Time to wait for the event to receive
+  ///
+  /// @return true if event is received in given timeout else false
+  bool getMDIEvent(const uint32_t device_node, std::vector<std::byte>& event, uint32_t timeout);
+
+  /* TODO: SW-18541 - This API will be deprecated */
+  /// @brief Gets the MDI event type
+  ///
+  /// @param[in] device_node  device index to use
+  /// @param[out] event  A vector containing the complete event message
+  /// @param[in] timeout  Time to wait for the event to receive
+  ///
+  /// @return true if event is received in given timeout else false
+  bool getEvent(const uint32_t device_node, std::vector<std::byte>& event, uint32_t timeout);
+
+  /// @brief Gets the DM event
+  ///
+  /// @param[in] device_node  device index to use
+  /// @param[out] event  A vector containing the complete event message
+  /// @param[in] timeout  Time to wait for the event to receive
+  ///
+  /// @return true if event is received in given timeout else false
+  bool getDMEvent(const uint32_t device_node, std::vector<std::byte>& event, uint32_t timeout);
+
+private:
+  /// @brief DeviceManagement constructors
+  DeviceManagement(){};
+  // DeviceManagement(IDeviceLayer *devLayer){devLayer_ = devLayer;};
+  DeviceManagement(const DeviceManagement& dm){};
+
+  /// @brief DeviceManagement Destructor
+  ~DeviceManagement() {
+    destroyDevicesInstance();
+  };
+
+  struct destruction_;
+
+  /// @brief Determine if command is a 'set' or 'get' data command
+  ///
+  /// @param[in] cmd  Command code table iterator
+  ///
+  /// @return True if 'set' command
+  bool isSetCommand(itCmd& cmd);
+
+  /// @brief Determine if command is a 'set' or 'get' data command
+  ///
+  /// @param[in] cmd  Command code table iterator
+  ///
+  /// @return True if 'get' command
+  bool isGetCommand(itCmd& cmd);
+
+  /// @brief Determine if command code is a valid command
+  ///
+  /// @param[in] cmd_code  Command code to check
+  ///
+  /// @return Command code table iterator
+  itCmd isValidCommand(uint32_t cmd_code);
+
+  /// @brief Determine if Active Power Management is a valid
+  ///
+  /// @param[in] input_buff  Input buffer to check
+  ///
+  /// @return True if Active Power Management is valid
+  bool isValidActivePowerManagement(const char* input_buff);
+
+  /// @brief Determine if TDP is a valid
+  ///
+  /// @param[in] input_buff  Input buffer to check
+  ///
+  /// @return True if TDP level is valid
+  bool isValidTdpLevel(const char* input_buff);
+
+  /// @brief Determine if Temprature is in valid range
+  ///
+  /// @param[in] input_buff  Input buffer to check
+  ///
+  /// @return True if Temprature is in valid range
+  bool isValidTemperature(const char* input_buff);
+
+  /// @brief Determine if PCIE  link speed is in valid range
+  ///
+  /// @param[in] input_buff  Input buffer to check
+  ///
+  /// @return True if PCIE link speed is in valid range
+  bool isValidPcieLinkSpeed(const char* input_buff);
+
+  /// @brief Determine if PCIE Lane Width is valid
+  ///
+  /// @param[in] input_buff  Input buffer to check
+  ///
+  /// @return True if PCIE Lane Width is valid
+  bool isValidPcieLaneWidth(const char* input_buff);
+
+  /// @brief Determine if parameter related to command is valid
+  ///
+  /// @param[in] cmd_code  Command code for which parameter needs validation
+  ///
+  /// @param[in] input_buff  Input buffer containing parameter
+  /// @return True if parameter is valid
+  bool isInputBufferValid(uint32_t cmd_code, const char* input_buff);
+
+  /// @brief Determine if device node is a valid node
+  ///
+  /// @param[in] device_node  Device node to check
+  ///
+  /// @return True if valid device node
+  bool isValidDeviceNode(const uint32_t device_node);
+
+  /// @brief Gets a mapped lockable device based on tokenized node data
+  ///
+  /// @param[in] index  index of device
+  ///
+  /// @return Smart shared pointer to lockable_ struct wrapping the device
+  std::shared_ptr<lockable_> getDeviceInstance(const uint32_t index);
+
+  /// @brief Fetch firmware image, verify, and write to FW region
+  ///
+  /// @param[in] lockable  Smart shared pointer to lockable_ struct wrapping
+  /// the device index
+  /// @param[inout] filePath  Pointer to firmware image path on filesystem
+  int updateFirmwareImage(std::shared_ptr<lockable_> lockable, const char* filePath);
+
+  /// @brief Determine if provided SHA512 is valid
+  ///
+  /// @param[in] str  Command code to check
+  ///
+  /// @return True if valid SHA512
+  bool isValidSHA512(const std::string& str);
+
+  /// @brief Read provided file and extract potential SHA512
+  ///
+  /// @param[inout] filePath  Pointer to hash file on filesystem
+  ///
+  /// @param[inout] hash  reference to unsigned char vector
+  int processHashFile(const char* filePath, std::vector<unsigned char>& hash);
+
+  /// @brief Get the provided IDeviceLayer pointer
+  ///
+  /// @return IDeviceLayer*
+  IDeviceLayer* getDeviceLayer();
+
+  /// @brief Set the provided IDeviceLayer pointer
+  ///
+  /// @param[in] ptr  IDeviceLayer pointer
+  void setDeviceLayer(IDeviceLayer* ptr);
+
+  /// @brief Communicates with device for receiving the responses or events
+  ///
+  /// @param[in] lockable  Smart shared pointer to lockable_ struct representing
+  /// device
+  void receiver(std::shared_ptr<lockable_> lockable);
+
+  /// @brief Create device profile
+  ///
+  /// @param[in] device_node  device index to use
+  void createDeviceInstance(const uint32_t device_node);
+
+  /// @brief Destroy device profile
+  ///
+  /// @param[in] device_node  device index to use
+  /// @param[in] waitReceiverExit wait for receiver thread to exit
+  void destroyDeviceInstance(const uint32_t device_node, bool waitReceiverExit = false);
+
+  /// @brief Destroy all devices profile
+  ///
+  /// @param[in] waitReceiverExit wait for receiver thread to exit
+  void destroyDevicesInstance(bool waitReceiverExit = false);
+
+  /// @brief Handles the event message types
+  ///
+  /// @param[in] device_node  device index to use
+  /// @param[in] message Vector containing raw received message
+  ///
+  /// @param[out] return true if given message was event and handled correctly
+  bool handleEvent(const uint32_t device_node, std::vector<std::byte>& message);
+
+  std::unordered_map<uint32_t, std::shared_ptr<lockable_>> deviceMap_;
+  std::mutex deviceMapMtx_;
+  IDeviceLayer* devLayer_;
+  std::atomic<device_mgmt_api::tag_id_t> tag_id_;
+};
+
+typedef DeviceManagement& (*getDM_t)(IDeviceLayer* devLayer);
+
+} // namespace device_management
+
+#endif // ET_DEVICEMANAGEMENT_H
diff --git a/device-management/include/deviceManagement/dm.h b/device-management/include/deviceManagement/dm.h
new file mode 100644
index 00000000..ccfa2665
--- /dev/null
+++ b/device-management/include/deviceManagement/dm.h
@@ -0,0 +1,22 @@
+/**
+ * Copyright (c) 2018-present, Esperanto Technologies Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ET_DM_H
+#define ET_DM_H
+
+#include <esperanto/device-apis/management-api/device_mgmt_api_cxx.h>
+
+#endif // ET_DM_H
diff --git a/device-management/src/DeviceManagement.cc b/device-management/src/DeviceManagement.cc
new file mode 100644
index 00000000..3edd2643
--- /dev/null
+++ b/device-management/src/DeviceManagement.cc
@@ -0,0 +1,625 @@
+//******************************************************************************
+// Copyright (C) 2020, Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the2
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "deviceManagement/DeviceManagement.h"
+#include "device-layer/IDeviceLayer.h"
+#include "utils.h"
+
+#include <cerrno>
+#include <cstring>
+#include <chrono>
+#include <exception>
+#include <fstream>
+#include <iostream>
+#include <memory>
+#include <regex>
+#include <sstream>
+#include <tuple>
+#include <unordered_map>
+#include <vector>
+
+/* Maximum DM events for fixed queue*/
+#define MAX_DM_EVENTS 100
+
+using namespace dev;
+
+namespace device_management {
+
+template <typename T, int MaxLen, typename Container = std::deque<T>>
+class FixedQueue : public std::queue<T, Container> {
+public:
+  void push(const T& value) {
+    if (this->size() == MaxLen) {
+      this->c.pop_front();
+    }
+    std::queue<T, Container>::push(value);
+  }
+};
+
+struct lockable_ {
+  explicit lockable_(uint32_t index)
+    : idx(index) {
+    exitReceiverFuture = exitReceiverPromise.get_future();
+  }
+
+  ~lockable_() {
+    if (receiverRunning) {
+      receiverRunning = false;
+    }
+    eventsCv.notify_all();
+  }
+
+  std::future<std::vector<std::byte>> getRespReceiveFuture(device_mgmt_api::tag_id_t tagId) {
+    std::scoped_lock lk(commandMapMtx);
+    std::promise<std::vector<std::byte>> p;
+    commandMap.insert_or_assign(tagId, std::move(p));
+    return commandMap[tagId].get_future();
+  };
+
+  bool fulfillRespReceivePromise(const std::vector<std::byte>& response) {
+    auto tagId = reinterpret_cast<const dm_rsp*>(response.data())->info.rsp_hdr.tag_id;
+    std::scoped_lock lk(commandMapMtx);
+    if (auto it = commandMap.find(tagId); it != commandMap.end()) {
+      it->second.set_value(response);
+      commandMap.erase(it);
+      return true;
+    }
+    auto rsp = reinterpret_cast<const dm_rsp*>(response.data());
+    DV_LOG(FATAL) << "Stray response received: tag_id: " << rsp->info.rsp_hdr.tag_id
+                  << ", msg_id: " << rsp->info.rsp_hdr.msg_id;
+    // An unkept promise cannot be fulfilled
+    return false;
+  }
+
+  void pushEvent(std::vector<std::byte>& event) {
+    std::scoped_lock lk(eventsMtx);
+    auto rCB = reinterpret_cast<const dm_evt*>(event.data());
+    if (rCB->info.event_hdr.msg_id >= device_mgmt_api::DM_CMD_MDI_SET_BREAKPOINT_EVENT &&
+        rCB->info.event_hdr.msg_id < device_mgmt_api::DM_CMD_MDI_END) {
+      mdiEvents.push(std::move(event));
+    } else if (rCB->info.event_hdr.msg_id >= device_mgmt_api::DM_EVENT_SP_TRACE_BUFFER_FULL &&
+               rCB->info.event_hdr.msg_id < device_mgmt_api::DM_EVENT_END) {
+      dmEvents.push(std::move(event));
+    }
+    eventsCv.notify_all();
+  }
+
+  bool popMDIEvent(std::vector<std::byte>& event, uint32_t timeout) {
+    std::unique_lock lk(eventsMtx);
+    if (eventsCv.wait_for(lk, std::chrono::milliseconds(timeout),
+                          [this]() { return !receiverRunning || !mdiEvents.empty(); })) {
+      if (!mdiEvents.empty()) {
+        event = std::move(mdiEvents.front());
+        mdiEvents.pop();
+        return true;
+      }
+    }
+    return false;
+  }
+
+  bool popDMEvent(std::vector<std::byte>& event, uint32_t timeout) {
+    std::unique_lock lk(eventsMtx);
+    if (eventsCv.wait_for(lk, std::chrono::milliseconds(timeout),
+                          [this]() { return !receiverRunning || !dmEvents.empty(); })) {
+      if (!dmEvents.empty()) {
+        event = std::move(dmEvents.front());
+        dmEvents.pop();
+        return true;
+      }
+    }
+    return false;
+  }
+
+  uint32_t idx;
+  // receiver is run in detach mode so no need to wait for receiver thread to join
+  // But for some scenarios when it is required to know the completion of receiver
+  // thread exitReceiverFuture can be used.
+  std::thread receiver;
+  std::atomic<bool> receiverRunning = false;
+  std::shared_future<void> exitReceiverFuture;
+  std::promise<void> exitReceiverPromise;
+  std::timed_mutex sqGuard;
+  std::timed_mutex cqGuard;
+
+private:
+  std::unordered_map<device_mgmt_api::tag_id_t, std::promise<std::vector<std::byte>>> commandMap;
+  std::mutex commandMapMtx;
+  std::mutex eventsMtx;
+  std::condition_variable eventsCv;
+  std::queue<std::vector<std::byte>> mdiEvents;
+  FixedQueue<std::vector<std::byte>, MAX_DM_EVENTS> dmEvents;
+};
+
+bool DeviceManagement::handleEvent(const uint32_t device_node, std::vector<std::byte>& message) {
+  auto rCB = reinterpret_cast<const dm_evt*>(message.data());
+  // The range can be extended to handle all type of events
+  if ((rCB->info.event_hdr.msg_id >= device_mgmt_api::DM_CMD_MDI_SET_BREAKPOINT_EVENT &&
+       rCB->info.event_hdr.msg_id < device_mgmt_api::DM_CMD_MDI_END) ||
+      (rCB->info.event_hdr.msg_id >= device_mgmt_api::DM_EVENT_BEGIN &&
+       rCB->info.event_hdr.msg_id < device_mgmt_api::DM_EVENT_END)) {
+
+    auto lockable = getDeviceInstance(device_node);
+    lockable->pushEvent(message);
+    return true;
+  }
+  return false;
+}
+
+bool DeviceManagement::getMDIEvent(const uint32_t device_node, std::vector<std::byte>& event, uint32_t timeout) {
+  auto lockable = getDeviceInstance(device_node);
+  return lockable->popMDIEvent(event, timeout);
+}
+
+/* TODO: SW-18541 - This API is deprecated, use getMDIEvent() instead */
+bool DeviceManagement::getEvent(const uint32_t device_node, std::vector<std::byte>& event, uint32_t timeout) {
+  return getMDIEvent(device_node, event, timeout);
+}
+
+bool DeviceManagement::getDMEvent(const uint32_t device_node, std::vector<std::byte>& event, uint32_t timeout) {
+  auto lockable = getDeviceInstance(device_node);
+  return lockable->popDMEvent(event, timeout);
+}
+
+void DeviceManagement::receiver(std::shared_ptr<lockable_> lockable) {
+  while (lockable->receiverRunning) {
+    lockable->cqGuard.lock();
+    std::vector<std::byte> message;
+    while (devLayer_->receiveResponseServiceProcessor(lockable->idx, message)) {
+      if (handleEvent(lockable->idx, message)) {
+        continue;
+      }
+      if (!lockable->fulfillRespReceivePromise(message)) {
+        DV_DLOG(WARNING) << "receiver: discarding the stray message";
+      }
+    }
+    lockable->cqGuard.unlock();
+    auto sqAvail = false;
+    auto cqAvail = false;
+    while (lockable->receiverRunning && !cqAvail) {
+      try {
+        devLayer_->waitForEpollEventsServiceProcessor(lockable->idx, sqAvail, cqAvail, std::chrono::seconds(1));
+      } catch (const dev::Exception& ex) {
+        if (std::string(ex.what()).find(std::strerror(EINTR)) != std::string::npos) {
+          // Ignore 'Interrupted system call' error since this thread is running
+          // in detach mode and epoll call can be interrupted during tear-down.
+          continue;
+        }
+        auto eptr = std::make_exception_ptr(ex);
+        std::rethrow_exception(eptr);
+      }
+    }
+  }
+  lockable->exitReceiverPromise.set_value_at_thread_exit();
+}
+
+struct DeviceManagement::destruction_ {
+  void operator()(const DeviceManagement* const ptr) {
+    delete ptr;
+  }
+};
+
+DeviceManagement& DeviceManagement::getInstance(IDeviceLayer* devLayer) {
+  static std::unique_ptr<DeviceManagement, destruction_> instance(new DeviceManagement());
+  (*instance).setDeviceLayer(devLayer);
+  for (int i = 0; i < devLayer->getDevicesCount(); i++) {
+    (*instance).createDeviceInstance(static_cast<unsigned int>(i));
+  }
+  return *instance;
+}
+
+void DeviceManagement::setDeviceLayer(IDeviceLayer* ptr) {
+  devLayer_ = ptr;
+}
+
+itCmd DeviceManagement::isValidCommand(uint32_t cmd_code) {
+  for (auto it = commandCodeTable.begin(); it != commandCodeTable.end(); ++it) {
+    if (it->second == cmd_code) {
+      DV_DLOG(DEBUG) << "Command: " << it->first << " code: " << it->second << std::endl;
+      return it;
+    }
+  }
+
+  return commandCodeTable.end();
+}
+
+bool DeviceManagement::isValidDeviceNode(const uint32_t device_node) {
+  return device_node < devLayer_->getDevicesCount();
+}
+
+int DeviceManagement::getDevicesCount() {
+  return devLayer_->getDevicesCount();
+}
+
+bool DeviceManagement::isSetCommand(itCmd& cmd) {
+  if (cmd->first.find("DM_CMD_SET") == 0) {
+    return true;
+  }
+
+  return false;
+}
+
+bool DeviceManagement::isGetCommand(itCmd& cmd) {
+  if (cmd->first.find("DM_CMD_GET") == 0) {
+    return true;
+  }
+
+  return false;
+}
+
+void DeviceManagement::createDeviceInstance(const uint32_t device_node) {
+  std::scoped_lock lk(deviceMapMtx_);
+  if (auto& ptr = deviceMap_[device_node]; !ptr) {
+    ptr = std::make_shared<lockable_>(device_node);
+    if (!ptr->receiverRunning) {
+      ptr->receiverRunning = true;
+      ptr->receiver = std::thread(std::bind(&DeviceManagement::receiver, this, ptr));
+      ptr->receiver.detach();
+    }
+  }
+}
+
+void DeviceManagement::destroyDeviceInstance(const uint32_t device_node, bool waitReceiverExit) {
+  std::scoped_lock lk(deviceMapMtx_);
+  if (auto& ptr = deviceMap_[device_node]; ptr) {
+    ptr->receiverRunning = false;
+    if (waitReceiverExit) {
+      ptr->exitReceiverFuture.get();
+    }
+  }
+  deviceMap_.erase(device_node);
+}
+
+void DeviceManagement::destroyDevicesInstance(bool waitReceiverExit) {
+  std::scoped_lock lk(deviceMapMtx_);
+  for (auto& d : deviceMap_) {
+    if (auto& ptr = d.second; ptr) {
+      ptr->receiverRunning = false;
+    }
+  }
+  if (waitReceiverExit) {
+    for (auto& d : deviceMap_) {
+      auto& ptr = d.second;
+      if (auto& ptr = d.second; ptr) {
+        ptr->exitReceiverFuture.get();
+      }
+    }
+  }
+  deviceMap_.clear();
+}
+
+std::shared_ptr<lockable_> DeviceManagement::getDeviceInstance(const uint32_t index) {
+  std::scoped_lock lk(deviceMapMtx_);
+  auto& ptr = deviceMap_[index];
+  if (!ptr) {
+    throw Exception("Device[" + std::to_string(index) + "] does not exist!");
+  }
+  return deviceMap_[index];
+}
+
+int DeviceManagement::updateFirmwareImage(std::shared_ptr<lockable_> lockable, const char* filePath) {
+
+  std::ifstream file(filePath, std::ios::binary);
+
+  if (!file.good()) {
+    return -EINVAL;
+  }
+
+  std::vector<unsigned char> fwImage(std::istreambuf_iterator<char>(file), {});
+
+  if (!devLayer_->updateFirmwareImage(lockable->idx, fwImage)) {
+    DV_LOG(INFO) << "DeviceManagement::updateFirmwareImage failed" << std::endl;
+    return -EIO;
+  }
+
+  DV_LOG(DEBUG) << "Written firmware image of size: " << fwImage.size() << std::endl;
+  return 0;
+}
+
+bool DeviceManagement::isValidSHA512(const std::string& str) {
+  std::regex re("^[[:xdigit:]]{128}$");
+  std::smatch m;
+
+  if (!std::regex_search(str, m, re)) {
+    return false;
+  }
+
+  return true;
+}
+
+int DeviceManagement::processHashFile(const char* filePath, std::vector<unsigned char>& hash) {
+  std::ifstream file(filePath);
+
+  if (!file.good()) {
+    return -EINVAL;
+  }
+
+  std::string contents("");
+  std::copy_n(std::istreambuf_iterator<char>(file), 128, std::back_inserter(contents));
+
+  if (!isValidSHA512(contents)) {
+    return -EINVAL;
+  }
+
+  for (uint32_t i = 0; i < contents.size(); i += 2) {
+    std::stringstream ss("");
+    unsigned long value = 0;
+
+    ss << contents[i] << contents[i + 1];
+
+    if (ss.fail()) {
+      return -EIO;
+    }
+
+    ss >> std::hex >> value;
+    hash.emplace(hash.end(), value);
+  }
+
+  return 0;
+}
+
+int DeviceManagement::getTraceBufferServiceProcessor(const uint32_t device_node, TraceBufferType trace_type,
+                                                     std::vector<std::byte>& response) {
+  if (!isValidDeviceNode(device_node)) {
+    return -EINVAL;
+  }
+
+  devLayer_->getTraceBufferServiceProcessor(device_node, trace_type, response);
+  return 0;
+}
+
+bool DeviceManagement::isValidActivePowerManagement(const char* input_buff) {
+  for (auto it = activePowerManagementTable.begin(); it != activePowerManagementTable.end(); ++it) {
+    if (it->second == *input_buff) {
+      return true;
+    }
+  }
+  return false;
+}
+
+bool DeviceManagement::isValidTemperature(const char* input_buff) {
+  device_mgmt_api::temperature_threshold_t* temperature_threshold =
+    (device_mgmt_api::temperature_threshold_t*)input_buff;
+  if (temperature_threshold->sw_temperature_c >= 20 && temperature_threshold->sw_temperature_c <= 125) {
+    return true;
+  }
+  return false;
+}
+
+bool DeviceManagement::isValidPcieLinkSpeed(const char* input_buff) {
+  for (auto it = pcieLinkSpeedTable.begin(); it != pcieLinkSpeedTable.end(); ++it) {
+    if (it->second == *input_buff) {
+      return true;
+    }
+  }
+  return false;
+}
+
+bool DeviceManagement::isValidPcieLaneWidth(const char* input_buff) {
+  for (auto it = pcieLaneWidthTable.begin(); it != pcieLaneWidthTable.end(); ++it) {
+    if (it->second == *input_buff) {
+      return true;
+    }
+  }
+  return false;
+}
+
+bool DeviceManagement::isInputBufferValid(uint32_t cmd_code, const char* input_buff) {
+  bool ret;
+  switch (cmd_code) {
+  case device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_ACTIVE_POWER_MANAGEMENT:
+    ret = isValidActivePowerManagement(input_buff);
+    break;
+  case device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_TEMPERATURE_THRESHOLDS:
+    ret = isValidTemperature(input_buff);
+    break;
+  case device_mgmt_api::DM_CMD::DM_CMD_SET_PCIE_MAX_LINK_SPEED:
+    ret = isValidPcieLinkSpeed(input_buff);
+    break;
+  case device_mgmt_api::DM_CMD::DM_CMD_SET_PCIE_LANE_WIDTH:
+    ret = isValidPcieLaneWidth(input_buff);
+    break;
+  default:
+    ret = true;
+    break;
+  }
+  return ret;
+}
+
+int DeviceManagement::serviceRequest(const uint32_t device_node, uint32_t cmd_code, const char* input_buff,
+                                     const uint32_t input_size, char* output_buff, const uint32_t output_size,
+                                     uint32_t* host_latency, uint64_t* dev_latency, uint32_t timeout) {
+
+  auto start = std::chrono::steady_clock::now();
+  auto end = start + std::chrono::milliseconds(timeout);
+
+  if (!isValidDeviceNode(device_node)) {
+    return -EINVAL;
+  }
+
+  auto cmd = isValidCommand(cmd_code);
+  if (cmd == commandCodeTable.end()) {
+    return -EINVAL;
+  }
+
+  auto isSet = isSetCommand(cmd);
+  if (isSet && (!input_buff || !input_size)) {
+    return -EINVAL;
+  }
+
+  auto isGet = isGetCommand(cmd);
+  if (isGet && (!output_buff || !output_size)) {
+    return -EINVAL;
+  }
+
+  if (!host_latency) {
+    return -EINVAL;
+  }
+
+  if (!dev_latency) {
+    return -EINVAL;
+  }
+
+  if (!devLayer_) {
+    return -EINVAL;
+  }
+
+  if (!isInputBufferValid(cmd_code, input_buff)) {
+    return -EINVAL;
+  }
+
+  auto inputSize = input_size;
+  auto lockable = getDeviceInstance(device_node);
+
+  std::future<std::vector<std::byte>> respReceiveFuture;
+  if (lockable->sqGuard.try_lock_for(end - std::chrono::steady_clock::now())) {
+    const std::lock_guard<std::timed_mutex> lock(lockable->sqGuard, std::adopt_lock_t());
+
+    auto wCB = std::make_unique<dm_cmd>();
+    wCB->info.cmd_hdr.tag_id = tag_id_++;
+    wCB->info.cmd_hdr.msg_id = cmd_code;
+    wCB->payload = std::make_unique<char[]>(inputSize);
+
+    switch (cmd_code) {
+    case device_mgmt_api::DM_CMD::DM_CMD_SET_FIRMWARE_UPDATE: {
+      wCB->info.cmd_hdr.size = sizeof(wCB->info);
+      DV_LOG(DEBUG) << "Size: " << std::dec << wCB->info.cmd_hdr.size;
+      int res = updateFirmwareImage(lockable, input_buff);
+
+      if (res != 0) {
+        DV_LOG(INFO) << "failed to write firmware image to device DRAM";
+        return res;
+      }
+    } break;
+    case device_mgmt_api::DM_CMD::DM_CMD_SET_SP_BOOT_ROOT_CERT:
+    case device_mgmt_api::DM_CMD::DM_CMD_SET_SW_BOOT_ROOT_CERT: {
+      std::vector<unsigned char> hash;
+
+      int res = processHashFile(input_buff, hash);
+
+      if (res != 0) {
+        DV_LOG(INFO) << "process hash file error ";
+        return res;
+      }
+      inputSize = hash.size();
+      if (sizeof(wCB->payload) < inputSize) {
+        DV_LOG(INFO) << "not enough space in cmd payload ";
+        return -EAGAIN;
+      }
+      auto tmp = reinterpret_cast<char*>(hash.data());
+      DV_LOG(INFO) << "Mem copy ";
+      memcpy(wCB->payload.get(), input_buff, inputSize);
+      DV_LOG(INFO) << "Size: " << inputSize;
+      wCB->info.cmd_hdr.size = sizeof(wCB->info) + inputSize;
+      DV_LOG(INFO) << "input_buff: " << tmp;
+    } break;
+    case device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_RESIDENCY_THROTTLE_STATES:
+    case device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_RESIDENCY_POWER_STATES:
+    case device_mgmt_api::DM_CMD::DM_CMD_SET_DM_TRACE_RUN_CONTROL:
+    case device_mgmt_api::DM_CMD::DM_CMD_SET_DM_TRACE_CONFIG:
+    case device_mgmt_api::DM_CMD::DM_CMD_MDI_SELECT_HART:
+    case device_mgmt_api::DM_CMD::DM_CMD_MDI_UNSELECT_HART:
+    case device_mgmt_api::DM_CMD::DM_CMD_MDI_RESET_HART:
+    case device_mgmt_api::DM_CMD::DM_CMD_MDI_HALT_HART:
+    case device_mgmt_api::DM_CMD::DM_CMD_MDI_RESUME_HART:
+    case device_mgmt_api::DM_CMD::DM_CMD_MDI_GET_HART_STATUS:
+    case device_mgmt_api::DM_CMD::DM_CMD_MDI_SET_BREAKPOINT:
+    case device_mgmt_api::DM_CMD::DM_CMD_MDI_UNSET_BREAKPOINT:
+    case device_mgmt_api::DM_CMD::DM_CMD_MDI_ENABLE_SINGLE_STEP:
+    case device_mgmt_api::DM_CMD::DM_CMD_MDI_DISABLE_SINGLE_STEP:
+    case device_mgmt_api::DM_CMD::DM_CMD_MDI_READ_GPR:
+    case device_mgmt_api::DM_CMD::DM_CMD_MDI_DUMP_GPR:
+    case device_mgmt_api::DM_CMD::DM_CMD_MDI_WRITE_GPR:
+    case device_mgmt_api::DM_CMD::DM_CMD_MDI_READ_CSR:
+    case device_mgmt_api::DM_CMD::DM_CMD_MDI_WRITE_CSR:
+    case device_mgmt_api::DM_CMD::DM_CMD_MDI_READ_MEM:
+    case device_mgmt_api::DM_CMD::DM_CMD_MDI_WRITE_MEM: {
+      memcpy(wCB->payload.get(), input_buff, inputSize);
+      wCB->info.cmd_hdr.size = sizeof(wCB->info) + inputSize;
+      break;
+    }
+    default: {
+      if (isSet && input_buff && inputSize) {
+        memcpy(wCB->payload.get(), input_buff, inputSize);
+      }
+      wCB->info.cmd_hdr.size = sizeof(wCB->info) + inputSize;
+    } break;
+    }
+    CmdFlagSP flags;
+    if (cmd_code == device_mgmt_api::DM_CMD::DM_CMD_MM_RESET) {
+      flags.isMmReset_ = true;
+    } else if (cmd_code == device_mgmt_api::DM_CMD::DM_CMD_RESET_ETSOC) {
+      flags.isEtsocReset_ = true;
+    }
+    // There will be no response for ETSOC Reset, so do not add response placeholder and stop device functionality
+    if (flags.isEtsocReset_) {
+      destroyDeviceInstance(lockable->idx, true);
+    } else {
+      respReceiveFuture = lockable->getRespReceiveFuture(wCB->info.cmd_hdr.tag_id);
+    }
+    size_t totalSize = sizeof(wCB->info) + input_size;
+    auto buffer = std::make_unique<std::byte[]>(totalSize);
+    memcpy(buffer.get(), &(wCB->info), sizeof(wCB->info));
+    memcpy(buffer.get() + sizeof(wCB->info), wCB->payload.get(), input_size);
+    try {
+      if (!devLayer_->sendCommandServiceProcessor(lockable->idx, buffer.get(), wCB->info.cmd_hdr.size, flags)) {
+        if (flags.isEtsocReset_) {
+          createDeviceInstance(lockable->idx);
+        }
+
+        return -EIO;
+      }
+    } catch (const dev::Exception& ex) {
+      auto eptr = std::make_exception_ptr(ex);
+      std::rethrow_exception(eptr);
+    }
+    DV_DLOG(DEBUG) << "Sent cmd: " << wCB->info.cmd_hdr.msg_id << " with header size: " << wCB->info.cmd_hdr.size
+                   << std::endl;
+
+    if (flags.isEtsocReset_) {
+      devLayer_->reinitDeviceInstance(
+        lockable->idx, false,
+        std::chrono::duration_cast<std::chrono::milliseconds>(end - std::chrono::steady_clock::now()));
+      createDeviceInstance(lockable->idx);
+      return 0;
+    }
+    if (auto status = respReceiveFuture.wait_for(end - std::chrono::steady_clock::now());
+        status != std::future_status::ready) {
+      return -EAGAIN;
+    }
+
+    auto message = respReceiveFuture.get();
+    auto rCB = reinterpret_cast<dm_rsp*>(message.data());
+    DV_DLOG(DEBUG) << "Read rsp to cmd: " << rCB->info.rsp_hdr.msg_id << " with header size: " << rCB->info.rsp_hdr.size
+                   << std::endl;
+
+    if (output_buff && output_size) {
+      memcpy(output_buff, rCB->payload, output_size);
+    }
+    auto status = rCB->info.rsp_hdr_ext.status;
+    if (status) {
+      DV_LOG(INFO) << "Received incorrect rsp status: " << rCB->info.rsp_hdr_ext.status << std::endl;
+      return -EIO;
+    }
+
+    *dev_latency = rCB->info.rsp_hdr_ext.device_latency_usec;
+    *host_latency =
+      std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - start).count();
+
+    return 0;
+  }
+
+  return -EAGAIN;
+}
+
+extern "C" DeviceManagement& getInstance(IDeviceLayer* devLayer) {
+  return DeviceManagement::getInstance(devLayer);
+}
+
+} // namespace device_management
diff --git a/device-management/src/Schema/DeviceManagement-spec.schema.json b/device-management/src/Schema/DeviceManagement-spec.schema.json
new file mode 100644
index 00000000..ed5c87a9
--- /dev/null
+++ b/device-management/src/Schema/DeviceManagement-spec.schema.json
@@ -0,0 +1,594 @@
+{
+	"enum": {
+		"DM_CMD": [
+
+			"======Comment:Asset tracking=====",
+
+			"DM_CMD_GET_MODULE_MANUFACTURE_NAME",
+			"DM_CMD_GET_MODULE_PART_NUMBER",
+			"DM_CMD_GET_MODULE_SERIAL_NUMBER",
+			"DM_CMD_GET_ASIC_CHIP_REVISION",
+			"DM_CMD_GET_MODULE_FIRMWARE_REVISIONS",
+			"DM_CMD_GET_MODULE_PCIE_ADDR",
+			"DM_CMD_GET_MODULE_PCIE_NUM_PORTS_MAX_SPEED",
+			"DM_CMD_GET_MODULE_MEMORY_SIZE_MB",
+			"DM_CMD_GET_MODULE_REVISION",
+			"DM_CMD_GET_MODULE_FORM_FACTOR",
+			"DM_CMD_GET_MODULE_MEMORY_VENDOR_PART_NUMBER",
+			"DM_CMD_GET_MODULE_MEMORY_TYPE",
+			"DM_CMD_GET_FUSED_PUBLIC_KEYS",
+
+			"======Comment:Firmware Management =====",
+
+			"DM_CMD_SET_FIRMWARE_UPDATE",
+			"DM_CMD_GET_FIRMWARE_BOOT_STATUS",
+			"DM_CMD_SET_FIRMWARE_VERSION_COUNTER",
+			"DM_CMD_SET_FIRMWARE_VALID",
+			"DM_CMD_SET_SP_BOOT_ROOT_CERT",
+			"DM_CMD_SET_SW_BOOT_ROOT_CERT",
+
+			"======Comment: Health Management (Thermal and Power) =====",
+
+			"DM_CMD_GET_MODULE_TEMPERATURE_THRESHOLDS",
+			"DM_CMD_SET_MODULE_TEMPERATURE_THRESHOLDS",
+			"DM_CMD_GET_MODULE_POWER_STATE",
+			"DM_CMD_SET_MODULE_ACTIVE_POWER_MANAGEMENT",
+			"DM_CMD_GET_MODULE_STATIC_TDP_LEVEL",
+			"DM_CMD_SET_MODULE_STATIC_TDP_LEVEL",
+			"DM_CMD_GET_MODULE_CURRENT_TEMPERATURE",
+			"DM_CMD_GET_MODULE_RESIDENCY_THROTTLE_STATES",
+			"DM_CMD_GET_MODULE_RESIDENCY_POWER_STATES",
+			"DM_CMD_GET_MODULE_UPTIME",
+			"DM_CMD_GET_MODULE_VOLTAGE",
+			"DM_CMD_GET_MODULE_POWER",
+
+			"======Comment: Historical extreme values =====",
+
+			"DM_CMD_GET_MODULE_MAX_TEMPERATURE",
+			"DM_CMD_GET_MODULE_MAX_DDR_BW",
+			"DM_CMD_GET_MAX_MEMORY_ERROR",
+
+			"======Comment: Error Control =====",
+
+			"DM_CMD_SET_DDR_ECC_COUNT",
+			"DM_CMD_SET_PCIE_ECC_COUNT",
+			"DM_CMD_SET_SRAM_ECC_COUNT",
+
+
+			"======Comment: Link Management =====",
+
+			"DM_CMD_SET_PCIE_RESET",
+			"DM_CMD_GET_MODULE_PCIE_ECC_UECC",
+			"DM_CMD_GET_MODULE_DDR_BW_COUNTER",
+			"DM_CMD_GET_MODULE_DDR_ECC_UECC",
+			"DM_CMD_GET_MODULE_SRAM_ECC_UECC",
+			"DM_CMD_SET_PCIE_MAX_LINK_SPEED",
+			"DM_CMD_SET_PCIE_LANE_WIDTH",
+			"DM_CMD_SET_PCIE_RETRAIN_PHY",
+
+
+			"======Comment: Performance =====",
+
+			"DM_CMD_GET_ASIC_FREQUENCIES",
+			"DM_CMD_GET_DRAM_BANDWIDTH",
+			"DM_CMD_GET_DRAM_CAPACITY_UTILIZATION",
+			"DM_CMD_GET_ASIC_PER_CORE_DATAPATH_UTILIZATION",
+			"DM_CMD_GET_ASIC_UTILIZATION",
+			"DM_CMD_GET_ASIC_STALLS",
+			"DM_CMD_GET_ASIC_LATENCY",
+
+			"======Comment: Master Minion State =====",
+			"DM_CMD_GET_MM_ERROR_COUNT"
+		],
+
+		"FIRMWARE_STATUS": ["FIRMWARE_STATUS_PASS", "FIRMWARE_STATUS_FAILED"],
+		"DM_STATUS": ["DM_STATUS_SUCCESS", "DM_STATUS_ERROR"],
+		"POWER_STATE": ["POWER_STATE_MAX_POWER", "POWER_STATE_MANAGED_POWER", "POWER_STATE_SAFE_POWER", "POWER_STATE_LOW_POWER", "POWER_STATE_INVALID"],
+		"ACTIVE_POWER_MANAGEMENT": ["ACTIVE_POWER_MANAGEMENT_TURN_OFF", "ACTIVE_POWER_MANAGEMENT_TURN_ON", "ACTIVE_POWER_MANAGEMENT_INVALID"],
+		"POWER_THROTTLE_STATE": ["POWER_THROTTLE_STATE_POWER_IDLE", "POWER_THROTTLE_STATE_THERMAL_IDLE", "POWER_THROTTLE_STATE_POWER_UP", "POWER_THROTTLE_STATE_POWER_DOWN", "POWER_THROTTLE_STATE_THERMAL_DOWN", "POWER_THROTTLE_STATE_POWER_SAFE", "POWER_THROTTLE_STATE_THERMAL_SAFE"],
+		"PCIE_RESET": ["PCIE_RESET_FLR", "PCIE_RESET_HOT", "PCIE_RESET_WARM"],
+		"PCIE_LINK_SPEED": ["PCIE_LINK_SPEED_GEN3", "PCIE_LINK_SPEED_GEN4"],
+		"PCIE_LANE_W_SPLIT": ["PCIE_LANE_W_SPLIT_x4", "PCIE_LANE_W_SPLIT_x8"]
+	},
+
+	"cmd_param_structs": {
+
+		"asset_tracking_class": {
+
+			"asset_tracking": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": null,
+					"output_buff": ["DM_CMD_GET_MODULE_MANUFACTURE_NAME",
+									"DM_CMD_GET_MODULE_PART_NUMBER",
+									"DM_CMD_GET_MODULE_SERIAL_NUMBER",
+									"DM_CMD_GET_ASIC_CHIP_REVISION",
+									"DM_CMD_GET_MODULE_PCIE_ADDR",
+									"DM_CMD_GET_MODULE_PCIE_NUM_PORTS_MAX_SPEED",
+									"DM_CMD_GET_MODULE_MEMORY_SIZE_MB",
+									"DM_CMD_GET_MODULE_REVISION",
+									"DM_CMD_GET_MODULE_FORM_FACTOR",
+									"DM_CMD_GET_MODULE_MEMORY_VENDOR_PART_NUMBER",
+									"DM_CMD_GET_MODULE_MEMORY_TYPE"
+									]
+				},
+
+				"fields": {
+					"asset[24]": "char "
+				}
+			},
+
+			"fused_public_key": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": null,
+					"output_buff": ["DM_CMD_GET_FUSED_PUBLIC_KEYS"]
+				},
+
+				"fields": {
+					"key_size_tbd[32]": "uint8_t"
+				}
+			},
+
+			"firmware_version": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": null,
+					"output_buff": "DM_CMD_GET_MODULE_FIRMWARE_REVISIONS"
+				},
+				"fields": {
+					"bl1_v": "uint32_t",
+					"bl2_v": "uint32_t",
+					"mm_v": "uint32_t",
+					"wm_v": "uint32_t",
+					"machm_v": "uint32_t",
+					"fw_release_rev": "uint32_t"
+				}
+			}
+		},
+
+		"firmware_mgmt_class": {
+
+			"update_firmware": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types. Image format is TBD",
+					"input_buff": "DM_CMD_SET_FIRMWARE_UPDATE",
+					"output_buff": null
+				},
+				"fields": {
+					"fw_image_path[64]": "char "
+				}
+			},
+
+			"certificate_hash": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": "DM_CMD_SET_SP_BOOT_ROOT_CERT",
+					"output_buff": null
+				},
+				"fields": {
+					"hash_size_tbd[32]": "uint8_t"
+				}
+			}
+		},
+
+		"thermal_power_mgmt_class": {
+
+			"temperature_threshold": {
+
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": "DM_CMD_SET_MODULE_TEMPERATURE_THRESHOLDS",
+					"output_buff": "DM_CMD_GET_MODULE_TEMPERATURE_THRESHOLDS"
+				},
+
+				"fields": {
+					"sw_temperature_c": "int32_t"
+				},
+
+				"default_temp_threshold" : {
+					"sw_temp_c" : 70
+				}
+			},
+
+			"power_state": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": null,
+					"output_buff": "DM_CMD_GET_MODULE_POWER_STATE"
+				},
+
+				"fields": {
+					"state": "enum POWER_STATE"
+				},
+
+				"default_power_state" : "POWER_STATE_LOW_POWER"
+			},
+
+			"active_power_management": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": "DM_CMD_SET_MODULE_ACTIVE_POWER_MANAGEMENT",
+					"output_buff": null
+				},
+
+				"fields": {
+					"state": "enum ACTIVE_POWER_MANAGEMENT"
+				},
+
+				"default_power_state" : "ACTIVE_POWER_MANAGEMENT_TURN_OFF"
+			},
+
+			"power_throttle_state": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": "DM_CMD_GET_MODULE_RESIDENCY_THROTTLE_STATES",
+					"output_buff": null
+				},
+
+				"fields": {
+					"tdp": "enum POWER_THROTTLE_STATE"
+				},
+
+				"default_power_throttle_state" : "POWER_THROTTLE_STATE_POWER_IDLE"
+			},
+
+			"current_temperature": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": null,
+					"output_buff": "DM_CMD_GET_MODULE_CURRENT_TEMPERATURE"
+				},
+
+				"fields": {
+					"temperature_c": "int32_t"
+				}
+			},
+
+			"throttle_residency": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": null,
+					"output_buff": "DM_CMD_GET_MODULE_RESIDENCY_THROTTLE_STATES"
+				},
+
+				"fields": {
+					"cumulative": "uint64_t",
+					"average": "uint64_t",
+					"maximum": "uint64_t",
+					"minimum": "uint64_t"
+				}
+			},
+
+			"power_residency": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": null,
+					"output_buff": "DM_CMD_GET_MODULE_RESIDENCY_POWER_STATES"
+				},
+				"fields": {
+					"cumulative": "uint64_t",
+					"average": "uint64_t",
+					"maximum": "uint64_t",
+					"minimum": "uint64_t"
+				}
+			},
+
+			"module_power": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": null,
+					"output_buff": "DM_CMD_GET_MODULE_POWER"
+				},
+				"fields": {
+					"watts": "uint32_t"
+				}
+			},
+
+			"module_voltage": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": null,
+					"output_buff": "DM_CMD_GET_MODULE_VOLTAGE"
+				},
+				"fields": {
+					"ddr" : "uint8_t",
+					"l2_cache" : "uint8_t",
+					"maxion" : "uint8_t",
+					"minion" : "uint8_t",
+					"pcie" : "uint8_t",
+					"noc" : "uint8_t",
+					"pcie_logic" : "uint8_t",
+					"vddqlp" : "uint8_t",
+					"vddq" : "uint8_t"
+				}
+			},
+
+			"module_uptime": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": null,
+					"output_buff": "DM_CMD_GET_MODULE_UPTIME"
+				},
+				"fields": {
+					"time_day": "uint16_t",
+					"time_hours": "uint8_t",
+					"time_seconds": "uint8_t"
+				}
+			}
+
+		},
+
+		"max_historical_values_class": {
+
+			"max_temperature": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": null,
+					"output_buff": "DM_CMD_GET_MODULE_MAX_TEMPERATURE"
+				},
+				"fields": {
+					"max_temperature_c": "int32_t"
+				}
+			},
+
+			"max_memory_error": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": null,
+					"output_buff": "DM_CMD_GET_MAX_MEMORY_ERROR"
+				},
+
+				"fields": {
+					"max_ecc_count": "uint32_t"
+				}
+			},
+
+			"max_dram_bw": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": null,
+					"output_buff": "DM_CMD_GET_MODULE_MAX_DDR_BW"
+				},
+				"fields": {
+					"max_bw_rd_req_sec": "uint32_t",
+					"max_bw_wr_req_sec": "uint32_t"
+				}
+			}
+		},
+
+		"error_control_class": {
+
+			"set_error_count": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": ["DM_CMD_SET_DDR_ECC_COUNT", "DM_CMD_SET_SRAM_ECC_COUNT ", "DM_CMD_SET_PCIE_ECC_COUNT"],
+					"output_buff": null
+				},
+				"fields": {
+					"ecc_error_count": "uint32_t"
+				},
+
+				"default_error_threshold" : 10
+			}
+		},
+
+
+		"link_mgmt_class": {
+
+			"pcie_reset": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": "DM_CMD_SET_PCIE_RESET",
+					"output_buff": null
+				},
+				"fields": {
+					"reset_type": "enum PCIE_RESET"
+				}
+			},
+
+			"get_error_count": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": null,
+					"output_buff": ["DM_CMD_GET_MODULE_PCIE_ECC_UECC", "DM_CMD_GET_MODULE_DDR_ECC_UECC", "DM_CMD_GET_MODULE_SRAM_ECC_UECC"]
+				},
+				"fields": {
+					"ecc_count": "uint32_t",
+					"uecc_count": "uint32_t"
+				}
+			},
+
+			"dram_bw_counter": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": null,
+					"output_buff": "DM_CMD_GET_MODULE_DDR_BW_COUNTER"
+				},
+				"fields": {
+					"read_req_per_sec": "uint32_t",
+					"write_req_per_sec": "uint32_t"
+				}
+			},
+
+			"pcie_link_speed": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": "DM_CMD_SET_PCIE_MAX_LINK_SPEED",
+					"output_buff": null
+				},
+				"fields": {
+					"speed": "enum PCIE_LINK_SPEED"
+				},
+
+				"default_link_speed" : "PCIE_LINK_SPEED_GEN3"
+			},
+
+			"pcie_lane_width": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": "DM_CMD_SET_PCIE_LANE_WIDTH",
+					"output_buff": null
+				},
+				"fields": {
+					"width": "enum PCIE_LANE_W_SPLIT"
+				}
+			},
+
+			"pcie_retrain_phy": {
+				"usage": {
+					"desc": "No struct is requried, request is handled based on the command id",
+					"input_buff": "null",
+					"output_buff": "null"
+				}
+			},
+
+			"etsoc_reset": {
+				"usage": {
+					"desc": "No struct is requried, request is handled based on the command id",
+					"input_buff": "null",
+					"output_buff": "null"
+				}
+			}
+		},
+
+		"performance_class": {
+			"asic_frequencies": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": null,
+					"output_buff": "DM_CMD_GET_ASIC_FREQUENCIES"
+				},
+				"fields": {
+					"minion_shire_mhz": "uint8_t",
+					"noc_mhz": "uint8_t",
+					"mem_shire_mhz": "uint8_t",
+					"dram_mhz": "uint8_t",
+					"p_shire_mhz": "uint8_t",
+					"io_shire_mhz": "uint8_t"
+				},
+
+				"default_freqs" : {
+					"minion_shire": 800,
+					"noc": 400,
+					"mem_shire":1067,
+					"dram": 1067,
+					"p_shire": 1010,
+					"io_shire": 500
+				}
+			},
+			"dram_bw": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": null,
+					"output_buff": "DM_CMD_GET_DRAM_BANDWIDTH"
+				},
+				"fields": {
+					"read_req_sec": "uint32_t",
+					"write_req_sec": "uint32_t"
+				}
+			},
+
+			"dram_capacity": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": null,
+					"output_buff": "DM_CMD_GET_DRAM_CAPACITY_UTILIZATION"
+				},
+				"fields": {
+					"percentage_cap": "uint32_t"
+				}
+			},
+
+			"asic_per_core_util": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": null,
+					"output_buff": "DM_CMD_GET_ASIC_PER_CORE_DATAPATH_UTILIZATION"
+				},
+				"fields": {
+					"TBD": "TBD"
+				}
+			},
+
+			"asic_util": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": null,
+					"output_buff": "DM_CMD_GET_ASIC_UTILIZATION"
+				},
+				"fields": {
+					"TBD": "TBD"
+				}
+			},
+
+			"asic_stalls": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": null,
+					"output_buff": "DM_CMD_GET_ASIC_STALLS"
+				},
+				"fields": {
+					"TBD": "TBD"
+				}
+			},
+
+			"asic_latency": {
+				"usage": {
+					"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+					"input_buff": null,
+					"output_buff": "DM_CMD_GET_ASIC_LATENCY"
+				},
+				"fields": {
+					"TBD": "TBD"
+				}
+			}
+		},
+
+		"mm_error_count": {
+			"usage": {
+				"desc": "struct is used in the input_buff/output_buff arguments of serviceRequest API for following request types",
+				"input_buff": null,
+				"output_buff": "DM_CMD_GET_MM_ERROR_COUNT"
+			},
+			"fields": {
+				"hang_count": "uint32_t",
+				"exception_count": "uint32_t"
+			}
+		}
+	},
+
+	"APIs": {
+
+		"getInstance": {
+			"revision": "1.0.0",
+			"name": "DM Instance",
+			"short_desc": "Gets the DM Instance",
+			"desc": "Gets the Device Management Instance",
+			"return type": "DeviceManagement &",
+			"access_method": "Library call",
+			"symbol_name": "getInstance"
+		},
+
+		"serviceRequest": {
+			"revision": "1.0.0",
+			"short_desc": "Generic API for DM services",
+			"desc": "Generic API to request various DM services",
+			"access_method": "Instance call",
+			"symbol_name": "serviceRequest",
+			"return type": "int32_t",
+			"valid_range": "enum DM_STATUS",
+			"parameters": {
+				"device_node": "const uint32_t",
+				"cmd_id": "const uint32_t",
+				"input_buff": "const char *",
+				"input_size": "const uint32_t",
+				"output_buff": "char *",
+				"output_size": "const uint32_t",
+				"host_latency_usec": "uint64_t *",
+				"device_latency_usec": "uint64_t *",
+				"timeout_msec": "const uint32_t"
+			}
+		}
+	}
+}
diff --git a/device-management/src/utils.h b/device-management/src/utils.h
new file mode 100644
index 00000000..c000bcd4
--- /dev/null
+++ b/device-management/src/utils.h
@@ -0,0 +1,16 @@
+/*-------------------------------------------------------------------------
+ * Copyright (C) 2020, Esperanto Technologies Inc.
+ * The copyright to the computer program(s) herein is the
+ * property of Esperanto Technologies, Inc. All Rights Reserved.
+ * The program(s) may be used and/or copied only with
+ * the written permission of Esperanto Technologies and
+ * in accordance with the terms and conditions stipulated in the
+ * agreement/contract under which the program(s) have been supplied.
+ *-------------------------------------------------------------------------*/
+
+#pragma once
+#include <hostUtils/logging/Logging.h>
+
+#define DV_LOG(severity) ET_LOG(DM, severity)
+#define DV_DLOG(severity) ET_DLOG(DM, severity)
+#define DV_VLOG(level) ET_VLOG(DM, level)
diff --git a/device-management/test_package/CMakeLists.txt b/device-management/test_package/CMakeLists.txt
new file mode 100644
index 00000000..3268a0d9
--- /dev/null
+++ b/device-management/test_package/CMakeLists.txt
@@ -0,0 +1,13 @@
+cmake_minimum_required(VERSION 3.8)
+project(test_package)
+
+set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
+set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
+set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
+
+set(CMAKE_VERBOSE_MAKEFILE TRUE)
+find_package(deviceManagement REQUIRED)
+
+add_executable(${PROJECT_NAME} test_package.cpp)
+target_compile_features(${PROJECT_NAME} PRIVATE cxx_std_17)
+target_link_libraries(${PROJECT_NAME} PRIVATE deviceManagement::DM)
diff --git a/device-management/test_package/conanfile.py b/device-management/test_package/conanfile.py
new file mode 100644
index 00000000..27a7200a
--- /dev/null
+++ b/device-management/test_package/conanfile.py
@@ -0,0 +1,21 @@
+from conan import ConanFile
+from conan.tools.cmake import CMake
+from conans import tools
+import os
+
+class DeviceManagementTest(ConanFile):
+    settings = "os", "compiler", "build_type", "arch"
+    generators = "CMakeToolchain", "CMakeDeps"
+
+    def build(self):
+        cmake = CMake(self)
+        cmake.configure()
+        cmake.build()
+
+    def test(self):
+        if not tools.cross_building(self.settings):
+            test_library = os.path.join("bin", "test_package")
+
+            for test in [test_library]:
+                self.output.info(f"Running -> {test}")
+                self.run(test, run_environment=True)
\ No newline at end of file
diff --git a/device-management/test_package/test_package.cpp b/device-management/test_package/test_package.cpp
new file mode 100644
index 00000000..fb720055
--- /dev/null
+++ b/device-management/test_package/test_package.cpp
@@ -0,0 +1,7 @@
+#include <deviceManagement/DeviceManagement.h>
+
+#include <iostream>
+
+int main() {
+    std::cout << "SUCCESS" << std::endl;
+}
\ No newline at end of file
diff --git a/device-management/tests/Autogen.h.in b/device-management/tests/Autogen.h.in
new file mode 100644
index 00000000..c8642a68
--- /dev/null
+++ b/device-management/tests/Autogen.h.in
@@ -0,0 +1,19 @@
+//******************************************************************************
+// Copyright (C) 2021, Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#ifndef AUTOGEN_H_
+#define AUTOGEN_H_
+
+static constexpr const char* FLASH_IMG_PATH = "@FLASH_IMG_PATH@";
+static constexpr const char* FLASH_TOOL_PATH = "@FLASH_TOOL@";
+static constexpr const char* DEVICE_SIGNED_ARTIFACTS_PATH = "@DEVICE_SIGNED_ARTIFACTS_DIR@";
+static constexpr const char* FLASH_32MBIT_TEMPLATE_PATH = "@FLASH_32MBIT_TEMPLATE@";
+
+#endif // AUTOGEN_H_
diff --git a/device-management/tests/CMakeLists.txt b/device-management/tests/CMakeLists.txt
new file mode 100644
index 00000000..6ff64d8b
--- /dev/null
+++ b/device-management/tests/CMakeLists.txt
@@ -0,0 +1,315 @@
+#------------------------------------------------------------------------------
+# Copyright (C) 2020, Esperanto Technologies Inc.
+# The copyright to the computer program(s) herein is the
+# property of Esperanto Technologies, Inc. All Rights Reserved.
+# The program(s) may be used and/or copied only with
+# the written permission of Esperanto Technologies and
+# in accordance with the terms and conditions stipulated in the
+# agreement/contract under which the program(s) have been supplied.
+#------------------------------------------------------------------------------
+
+
+include(ExternalProject)
+include(GoogleTest)
+
+enable_testing()
+
+find_package(deviceLayer REQUIRED)
+find_package(fmt REQUIRED)
+find_package(GTest REQUIRED)
+find_package(gflags REQUIRED)
+find_package(glog REQUIRED)
+find_package(Threads REQUIRED)
+find_package(EsperantoDeviceMinionRuntime REQUIRED)
+find_package(EsperantoBootLoader REQUIRED)
+find_package(esperantoTrace REQUIRED)
+
+get_property(BOOTROM_TRAMPOLINE_TO_BL2_ELF TARGET EsperantoBootLoader::BootromTrampolineToBL2.elf PROPERTY LOCATION)
+get_property(BL2_ELF TARGET EsperantoBootLoader::ServiceProcessorBL2_fast-boot.elf PROPERTY LOCATION)
+get_property(BL2_ELF_TF TARGET EsperantoBootLoader::ServiceProcessorBL2_testframework.elf PROPERTY LOCATION)
+get_property(MASTER_MINION_ELF TARGET EsperantoDeviceMinionRuntime::MasterMinion.elf PROPERTY LOCATION)
+get_property(MASTER_MINION_ELF_TF TARGET EsperantoDeviceMinionRuntime::MasterMinionTF.elf PROPERTY LOCATION)
+get_property(MACHINE_MINION_ELF TARGET EsperantoDeviceMinionRuntime::MachineMinion.elf PROPERTY LOCATION)
+get_property(WORKER_MINION_ELF TARGET EsperantoDeviceMinionRuntime::WorkerMinion.elf PROPERTY LOCATION)
+
+# This will be used by test case to verify f/w update support as this is CMakeLists for DM tests.
+# End user can use f/w image of choice by passing it as argument to dev_mngt_service.
+set(FLASH_IMG_PATH "${FLASH_INSTALL_DIR}/dev-image/production-signed-with-test-keys-pcie-phy-fw-override/flash_32Mbit.bin")
+set(FLASH_TOOL ${CMAKE_INSTALL_PREFIX}/bin/esperanto_flash_tool)
+set(DEVICE_SIGNED_ARTIFACTS_DIR ${CMAKE_INSTALL_PREFIX}/lib/esperanto-fw/device-artifacts/signed-artifacts/test-key-artifacts)
+set(FLASH_32MBIT_TEMPLATE ${ROOT_BINARY_DIR}/device-software/device-artifacts/flash-image/src/device-artifacts-flash-image-build/dev-image/production-signed-with-test-keys-pcie-phy-fw-override/flash_32Mbit_template.json)
+
+option(ENABLE_SANITIZER_ADDRESS "" OFF)
+option(ENABLE_SANITIZER_LEAK "" OFF)
+option(ENABLE_SANITIZER_UNDEFINED_BEHAVIOR "" OFF)
+option(ENABLE_SANITIZER_THREAD "" OFF)
+option(ENABLE_SANITIZER_MEMORY "" OFF)
+include(CompilerSanitizers)
+
+include_directories(${CMAKE_CURRENT_BINARY_DIR})
+configure_file(Autogen.h.in Autogen.h)
+
+install(FILES
+    ${CMAKE_CURRENT_BINARY_DIR}/Autogen.h
+    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/device-management
+)
+
+add_library(DMTests
+    DevErrorEvent.cpp
+    TestDevMgmtApiSyncCmds.cpp
+)
+
+target_compile_features(DMTests PRIVATE cxx_std_17)
+target_include_directories(DMTests
+    PUBLIC
+        $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/src>
+        ${CMAKE_CURRENT_SOURCE_DIR}
+)
+target_link_libraries(DMTests
+    PUBLIC
+        deviceManagement::DM
+        deviceLayer::deviceLayer
+        fmt::fmt
+        GTest::GTest
+        GTest::Main
+        gflags::gflags
+        ${CMAKE_DL_LIBS}
+)
+
+# Helper to create tests
+function(create_test)
+    cmake_parse_arguments(TEST
+        ""
+        "TARGET"
+        "SOURCES;ARGS;PROPERTIES"
+        ${ARGN}
+    )
+
+    add_executable(${TEST_TARGET} ${TEST_SOURCES})
+    target_compile_features(${TEST_TARGET} PRIVATE cxx_std_17)
+    target_link_libraries(${TEST_TARGET} PRIVATE DMTests)
+    target_add_sanitizers(${TEST_TARGET})
+
+    # set internal execution timeout value relative to actual timeout. Internal timeout
+    # is smaller for wraping up the execution and printing the test summary
+    string(REGEX MATCH "[T][I][M][E][O][U][T][0-9]*" TIMEOUT_ENTRY ${TEST_PROPERTIES})
+    string(REGEX REPLACE "[T][I][M][E][O][U][T]" "" TIMEOUT_VAL ${TIMEOUT_ENTRY})
+    if(TIMEOUT_VAL STREQUAL "")
+        # default timeout value
+        set(TIMEOUT_VAL "60")
+    endif()
+    set(WRAP_UP_TIME "15")
+    MATH(EXPR EXEC_TIMEOUT_MS "(${TIMEOUT_VAL}-${WRAP_UP_TIME})*1000")
+    set(TEST_ARGS ${TEST_ARGS} --exec_timeout_ms=${EXEC_TIMEOUT_MS})
+
+    gtest_discover_tests(${TEST_TARGET}
+        EXTRA_ARGS ${TEST_ARGS}
+        TEST_PREFIX deviceManagement:
+        PROPERTIES ${TEST_PROPERTIES}
+        TEST_LIST DISCOVERED_TESTS
+    )
+endfunction()
+
+# All tests should be created using the helper
+
+####################
+# FUNCTIONAL TESTS #
+####################
+create_test(
+    TARGET	FunctionalTestDevMgmtApiAssetTrackingCmds
+    SOURCES	functional/FunctionalTestDevMgmtApiAssetTrackingCmds.cpp
+    ARGS	""
+    PROPERTIES	"LABELS;FUNCTIONAL;TIMEOUT;60"
+)
+
+create_test(
+    TARGET      FunctionalTestDevMgmtApiThermalAndPowerMonitoringCmds
+    SOURCES     functional/FunctionalTestDevMgmtApiThermalAndPowerMonitoringCmds.cpp
+    ARGS        ""
+    PROPERTIES  "LABELS;FUNCTIONAL;TIMEOUT;60"
+)
+
+create_test(
+    TARGET      FunctionalTestDevMgmtApiHistoricalExtremeValCmds
+    SOURCES     functional/FunctionalTestDevMgmtApiHistoricalExtremeValCmds.cpp
+    ARGS        ""
+    PROPERTIES  "LABELS;FUNCTIONAL;TIMEOUT;60"
+)
+
+create_test(
+    TARGET      FunctionalTestDevMgmtApiErrorControlCmds
+    SOURCES     functional/FunctionalTestDevMgmtApiErrorControlCmds.cpp
+    ARGS        ""
+    PROPERTIES  "LABELS;FUNCTIONAL;TIMEOUT;60"
+)
+
+create_test(
+    TARGET      FunctionalTestDevMgmtApiLinkMgmtCmds
+    SOURCES     functional/FunctionalTestDevMgmtApiLinkMgmtCmds.cpp
+    ARGS        ""
+    PROPERTIES  "LABELS;FUNCTIONAL;TIMEOUT;60"
+)
+
+create_test(
+    TARGET      FunctionalTestDevMgmtApiPerfMgmtCmds
+    SOURCES     functional/FunctionalTestDevMgmtApiPerfMgmtCmds.cpp
+    ARGS        ""
+    PROPERTIES  "LABELS;FUNCTIONAL;TIMEOUT;60"
+)
+
+create_test(
+    TARGET      FunctionalTestDevMgmtApiFirmwareMgmtCmds
+    SOURCES     functional/FunctionalTestDevMgmtApiFirmwareMgmtCmds.cpp
+    ARGS        ""
+    PROPERTIES  "LABELS;FUNCTIONAL;TIMEOUT;540"
+)
+
+#####################
+# INTEGRATION TESTS #
+#####################
+create_test(
+    TARGET      IntegrationTestDevMgmtApiCmds
+    SOURCES     integration/IntegrationTestDevMgmtApiCmds.cpp
+    ARGS        ""
+    PROPERTIES  "LABELS;INTEGRATION;TIMEOUT;300"
+)
+
+create_test(
+    TARGET      IntegrationTestDevMgmtApiTraceCmds
+    SOURCES     integration/IntegrationTestDevMgmtApiTraceCmds.cpp
+    ARGS        ""
+    PROPERTIES  "LABELS;INTEGRATION;TIMEOUT;300"
+)
+
+create_test(
+    TARGET      IntegrationTestDevMgmtApiFirmwareMgmtCmds
+    SOURCES     integration/IntegrationTestDevMgmtApiFirmwareMgmtCmds.cpp
+    ARGS        ""
+    PROPERTIES  "LABELS;INTEGRATION;TIMEOUT;800"
+)
+
+#####################
+# MDI DEBUG TESTS #
+#####################
+create_test(
+    TARGET      RunControlApiTestcmds
+    SOURCES     mdi_debug/RunControlApiTestcmds.cpp
+    ARGS        ""
+    PROPERTIES  "LABELS;MDI;TIMEOUT;300"
+)
+
+create_test(
+    TARGET      StateInspectionApiTestcmds
+    SOURCES     mdi_debug/StateInspectionApiTestcmds.cpp
+    ARGS        ""
+    PROPERTIES  "LABELS;MDI;TIMEOUT;300"
+)
+
+##################
+# SECURITY TESTS #
+##################
+create_test(
+    TARGET      SecurityTestDevMgmtApiGenericCmds
+    SOURCES     security/SecurityTestDevMgmtApiGenericCmds.cpp
+    ARGS        ""
+    PROPERTIES  "LABELS;SECURITY;TIMEOUT;60"
+)
+
+create_test(
+    TARGET      SecurityTestDevMgmtApiAssetTrackingCmds
+    SOURCES     security/SecurityTestDevMgmtApiAssetTrackingCmds.cpp
+    ARGS        ""
+    PROPERTIES  "LABELS;SECURITY;TIMEOUT;60"
+)
+
+create_test(
+    TARGET      SecurityTestDevMgmtApiThermalAndPowerMonitoringCmds
+    SOURCES     security/SecurityTestDevMgmtApiThermalAndPowerMonitoringCmds.cpp
+    ARGS        ""
+    PROPERTIES  "LABELS;SECURITY;TIMEOUT;60"
+)
+
+create_test(
+    TARGET      SecurityTestDevMgmtApiHistoricalExtremeValCmds
+    SOURCES     security/SecurityTestDevMgmtApiHistoricalExtremeValCmds.cpp
+    ARGS        ""
+    PROPERTIES  "LABELS;SECURITY;TIMEOUT;60"
+)
+
+create_test(
+    TARGET      SecurityTestDevMgmtApiErrorControlCmds
+    SOURCES     security/SecurityTestDevMgmtApiErrorControlCmds.cpp
+    ARGS        ""
+    PROPERTIES  "LABELS;SECURITY;TIMEOUT;60"
+)
+
+create_test(
+    TARGET      SecurityTestDevMgmtApiLinkMgmtCmds
+    SOURCES     security/SecurityTestDevMgmtApiLinkMgmtCmds.cpp
+    ARGS        ""
+    PROPERTIES  "LABELS;SECURITY;TIMEOUT;60"
+)
+
+create_test(
+    TARGET      SecurityTestDevMgmtApiPerfMgmtCmds
+    SOURCES     security/SecurityTestDevMgmtApiPerfMgmtCmds.cpp
+    ARGS        ""
+    PROPERTIES  "LABELS;SECURITY;TIMEOUT;60"
+)
+
+create_test(
+    TARGET      OpsNodeDependentTestDevMgmtApiFirmwareMgmtCmds
+    SOURCES     opsNodeDependent/OpsNodeDependentTestDevMgmtApiFirmwareMgmtCmds.cpp
+    ARGS        ""
+    PROPERTIES  "LABELS;OPS_NODE_DEPENDENT;TIMEOUT;120"
+)
+
+create_test(
+    TARGET      OpsNodeDependentTestDevMgmtApiTraceCmds
+    SOURCES     opsNodeDependent/OpsNodeDependentTestDevMgmtApiTraceCmds.cpp
+    ARGS        ""
+    PROPERTIES  "LABELS;OPS_NODE_DEPENDENT;TIMEOUT;60"
+)
+
+################
+# STRESS TESTS #
+################
+create_test(
+    TARGET      StressTestDevMgmtApiFirmwareMgmtCmds
+    SOURCES     stress/StressTestDevMgmtApiFirmwareMgmtCmds.cpp
+    ARGS        ""
+    PROPERTIES  "LABELS;STRESS;TIMEOUT;1200"
+)
+
+configure_file(
+    mix/MixTestDevMgmtApiAllCmds.sh.in
+    ${CMAKE_CURRENT_BINARY_DIR}/MixTestDevMgmtApiAllCmds.sh @ONLY
+)
+
+add_test(
+    NAME              deviceManagement:MixTestDevMgmtApiAllCmds.randomizeTests
+    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
+    COMMAND           MixTestDevMgmtApiAllCmds.sh
+)
+
+set_tests_properties(${TEST_NAME}
+    PROPERTIES
+    DEPENDS           FunctionalTestDevMgmtApiAssetTrackingCmds
+    DEPENDS           FunctionalTestDevMgmtApiThermalAndPowerMonitoringCmds
+    DEPENDS           FunctionalTestDevMgmtApiHistoricalExtremeValCmds
+    DEPENDS           FunctionalTestDevMgmtApiErrorControlCmds
+    DEPENDS           FunctionalTestDevMgmtApiLinkMgmtCmds
+    DEPENDS           FunctionalTestDevMgmtApiPerfMgmtCmds
+    DEPENDS           FunctionalTestDevMgmtApiFirmwareMgmtCmds
+    DEPENDS           IntegrationTestDevMgmtApiCmds
+    DEPENDS           IntegrationTestDevMgmtApiTraceCmds
+    DEPENDS           RunControlApiTestcmds
+    DEPENDS           StateInspectionApiTestcmds
+    DEPENDS           SecurityTestDevMgmtApiGenericCmds
+    DEPENDS           SecurityTestDevMgmtApiAssetTrackingCmds
+    DEPENDS           SecurityTestDevMgmtApiThermalAndPowerMonitoringCmds
+    DEPENDS           SecurityTestDevMgmtApiHistoricalExtremeValCmds
+    DEPENDS           SecurityTestDevMgmtApiErrorControlCmds
+    DEPENDS           SecurityTestDevMgmtApiLinkMgmtCmds
+    DEPENDS           SecurityTestDevMgmtApiPerfMgmtCmds
+)
diff --git a/device-management/tests/DevErrorEvent.cpp b/device-management/tests/DevErrorEvent.cpp
new file mode 100644
index 00000000..d9412402
--- /dev/null
+++ b/device-management/tests/DevErrorEvent.cpp
@@ -0,0 +1,53 @@
+/*-------------------------------------------------------------------------
+ * Copyright (C) 2023, Esperanto Technologies Inc.
+ * The copyright to the computer program(s) herein is the
+ * property of Esperanto Technologies, Inc. All Rights Reserved.
+ * The program(s) may be used and/or copied only with
+ * the written permission of Esperanto Technologies and
+ * in accordance with the terms and conditions stipulated in the
+ * agreement/contract under which the program(s) have been supplied.
+ *-------------------------------------------------------------------------*/
+
+#include "DevErrorEvent.h"
+#include <fmt/format.h>
+#include <regex>
+
+using namespace device_management;
+
+DevErrorEvent::DevErrorEvent(std::string errStats) {
+  for (auto typeIdx = 0U; typeIdx < static_cast<uint8_t>(EventType::TotalEvents); typeIdx++) {
+    std::smatch match;
+    std::regex rgx(getString(static_cast<EventType>(typeIdx)) + ":\\s+(\\d+)");
+    if (std::regex_search(errStats, match, rgx)) {
+      counters_[typeIdx] = std::strtoull(match.str(1).c_str(), nullptr, 10);
+    }
+  }
+}
+
+uint64_t DevErrorEvent::getDevErrorEventCount(DevErrorEvent::EventType eventType) {
+  return counters_[static_cast<uint8_t>(eventType)];
+}
+
+bool DevErrorEvent::hasFailure(std::vector<DevErrorEvent::EventType> skipList) {
+  bool failure = false;
+  static decltype(skipList) fullList;
+  static std::once_flag listOnceFlag;
+  std::call_once(listOnceFlag, []() {
+    for (auto typeIdx = 0U; typeIdx < static_cast<uint8_t>(EventType::TotalEvents); typeIdx++) {
+      fullList.push_back(static_cast<EventType>(typeIdx));
+    }
+    assert(fullList.size() == static_cast<int>(EventType::TotalEvents));
+  });
+  decltype(skipList) checkList;
+  std::sort(skipList.begin(), skipList.end(), [this](auto a, auto b) { return a < b; });
+  std::set_difference(fullList.begin(), fullList.end(), skipList.begin(), skipList.end(), std::back_inserter(checkList),
+                      [this](auto a, auto b) { return a < b; });
+  for (auto eventType : checkList) {
+    if (getDevErrorEventCount(eventType) > 0) {
+      DV_LOG(INFO) << fmt::format("Found error event {} (count: {})", getString(eventType),
+                                  getDevErrorEventCount(eventType));
+      failure = true;
+    }
+  }
+  return failure;
+}
diff --git a/device-management/tests/DevErrorEvent.h b/device-management/tests/DevErrorEvent.h
new file mode 100644
index 00000000..21e1ad18
--- /dev/null
+++ b/device-management/tests/DevErrorEvent.h
@@ -0,0 +1,102 @@
+/*-------------------------------------------------------------------------
+ * Copyright (C) 2023, Esperanto Technologies Inc.
+ * The copyright to the computer program(s) herein is the
+ * property of Esperanto Technologies, Inc. All Rights Reserved.
+ * The program(s) may be used and/or copied only with
+ * the written permission of Esperanto Technologies and
+ * in accordance with the terms and conditions stipulated in the
+ * agreement/contract under which the program(s) have been supplied.
+ *-------------------------------------------------------------------------*/
+
+#pragma once
+#include "utils.h"
+#include <cassert>
+#include <unordered_map>
+
+namespace device_management {
+
+class DevErrorEvent {
+public:
+  enum class EventType : uint8_t {
+    DramCeEvent = 0,
+    MinionCeEvent,
+    PcieCeEvent,
+    PmicCeEvent,
+    SpCeEvent,
+    SpExceptCeEvent,
+    SramCeEvent,
+    ThermOvershootCeEvent,
+    ThermThrottleCeEvent,
+    SpTraceBufferFullCeEvent,
+    DramUceEvent,
+    MinionHangUceEvent,
+    PcieUceEvent,
+    SpHangUceEvent,
+    SpWdogUceEvent,
+    SramUceEvent,
+    TotalEvents
+  };
+
+  DevErrorEvent() = delete;
+  explicit DevErrorEvent(std::string errStats);
+  uint64_t getDevErrorEventCount(EventType event);
+  bool hasFailure(std::vector<EventType> skipList);
+  DevErrorEvent operator+(const DevErrorEvent& other) const {
+    auto result = *this;
+    for (auto typeIdx = 0U; typeIdx < static_cast<uint8_t>(EventType::TotalEvents); typeIdx++) {
+      result.counters_[typeIdx] = this->counters_[typeIdx] + other.counters_[typeIdx];
+    }
+    return result;
+  }
+  DevErrorEvent operator-(const DevErrorEvent& other) const {
+    auto result = *this;
+    for (auto typeIdx = 0U; typeIdx < static_cast<uint8_t>(EventType::TotalEvents); typeIdx++) {
+      result.counters_[typeIdx] = this->counters_[typeIdx] - other.counters_[typeIdx];
+    }
+    return result;
+  }
+
+private:
+  static std::string getString(enum EventType type) {
+    switch (type) {
+    case EventType::DramCeEvent:
+      return "DramCeEvent";
+    case EventType::MinionCeEvent:
+      return "MinionCeEvent";
+    case EventType::PcieCeEvent:
+      return "PcieCeEvent";
+    case EventType::PmicCeEvent:
+      return "PmicCeEvent";
+    case EventType::SpCeEvent:
+      return "SpCeEvent";
+    case EventType::SpExceptCeEvent:
+      return "SpExceptCeEvent";
+    case EventType::SramCeEvent:
+      return "SramCeEvent";
+    case EventType::ThermOvershootCeEvent:
+      return "ThermOvershootCeEvent";
+    case EventType::ThermThrottleCeEvent:
+      return "ThermThrottleCeEvent";
+    case EventType::SpTraceBufferFullCeEvent:
+      return "SpTraceBufferFullCeEvent";
+    case EventType::DramUceEvent:
+      return "DramUceEvent";
+    case EventType::MinionHangUceEvent:
+      return "MinionHangUceEvent";
+    case EventType::PcieUceEvent:
+      return "PcieUceEvent";
+    case EventType::SpHangUceEvent:
+      return "SpHangUceEvent";
+    case EventType::SpWdogUceEvent:
+      return "SpWdogUceEvent";
+    case EventType::SramUceEvent:
+      return "SramUceEvent";
+    default:
+      DV_LOG(INFO) << "Unknown event type: " + std::to_string(static_cast<int>(type));
+      return "Unknown";
+    }
+  }
+  std::array<uint64_t, static_cast<uint8_t>(EventType::TotalEvents)> counters_ = {0};
+};
+
+} // namespace device_management
diff --git a/device-management/tests/TestDevMgmtApi.h b/device-management/tests/TestDevMgmtApi.h
new file mode 100644
index 00000000..e7138bfc
--- /dev/null
+++ b/device-management/tests/TestDevMgmtApi.h
@@ -0,0 +1,84 @@
+/*-------------------------------------------------------------------------
+ * Copyright (C) 2021, Esperanto Technologies Inc.
+ * The copyright to the computer program(s) herein is the
+ * property of Esperanto Technologies, Inc. All Rights Reserved.
+ * The program(s) may be used and/or copied only with
+ * the written permission of Esperanto Technologies and
+ * in accordance with the terms and conditions stipulated in the
+ * agreement/contract under which the program(s) have been supplied.
+ *-------------------------------------------------------------------------*/
+
+#include <esperanto/et-trace/layout.h>
+
+#define ET_TRACE_DECODER_IMPL
+#include <esperanto/et-trace/decoder.h>
+
+// A namespace containing template for `bit_cast`. To be removed when `bit_cast` will be available
+namespace templ {
+template <class To, class From>
+typename std::enable_if_t<
+  sizeof(To) == sizeof(From) && std::is_trivially_copyable_v<From> && std::is_trivially_copyable_v<To>, To>
+// constexpr support needs compiler magic
+bit_cast(const From& src) noexcept {
+  static_assert(std::is_trivially_constructible_v<To>,
+                "This implementation additionally requires destination type to be trivially constructible");
+
+  To dst;
+  memcpy(&dst, &src, sizeof(To));
+  return dst;
+}
+} // namespace templ
+
+struct asic_frequencies_t {
+  uint32_t minion_shire_mhz;
+  uint32_t noc_mhz;
+  uint32_t mem_shire_mhz;
+  uint32_t ddr_mhz;
+  uint32_t pcie_shire_mhz;
+  uint32_t io_shire_mhz;
+} __attribute__((packed));
+
+struct dram_bw_t {
+  uint32_t read_req_sec;
+  uint32_t write_req_sec;
+} __attribute__((packed));
+
+struct max_dram_bw_t {
+  uint8_t max_bw_rd_req_sec;
+  uint8_t max_bw_wr_req_sec;
+  uint8_t pad[6];
+} __attribute__((packed));
+
+struct module_uptime_t {
+  uint16_t day;
+  uint8_t hours;
+  uint8_t mins;
+  uint8_t pad[4];
+} __attribute__((packed));
+
+struct module_voltage_t {
+  uint8_t ddr;
+  uint8_t l2_cache;
+  uint8_t maxion;
+  uint8_t minion;
+  uint8_t pcie;
+  uint8_t noc;
+  uint8_t pcie_logic;
+  uint8_t vddqlp;
+  uint8_t vddq;
+  uint8_t pad[7];
+} __attribute__((packed));
+
+typedef uint8_t power_state_e;
+
+#define SP_NUM_REGISTERS (32)
+#define SP_EXCEPTION_STACK_FRAME_SIZE (sizeof(uint64_t) * 28)
+#define SP_EXCEPTION_CSRS_FRAME_SIZE (sizeof(uint64_t) * 4)
+#define SP_EXCEPTION_FRAME_SIZE (SP_EXCEPTION_STACK_FRAME_SIZE + SP_EXCEPTION_CSRS_FRAME_SIZE)
+#define SP_PERF_GLOBALS_SIZE                                                                                           \
+  (sizeof(struct asic_frequencies_t) + sizeof(struct dram_bw_t) + sizeof(struct max_dram_bw_t) + sizeof(uint32_t) +    \
+   sizeof(uint64_t))
+#define SP_POWER_GLOBALS_SIZE                                                                                          \
+  (sizeof(power_state_e) + sizeof(uint8_t) + (sizeof(uint8_t) * 3) + sizeof(struct module_uptime_t) +                  \
+   sizeof(struct module_voltage_t) + sizeof(uint64_t) + sizeof(uint64_t))
+#define SP_GLOBALS_SIZE (SP_PERF_GLOBALS_SIZE + SP_POWER_GLOBALS_SIZE)
diff --git a/device-management/tests/TestDevMgmtApiSyncCmds.cpp b/device-management/tests/TestDevMgmtApiSyncCmds.cpp
new file mode 100644
index 00000000..0a96510a
--- /dev/null
+++ b/device-management/tests/TestDevMgmtApiSyncCmds.cpp
@@ -0,0 +1,4502 @@
+//******************************************************************************
+// Copyright (C) 2020 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "TestDevMgmtApiSyncCmds.h"
+#include "Autogen.h"
+#include "TestDevMgmtApi.h"
+#include <array>
+#include <atomic>
+#include <chrono>
+#include <condition_variable>
+#include <cstdio>
+#include <dlfcn.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <fmt/format.h>
+#include <fmt/ranges.h>
+#include <fstream>
+#include <glog/logging.h>
+#include <iostream>
+#include <optional>
+#include <regex>
+#include <string>
+#include <unistd.h>
+
+#if __has_include("filesystem")
+#include <filesystem>
+#elif __has_include("experimental/filesystem")
+#include <experimental/filesystem>
+namespace std {
+namespace filesystem = std::experimental::filesystem;
+}
+#endif
+namespace fs = std::filesystem;
+
+using namespace dev;
+using namespace device_management;
+using namespace std::chrono_literals;
+using Clock = std::chrono::system_clock;
+using Timepoint = Clock::time_point;
+using TimeDuration = Clock::duration;
+
+#define DURATION2MS(dur) (((dur).count() > 0) ? std::chrono::duration_cast<std::chrono::milliseconds>(dur).count() : 0)
+#define BIN2VOLTAGE(REG_VALUE, BASE, MULTIPLIER, DIVIDER) (BASE + ((REG_VALUE * MULTIPLIER) / DIVIDER))
+#define VOLTAGE2BIN(VOL_VALUE, BASE, MULTIPLIER, DIVIDER) (uint8_t)(((VOL_VALUE - BASE) * DIVIDER) / MULTIPLIER)
+#define POWER_10MW_TO_MW(pwr_10mw) (pwr_10mw * 10)
+#define POWER_10MW_TO_W(pwr_10mw) (pwr_10mw / 100)
+
+DEFINE_bool(enable_trace_dump, true,
+            "Enable SP trace dump to file specified by flag: trace_logfile, otherwise on UART");
+DEFINE_bool(enable_bin_trace_dump, false, "Dump RAW/binary trace files under FLAGS_trace_bin_dir");
+DEFINE_bool(reset_trace_buffer, true,
+            "Reset the SP trace buffer on the start of the test run if trace logging is enabled");
+DEFINE_string(trace_base_dir, "devtrace", "Base directory which will contain all traces");
+DEFINE_string(trace_txt_dir, FLAGS_trace_base_dir + "/txt_files",
+              "A directory in the current path where the decoded device traces will be printed");
+DEFINE_string(trace_bin_dir, FLAGS_trace_base_dir + "/bin_files",
+              "A directory in the current path where the raw device traces will be dumped");
+DEFINE_uint32(exec_timeout_ms, 30000, "Internal execution timeout in milliseconds");
+
+#define FORMAT_VERSION(major, minor, revision) ((major << 24) | (minor << 16) | (revision << 8))
+#define MAJOR_VERSION(ver) ((ver >> 24) & 0xff)
+#define MINOR_VERSION(ver) ((ver >> 16) & 0xff)
+#define REVISION_VERSION(ver) ((ver >> 8) & 0xff)
+#define PMIC_FORMAT_VERSION(major, minor, revision) ((major << 16) | (minor << 8) | revision)
+#define EXTRACT_BYTE(byte_idx, org_val) (0xFF & (org_val >> (byte_idx * 8)))
+
+// These constants are based on the settings of firmware and flash tool
+static constexpr const int kPmicFlashImageMetadataOffset = 256;
+static constexpr const int kFlashImageRawFileHeaderSize = 2816;
+
+// PMIC Runtime Image metadata header - must be synced with device
+typedef struct pmicRtMetadata_ {
+  uint32_t start_addr;
+  uint32_t version;
+  uint32_t supported_board_types;
+  char hash[16];
+  uint32_t checksum;
+  uint32_t image_size;
+  uint32_t bl_fw_version;
+  uint32_t sp_pmic_interface_version;
+  uint32_t metadata_version;
+  uint32_t build_type;
+} pmicRuntimeMetadata_t;
+
+getDM_t TestDevMgmtApiSyncCmds::getInstance() {
+  const char* error;
+
+  if (handle_) {
+    getDM_t getDM = reinterpret_cast<getDM_t>(dlsym(handle_, "getInstance"));
+    if (!(error = dlerror())) {
+      return getDM;
+    }
+    std::cout << "Error: " << error << std::endl;
+  }
+  return (getDM_t)0;
+}
+
+std::string inline getTraceTxtName(int deviceIdx) {
+  return (fs::path(FLAGS_trace_txt_dir) / fs::path("dev" + std::to_string(deviceIdx) + "_traces.txt")).string();
+}
+
+std::string inline getFullTestName() {
+  return ::testing::UnitTest::GetInstance()->current_test_info()->test_case_name() + std::string(".") +
+         ::testing::UnitTest::GetInstance()->current_test_info()->name();
+}
+
+void TestDevMgmtApiSyncCmds::launchEventProcessor(int deviceIdx) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  while (eventProcessorRunning_) {
+    std::vector<std::byte> response;
+    if (auto eventOccured = dm.getDMEvent(deviceIdx, response, FLAGS_exec_timeout_ms); eventOccured) {
+      auto rCB = reinterpret_cast<const dm_evt*>(response.data());
+      if (rCB->info.event_hdr.msg_id == device_mgmt_api::DM_EVENT_SP_TRACE_BUFFER_FULL) {
+        DV_LOG(INFO) << "SP Buffer FULL event recieved, extracting traces" << std::endl;
+        if (dm.getTraceBufferServiceProcessor(deviceIdx, TraceBufferType::TraceBufferSP, response) !=
+            device_mgmt_api::DM_STATUS_SUCCESS) {
+          DV_LOG(INFO) << "Unable to get trace buffer for device: " << deviceIdx;
+          continue;
+        }
+        dumpRawTraceBuffer(deviceIdx, response, TraceBufferType::TraceBufferSP);
+        decodeTraceEvents(deviceIdx, response, TraceBufferType::TraceBufferSP);
+      }
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::initEventProcessor() {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto deviceCount = dm.getDevicesCount();
+
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    // launch the thread to monitor SP trace buffer events
+    eventThreads_.push_back(std::thread(std::bind(&TestDevMgmtApiSyncCmds::launchEventProcessor, this, deviceIdx)));
+    eventThreads_.back().detach();
+    eventProcessorRunning_ = true;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::cleanupEventProcessor() {
+  eventProcessorRunning_ = false;
+}
+
+void TestDevMgmtApiSyncCmds::initTestTrace() {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = dm.getDevicesCount();
+
+  if (getTestTarget() == Target::Loopback) {
+    FLAGS_enable_trace_dump = false;
+  }
+  if (FLAGS_enable_trace_dump) {
+    fs::create_directory(FLAGS_trace_base_dir);
+    fs::create_directory(FLAGS_trace_txt_dir);
+    fs::create_directory(FLAGS_trace_bin_dir);
+    for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+      std::ofstream logfile(getTraceTxtName(deviceIdx), std::ios_base::app);
+      logfile << "\n" << getFullTestName() << std::endl;
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::initDevErrorEvent(std::initializer_list<DevErrorEvent::EventType> list) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  for (int deviceIdx = 0; deviceIdx < dm.getDevicesCount(); deviceIdx++) {
+    eventsAtStartMap_.try_emplace(deviceIdx,
+                                  DevErrorEvent(devLayer_->getDeviceAttribute(deviceIdx, "err_stats/ce_count") +
+                                                devLayer_->getDeviceAttribute(deviceIdx, "err_stats/uce_count")));
+  }
+  setDevErrorEventSkipList(std::move(list));
+}
+
+void TestDevMgmtApiSyncCmds::checkDevErrorEvent() {
+  if (isParallelRun()) {
+    // In parallel runs, the error events can be generated by the tests running in parallel and that
+    // may generate false alarms
+    return;
+  }
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  for (const auto& [deviceIdx, eventsAtStart] : eventsAtStartMap_) {
+    auto eventsNow = DevErrorEvent(devLayer_->getDeviceAttribute(deviceIdx, "err_stats/ce_count") +
+                                   devLayer_->getDeviceAttribute(deviceIdx, "err_stats/uce_count"));
+    EXPECT_FALSE((eventsNow - eventsAtStart).hasFailure(devErrorEventSkipList_))
+      << fmt::format("Device[{}]: Failure found in error events!", deviceIdx);
+  }
+}
+
+void TestDevMgmtApiSyncCmds::controlTraceLogging(void) {
+  if (!FLAGS_enable_trace_dump) {
+    return;
+  }
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  // Trace control input params
+  std::array<char, sizeof(device_mgmt_api::trace_control_e)> input_buff;
+  device_mgmt_api::trace_control_e control = device_mgmt_api::TRACE_CONTROL_TRACE_ENABLE;
+  if (FLAGS_reset_trace_buffer) {
+    control |= device_mgmt_api::TRACE_CONTROL_RESET_TRACEBUF;
+  }
+
+  memcpy(input_buff.data(), &control, sizeof(control));
+
+  std::array<char, sizeof(uint8_t)> set_output_buff = {0};
+  auto hst_latency = std::make_unique<uint32_t>();
+  auto dev_latency = std::make_unique<uint64_t>();
+
+  auto deviceCount = dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_DM_TRACE_RUN_CONTROL, input_buff.data(),
+                                input_buff.size(), set_output_buff.data(), set_output_buff.size(), hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::dmStatsRunControl(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto setStatsRunControl = [&](int deviceIdx, device_mgmt_api::stats_type_e type,
+                                device_mgmt_api::stats_control_e control) {
+    // Trace control input params
+    std::array<char, sizeof(type) + sizeof(control)> input_buff;
+    memcpy(input_buff.data(), &type, sizeof(type));
+    memcpy(input_buff.data() + sizeof(type), &control, sizeof(control));
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    if (dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_STATS_RUN_CONTROL, input_buff.data(),
+                          input_buff.size(), nullptr, 0, hst_latency.get(), dev_latency.get(),
+                          DURATION2MS(end - Clock::now())) != device_mgmt_api::DM_STATUS_SUCCESS) {
+      return false;
+    }
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+    return true;
+  };
+
+  auto findStatsSampleInStatsBuffer = [&](int deviceIdx, TraceBufferType type) {
+    std::vector<std::byte> buff;
+    bool found = false;
+    if (dm.getTraceBufferServiceProcessor(deviceIdx, type, buff) != device_mgmt_api::DM_STATUS_SUCCESS) {
+      return found;
+    } else {
+      for (const trace_entry_header_t* entry = nullptr;
+           entry = Trace_Decode(static_cast<trace_buffer_std_header_t*>(static_cast<void*>(buff.data())), entry);) {
+        if (entry->type == TRACE_TYPE_CUSTOM_EVENT) {
+          found = true;
+          break;
+        }
+      }
+    }
+    return found;
+  };
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    // Disable the trace logging
+    ASSERT_TRUE(setStatsRunControl(deviceIdx, device_mgmt_api::STATS_TYPE_SP | device_mgmt_api::STATS_TYPE_MM,
+                                   device_mgmt_api::STATS_CONTROL_TRACE_DISABLE))
+      << fmt::format("Device[{}]: setStatsRunControl() failed!", deviceIdx);
+
+    // Reset the trace buffer
+    ASSERT_TRUE(setStatsRunControl(deviceIdx, device_mgmt_api::STATS_TYPE_SP | device_mgmt_api::STATS_TYPE_MM,
+                                   device_mgmt_api::STATS_CONTROL_TRACE_DISABLE |
+                                     device_mgmt_api::STATS_CONTROL_RESET_COUNTER |
+                                     device_mgmt_api::STATS_CONTROL_RESET_TRACEBUF))
+      << fmt::format("Device[{}]: setStatsRunControl() failed!", deviceIdx);
+    EXPECT_FALSE(findStatsSampleInStatsBuffer(deviceIdx, TraceBufferType::TraceBufferSPStats))
+      << fmt::format("Device[{}]: No SP Stats should have received!", deviceIdx);
+    EXPECT_FALSE(findStatsSampleInStatsBuffer(deviceIdx, TraceBufferType::TraceBufferMMStats))
+      << fmt::format("Device[{}]: No MM Stats should have received!", deviceIdx);
+
+    ASSERT_TRUE(setStatsRunControl(deviceIdx, device_mgmt_api::STATS_TYPE_SP | device_mgmt_api::STATS_TYPE_MM,
+                                   device_mgmt_api::STATS_CONTROL_TRACE_ENABLE))
+      << fmt::format("Device[{}]: setStatsRunControl() failed!", deviceIdx);
+  }
+
+  std::vector<bool> spStatsFound(deviceCount, false);
+  std::vector<bool> mmStatsFound(deviceCount, false);
+  auto loopDelay = (getTestTarget() == Target::Silicon) ? std::chrono::milliseconds(250) : std::chrono::seconds(1);
+  // Stats not immediately available, requires a delay. Wait until SP and MM Stats of all devices are received.
+  for (; Clock::now() < end && !(std::all_of(spStatsFound.begin(), spStatsFound.end(), [](bool v) { return v; }) &&
+                                 std::all_of(mmStatsFound.begin(), mmStatsFound.end(), [](bool v) { return v; }));
+       std::this_thread::sleep_for(loopDelay)) {
+    for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+      if (!spStatsFound[deviceIdx]) {
+        spStatsFound[deviceIdx] = findStatsSampleInStatsBuffer(deviceIdx, TraceBufferType::TraceBufferSPStats);
+      }
+      if (!mmStatsFound[deviceIdx]) {
+        mmStatsFound[deviceIdx] = findStatsSampleInStatsBuffer(deviceIdx, TraceBufferType::TraceBufferMMStats);
+      }
+    }
+  }
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    EXPECT_TRUE(spStatsFound[deviceIdx]) << fmt::format("Device[{}]: SP stats should have received now!", deviceIdx);
+    EXPECT_TRUE(mmStatsFound[deviceIdx]) << fmt::format("Device[{}]: MM stats should have received now!", deviceIdx);
+  }
+}
+
+static inline void logTraceException(std::stringstream& logs, const struct trace_entry_header_t* entry) {
+  const trace_execution_stack_t* tracePacketExecStack = templ::bit_cast<trace_execution_stack_t*>(entry);
+  logs << "\nsepc = 0x" << std::hex << tracePacketExecStack->registers.epc << std::endl;
+  logs << "stval = 0x" << std::hex << tracePacketExecStack->registers.tval << std::endl;
+  logs << "sstatus = 0x" << std::hex << tracePacketExecStack->registers.status << std::endl;
+  logs << "scause = 0x" << std::hex << tracePacketExecStack->registers.cause << std::endl;
+  /* Log x1-x31 */
+  for (int idx = 0; idx < TRACE_DEV_CONTEXT_GPRS; idx++) {
+    logs << "x" << std::dec << idx + 1 << " = "
+         << "0x" << std::hex << tracePacketExecStack->registers.gpr[idx] << std::endl;
+  }
+}
+
+static inline bool decodeSingleTraceEvent(std::stringstream& logs, const struct trace_entry_header_t* entry) {
+  auto validTypeFound = true;
+  logs << "H:" << entry->hart_id << " Timestamp:" << entry->cycle << " :";
+  if (entry->type == TRACE_TYPE_STRING) {
+    std::array<char, TRACE_STRING_MAX_SIZE + 1> stringLog;
+    const trace_string_t* tracePacketString = templ::bit_cast<trace_string_t*>(entry);
+    snprintf(stringLog.data(), TRACE_STRING_MAX_SIZE + 1, "%s", tracePacketString->string);
+    logs << stringLog.data() << std::endl;
+  } else if (entry->type == TRACE_TYPE_EXCEPTION) {
+    logTraceException(logs, entry);
+  } else if (entry->type > TRACE_TYPE_STRING && entry->type <= TRACE_TYPE_CUSTOM_EVENT) {
+    logs << "Trace Packet Type:" << entry->type
+         << ", Use trace-utils decoder on trace binary file to parse this packet." << std::endl;
+  } else {
+    logs << "Invalid Trace Packet Type:" << entry->type << std::endl;
+    validTypeFound = false;
+  }
+  return validTypeFound;
+}
+
+static inline uint32_t updatePmicMetaFwHash(std::string pmicSlotImgPath, char* newHash, char* oldHash) {
+  std::fstream pmicImage;
+  // Open the PMIC slot image
+  pmicImage.open(pmicSlotImgPath, std::fstream::binary | std::fstream::in | std::fstream::out);
+  if (pmicImage.is_open() && (pmicImage.tellp() <= 0)) {
+    int pmicMetaStartOffset = kFlashImageRawFileHeaderSize + kPmicFlashImageMetadataOffset;
+    // Seek to the start of the PMIC FW hash in metadata
+    pmicImage.seekg(pmicMetaStartOffset + offsetof(pmicRuntimeMetadata_t, hash), std::fstream::beg);
+    // Read the PMIC FW hash
+    pmicImage.read(oldHash, 16);
+    DV_LOG(INFO) << "PMIC current hash: " << oldHash;
+    DV_LOG(INFO) << "PMIC new hash: " << newHash;
+    // Seek to the start of the PMIC FW hash in metadata
+    pmicImage.seekp(pmicMetaStartOffset + offsetof(pmicRuntimeMetadata_t, hash), std::fstream::beg);
+    // Write the new PMIC FW hash
+    pmicImage.write(newHash, 16);
+
+    // Re-compute the checksum
+    uint32_t checksum = 0;
+    // Write zero initially to checksum
+    pmicImage.seekp(pmicMetaStartOffset + offsetof(pmicRuntimeMetadata_t, checksum), std::fstream::beg);
+    // Write the new PMIC FW checksum
+    pmicImage.write(templ::bit_cast<char*>(&checksum), sizeof(checksum));
+    // Get the total size of PMIC image
+    uint32_t fileSize;
+    pmicImage.seekg(pmicMetaStartOffset + offsetof(pmicRuntimeMetadata_t, image_size), std::fstream::beg);
+    // Read the PMIC FW size
+    pmicImage.read(templ::bit_cast<char*>(&fileSize), sizeof(fileSize));
+
+    // Now recompute the checksum from the beginning of PMIC image
+    int32_t temp32;
+    pmicImage.seekg(kFlashImageRawFileHeaderSize, std::fstream::beg);
+    for (int idx = 0; idx < fileSize; idx += 4) {
+      pmicImage.read(templ::bit_cast<char*>(&temp32), sizeof(temp32));
+      checksum += temp32;
+    }
+    checksum = ((0 - checksum) & ((1UL << 32) - 1));
+    DV_LOG(INFO) << "PMIC new checksum: " << checksum;
+
+    // Seek to the start of the PMIC checksum in metadata
+    pmicImage.seekp(pmicMetaStartOffset + offsetof(pmicRuntimeMetadata_t, checksum), std::fstream::beg);
+    // Write the new PMIC checksum
+    pmicImage.write(templ::bit_cast<char*>(&checksum), sizeof(checksum));
+
+    pmicImage.close();
+    return true;
+  } else {
+    return false;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::dumpRawTraceBuffer(int deviceIdx, const std::vector<std::byte>& traceBufRaw,
+                                                TraceBufferType bufferType) const {
+  if (!FLAGS_enable_bin_trace_dump) {
+    return;
+  }
+  if (traceBufRaw.empty()) {
+    DV_LOG(INFO) << "Invalid trace buffer! size is 0";
+    return;
+  }
+  std::vector<std::byte> traceBuf;
+  traceBuf.insert(traceBuf.begin(), traceBufRaw.begin(), traceBufRaw.end());
+  struct trace_buffer_std_header_t* traceHdr;
+  std::string fileName = (fs::path(FLAGS_trace_bin_dir) / fs::path("dev" + std::to_string(deviceIdx) + "_")).string();
+  unsigned int dataSize = 0;
+  auto fileFlags = std::ofstream::binary;
+  // Select the bin file
+  switch (bufferType) {
+  case TraceBufferType::TraceBufferSP:
+    traceHdr = templ::bit_cast<trace_buffer_std_header_t*>(traceBuf.data());
+    dataSize = traceHdr->data_size;
+    fileName += "sp_";
+    fileFlags |= std::ios_base::app;
+    break;
+  case TraceBufferType::TraceBufferSPStats:
+    traceHdr = templ::bit_cast<trace_buffer_std_header_t*>(traceBuf.data());
+    dataSize = traceHdr->data_size;
+    fileName += "sp_stats_";
+    fileFlags |= std::ios_base::app;
+    break;
+  case TraceBufferType::TraceBufferMM:
+    traceHdr = templ::bit_cast<trace_buffer_std_header_t*>(traceBuf.data());
+    dataSize = traceHdr->data_size;
+    fileName += "mm_";
+    fileFlags |= std::ios_base::app;
+    break;
+  case TraceBufferType::TraceBufferMMStats:
+    traceHdr = templ::bit_cast<trace_buffer_std_header_t*>(traceBuf.data());
+    dataSize = traceHdr->data_size;
+    fileName += "mm_stats_";
+    fileFlags |= std::ios_base::app;
+    break;
+  case TraceBufferType::TraceBufferCM:
+    traceHdr = templ::bit_cast<trace_buffer_std_header_t*>(traceBuf.data());
+    dataSize = traceHdr->sub_buffer_count * traceHdr->sub_buffer_size;
+    fileName += "cmsmode_";
+    fileFlags |= std::ofstream::trunc;
+    break;
+
+  default:
+    DV_LOG(INFO) << "Cannot dump unknown buffer type!";
+    return;
+  }
+
+  /* check if it is invoked from text context*/
+  if (::testing::UnitTest::GetInstance() && ::testing::UnitTest::GetInstance()->current_test_info()) {
+    fileName += std::string(::testing::UnitTest::GetInstance()->current_test_info()->name()) + ".bin";
+  } else {
+    fileName += std::to_string(std::chrono::system_clock::now().time_since_epoch().count()) + ".bin";
+  }
+
+  if (dataSize < sizeof(trace_buffer_std_header_t)) {
+    return;
+  }
+
+  std::ofstream rawTrace;
+
+  // Open the file
+  rawTrace.open(fileName, fileFlags);
+  if (rawTrace.is_open()) {
+    bool update_size = false;
+
+    // Check if the file is empty
+    if (rawTrace.tellp() <= 0) {
+      rawTrace.write(templ::bit_cast<char*>(traceHdr), sizeof(trace_buffer_std_header_t));
+    } else {
+      update_size = true;
+    }
+    // Remove the size of std header
+    dataSize -= static_cast<unsigned int>(sizeof(trace_buffer_std_header_t));
+    // Dump raw Trace data in the file (without std header)
+    rawTrace.write(templ::bit_cast<char*>(traceBuf.data() + sizeof(trace_buffer_std_header_t)), dataSize);
+    // Close the file
+    rawTrace.close();
+
+    // If we are appending data into existing file then update data size in raw trace header.
+    if (update_size && dataSize) {
+      unsigned int rawSize = 0;
+      std::fstream tracefile(fileName, std::fstream::binary | std::fstream::in | std::fstream::out);
+
+      // Get data existing data size in raw binary
+      tracefile.seekg(offsetof(trace_buffer_std_header_t, data_size), std::fstream::beg);
+      tracefile.read(templ::bit_cast<char*>(&rawSize), sizeof(traceHdr->data_size));
+
+      // Update data size
+      rawSize += dataSize;
+      tracefile.seekp(offsetof(trace_buffer_std_header_t, data_size), std::fstream::beg);
+      tracefile.write(templ::bit_cast<char*>(&rawSize), sizeof(traceHdr->data_size));
+      tracefile.close();
+    }
+  } else {
+    DV_LOG(INFO) << "Unable to open file: " << fileName;
+  }
+}
+
+bool TestDevMgmtApiSyncCmds::decodeTraceEvents(int deviceIdx, const std::vector<std::byte>& traceBufRaw,
+                                               TraceBufferType bufferType) const {
+  if (traceBufRaw.empty()) {
+    DV_LOG(INFO) << "Invalid trace buffer! size is 0";
+    return false;
+  }
+  std::vector<std::byte> traceBuf;
+  std::ofstream logfile;
+  std::string fileName = getTraceTxtName(deviceIdx);
+  traceBuf.insert(traceBuf.begin(), traceBufRaw.begin(), traceBufRaw.end());
+
+  DV_LOG(INFO) << "Saving trace to file: " << fileName;
+  logfile.open(fileName, std::ios_base::app);
+  switch (bufferType) {
+  case TraceBufferType::TraceBufferSP:
+    logfile << "-> SP Traces" << std::endl;
+    break;
+  case TraceBufferType::TraceBufferSPStats:
+    logfile << "-> SP Stats Traces" << std::endl;
+    break;
+  case TraceBufferType::TraceBufferMM:
+    logfile << "-> MM S-Mode Traces" << std::endl;
+    break;
+  case TraceBufferType::TraceBufferMMStats:
+    logfile << "-> MM Stats Traces" << std::endl;
+    break;
+  case TraceBufferType::TraceBufferCM:
+    logfile << "-> CM S-Mode Traces" << std::endl;
+    break;
+  default:
+    DV_LOG(INFO) << "Cannot decode unknown buffer type!";
+    logfile.close();
+    return false;
+  }
+
+  const struct trace_entry_header_t* entry = NULL;
+  bool validEventFound = false;
+  std::stringstream logs;
+  for (entry = Trace_Decode(templ::bit_cast<trace_buffer_std_header_t*>(traceBuf.data()), entry); entry;
+       entry = Trace_Decode(templ::bit_cast<trace_buffer_std_header_t*>(traceBuf.data()), entry)) {
+    if (decodeSingleTraceEvent(logs, entry)) {
+      validEventFound = true;
+    }
+  }
+
+  logfile << logs.str();
+  logfile.close();
+
+  return validEventFound;
+}
+
+bool TestDevMgmtApiSyncCmds::extractAndPrintTraceData(bool singleDevice, TraceBufferType bufferType) {
+  if (!FLAGS_enable_trace_dump) {
+    return false;
+  }
+
+  getDM_t dmi = getInstance();
+  EXPECT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  std::vector<std::byte> response;
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  auto validTraceDataFound = false;
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    if (dm.getTraceBufferServiceProcessor(deviceIdx, bufferType, response) != device_mgmt_api::DM_STATUS_SUCCESS) {
+      DV_LOG(INFO) << "Unable to get trace buffer for device: " << deviceIdx << ". Disabling Trace.";
+      continue;
+    }
+    dumpRawTraceBuffer(deviceIdx, response, bufferType);
+    if (decodeTraceEvents(deviceIdx, response, bufferType)) {
+      validTraceDataFound = true;
+    }
+  }
+
+  return validTraceDataFound;
+}
+
+void TestDevMgmtApiSyncCmds::getModuleManufactureName(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::asset_info_t);
+  char expected[output_size] = {0};
+  strncpy(expected, "Esperanto", output_size);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MANUFACTURE_NAME, nullptr, 0,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      printf("output_buff: %.*s\n", output_size, output_buff);
+      device_mgmt_api::asset_info_t* asset_info = (device_mgmt_api::asset_info_t*)output_buff;
+      EXPECT_EQ(strncmp(asset_info->asset, expected, output_size), 0);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModulePartNumber(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+  uint32_t partNumber;
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_PART_NUMBER, nullptr, 0,
+                                static_cast<char*>(static_cast<void*>(&partNumber)), sizeof(partNumber),
+                                hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received partNumber={:08x}", deviceIdx, partNumber);
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getFRUTest(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto getFRU = [&](int deviceIdx) -> bool {
+    char fruData[FRU_SIZE];
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    if (dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_FRU, nullptr, 0, fruData, sizeof(fruData),
+                          hst_latency.get(), dev_latency.get(),
+                          DURATION2MS(end - Clock::now())) != device_mgmt_api::DM_STATUS_SUCCESS) {
+      DV_LOG(INFO) << "Service Request Failed for Device: " << deviceIdx;
+      return false;
+    }
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+    return true;
+  };
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    ASSERT_TRUE(getFRU(deviceIdx)) << "getFRU() failed!";
+  }
+}
+
+void TestDevMgmtApiSyncCmds::setFRUTest(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto setFRU = [&](int deviceIdx) -> bool {
+    char fruData[FRU_SIZE] = {
+      (char)0x01, (char)0x00, (char)0x00, (char)0x01, (char)0x0A, (char)0x00, (char)0x00, (char)0xF4, (char)0x01,
+      (char)0x09, (char)0x19, (char)0xD2, (char)0x81, (char)0xE2, (char)0x95, (char)0xE5, (char)0x0C, (char)0x97,
+      (char)0x72, (char)0xE8, (char)0xD2, (char)0xEF, (char)0x03, (char)0x97, (char)0xEE, (char)0x59, (char)0xA7,
+      (char)0x2E, (char)0x30, (char)0xBF, (char)0x6C, (char)0x4D, (char)0xA7, (char)0xAF, (char)0x3B, (char)0x03,
+      (char)0x8C, (char)0xF0, (char)0x18, (char)0x32, (char)0xF0, (char)0x98, (char)0x96, (char)0x4D, (char)0x04,
+      (char)0x61, (char)0x58, (char)0x43, (char)0x02, (char)0x86, (char)0x24, (char)0x14, (char)0x41, (char)0x64,
+      (char)0x34, (char)0x01, (char)0x89, (char)0x50, (char)0x04, (char)0x59, (char)0xD8, (char)0x54, (char)0xD1,
+      (char)0x50, (char)0x14, (char)0x46, (char)0x89, (char)0x19, (char)0x06, (char)0x59, (char)0x18, (char)0x56,
+      (char)0x99, (char)0xD0, (char)0x14, (char)0x02, (char)0xC1, (char)0x00, (char)0x00, (char)0x27, (char)0x01,
+      (char)0x07, (char)0x19, (char)0x95, (char)0xE5, (char)0x0C, (char)0x97, (char)0x72, (char)0xE8, (char)0xD2,
+      (char)0xEF, (char)0x03, (char)0x97, (char)0xEE, (char)0x59, (char)0xA7, (char)0x2E, (char)0x30, (char)0xBF,
+      (char)0x6C, (char)0x4D, (char)0xA7, (char)0xAF, (char)0x3B, (char)0x03, (char)0x87, (char)0xF0, (char)0x98,
+      (char)0x96, (char)0x4D, (char)0x04, (char)0x61, (char)0x18, (char)0x89, (char)0xF0, (char)0x98, (char)0x96,
+      (char)0x4D, (char)0x04, (char)0x61, (char)0x58, (char)0x43, (char)0x02, (char)0xC0, (char)0x86, (char)0x24,
+      (char)0x14, (char)0x41, (char)0x64, (char)0x34, (char)0x01, (char)0xC0, (char)0xC0, (char)0xC1, (char)0x00,
+      (char)0xB7, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00,
+      (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00,
+      (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00,
+      (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00,
+      (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00,
+      (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00,
+      (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00,
+      (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00,
+      (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00,
+      (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00,
+      (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00,
+      (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00,
+      (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00, (char)0x00,
+      (char)0x00, (char)0x00, (char)0x00, (char)0x00,
+    };
+
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    if (dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_FRU, fruData, sizeof(fruData), nullptr, 0,
+                          hst_latency.get(), dev_latency.get(),
+                          DURATION2MS(end - Clock::now())) != device_mgmt_api::DM_STATUS_SUCCESS) {
+      DV_LOG(INFO) << "Service Request Failed for Device: " << deviceIdx;
+      return false;
+    }
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+    return true;
+  };
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    ASSERT_TRUE(setFRU(deviceIdx)) << "setFRU() failed!";
+  }
+}
+
+void TestDevMgmtApiSyncCmds::setAndGetModulePartNumber(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto setModulePartNumber = [&](int deviceIdx, uint32_t partNumber) {
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    DV_LOG(INFO) << fmt::format("Device[{}]: Setting partNumber={:08x}", deviceIdx, partNumber);
+    if (dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_PART_NUMBER,
+                          static_cast<char*>(static_cast<void*>(&partNumber)), sizeof(partNumber), nullptr, 0,
+                          hst_latency.get(), dev_latency.get(),
+                          DURATION2MS(end - Clock::now())) != device_mgmt_api::DM_STATUS_SUCCESS) {
+      return false;
+    }
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+    return true;
+  };
+
+  auto getModulePartNumber = [&](int deviceIdx) -> std::optional<uint32_t> {
+    uint32_t partNumber;
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    if (dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_PART_NUMBER, nullptr, 0,
+                          static_cast<char*>(static_cast<void*>(&partNumber)), sizeof(partNumber), hst_latency.get(),
+                          dev_latency.get(), DURATION2MS(end - Clock::now())) != device_mgmt_api::DM_STATUS_SUCCESS) {
+      return std::nullopt;
+    }
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received partNumber={:08x}", deviceIdx, partNumber);
+    return partNumber;
+  };
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    // Get default partNumber
+    auto container = getModulePartNumber(deviceIdx);
+    ASSERT_TRUE(container.has_value()) << "getModulePartNumber() failed!";
+    auto defaultPartNumber = container.value();
+
+    // Set the testPartNumber (0xdeadbeef)
+    uint32_t testPartNumber = 0xdeadbeef;
+    ASSERT_TRUE(setModulePartNumber(deviceIdx, testPartNumber)) << "setModulePartNumber() failed!";
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      // Validate testPartNumber
+      container = getModulePartNumber(deviceIdx);
+      ASSERT_TRUE(container.has_value()) << "getModulePartNumber() failed!";
+      EXPECT_EQ(container.value(), testPartNumber) << "Unable to set test partNumber";
+    }
+
+    // Revert back to default partNumber
+    ASSERT_TRUE(setModulePartNumber(deviceIdx, defaultPartNumber)) << "setModulePartNumber() failed";
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      // Validate default partNumber is set
+      container = getModulePartNumber(deviceIdx);
+      ASSERT_TRUE(container.has_value()) << "getModulePartNumber() failed!";
+      EXPECT_EQ(container.value(), defaultPartNumber) << "Unable to revert to default partNumber";
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModuleSerialNumber(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  ecid_t ecid;
+  const uint32_t output_size = sizeof(device_mgmt_api::asset_info_t);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_SERIAL_NUMBER, nullptr, 0,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      memcpy(&ecid, output_buff, sizeof(ecid_t));
+      printf("  Lot ID       = %s (0x%016lx)\n", ecid.lot_id_str, ecid.lot_id);
+      printf("  Wafer ID     = 0x%02x (%d)\n", ecid.wafer_id, ecid.wafer_id);
+      printf("  X Coordinate = 0x%02x (%d)\n", ecid.x_coordinate, ecid.x_coordinate);
+      printf("  Y Coordinate = 0x%02x (%d)\n", ecid.y_coordinate, ecid.y_coordinate);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getASICChipRevision(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::asset_info_t);
+  char expected[output_size] = {0};
+  strncpy(expected, "160", output_size);
+  printf("expected: %.*s\n", output_size, expected);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_CHIP_REVISION, nullptr, 0,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      printf("output_buff: %.*s\n", output_size, output_buff);
+
+      device_mgmt_api::asset_info_t* asset_info = (device_mgmt_api::asset_info_t*)output_buff;
+
+      EXPECT_EQ(strncmp(asset_info->asset, expected, output_size), 0);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModulePCIEPortsMaxSpeed(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::asset_info_t);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_PCIE_NUM_PORTS_MAX_SPEED, nullptr,
+                                0, output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      printf("output_buff: %.*s\n", output_size, output_buff);
+
+      device_mgmt_api::asset_info_t* asset_info = (device_mgmt_api::asset_info_t*)output_buff;
+
+      // TODO: SW-13272: Compare the max link speed with max_link_speed sysfs attribute
+      // auto sysfsMaxLinkSpeed = devLayer_->getDeviceAttribute(deviceIdx, "max_link_speed");
+      // auto receivedMaxLinkSpeed = std::string(asset_info->asset);
+      // EXPECT_NE(sysfsMaxLinkSpeed.find(receivedMaxLinkSpeed), std::string::npos)
+      //   << "Max Link Speed: received: " << receivedMaxLinkSpeed << " vs sysfs_attribute: " << sysfsMaxLinkSpeed;
+      EXPECT_TRUE(strncmp(asset_info->asset, "16", output_size) == 0 ||
+                  strncmp(asset_info->asset, "8", output_size) == 0);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModuleMemorySizeMB(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = 1;
+  std::vector<std::array<uint8_t, output_size>> expected = {{16}, {32}};
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    std::array<uint8_t, output_size> output_buff = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MEMORY_SIZE_MB, nullptr, 0,
+                                static_cast<char*>(static_cast<void*>(output_buff.data())), output_buff.size(),
+                                hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      EXPECT_TRUE(std::any_of(expected.begin(), expected.end(),
+                              [&](const std::array<uint8_t, output_size>& value) {
+                                return std::memcmp(output_buff.data(), value.data(), output_buff.size()) == 0;
+                              }))
+        << fmt::format("Expected: {} whereas output: {}", fmt::join(expected, ", "), output_buff);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModuleRevision(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = 4;
+  unsigned char expected[output_size] = {0x44, 0xab, 0x11, 0x22};
+  printf("expected: %.*s\n", output_size, expected);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_REVISION, nullptr, 0, output_buff,
+                                output_size, hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      printf("output_buff: %.*s\n", output_size, output_buff);
+
+      device_mgmt_api::asset_info_t* asset_info = (device_mgmt_api::asset_info_t*)output_buff;
+
+      EXPECT_EQ(memcmp(asset_info->asset, expected, output_size), 0);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModuleFormFactor(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = 1;
+  char expected[output_size] = {1};
+  printf("expected: %.*s\n", output_size, expected);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_FORM_FACTOR, nullptr, 0,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      printf("output_buff: %.*s\n", output_size, output_buff);
+
+      device_mgmt_api::asset_info_t* asset_info = (device_mgmt_api::asset_info_t*)output_buff;
+
+      EXPECT_EQ(strncmp(asset_info->asset, expected, output_size), 0);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModuleMemoryVendorPartNumber(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::asset_info_t);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MEMORY_VENDOR_PART_NUMBER,
+                                nullptr, 0, output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      printf("output_buff: %.*s\n", output_size, output_buff);
+
+      device_mgmt_api::asset_info_t* asset_info = (device_mgmt_api::asset_info_t*)output_buff;
+
+      EXPECT_EQ((output_size > 0), 1);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModuleMemoryType(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::asset_info_t);
+  char expected[output_size] = {0};
+  strncpy(expected, "LPDDR4X", output_size);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MEMORY_TYPE, nullptr, 0,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      printf("output_buff: %.*s\n", output_size, output_buff);
+
+      device_mgmt_api::asset_info_t* asset_info = (device_mgmt_api::asset_info_t*)output_buff;
+
+      EXPECT_EQ(strncmp(asset_info->asset, expected, output_size), 0);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModulePowerState(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    const uint32_t get_output_size = sizeof(device_mgmt_api::power_state_e);
+    char get_output_buff[get_output_size] = {0};
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_POWER_STATE, nullptr, 0,
+                                get_output_buff, get_output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      uint8_t powerstate = get_output_buff[0];
+      // Note: Module's Power State could vary. So there cannot be expected value for Power State in the test
+      printf("Module's Power State: %d\n", powerstate);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::setModuleActivePowerManagement(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    const uint32_t input_size = sizeof(device_mgmt_api::active_power_management_e);
+    char input_buff[input_size] = {device_mgmt_api::ACTIVE_POWER_MANAGEMENT_TURN_ON};
+
+    const uint32_t set_output_size = sizeof(uint8_t);
+    char set_output_buff[set_output_size] = {0};
+
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_ACTIVE_POWER_MANAGEMENT,
+                                input_buff, input_size, set_output_buff, set_output_size, hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      EXPECT_EQ((uint32_t)set_output_buff[0], device_mgmt_api::DM_STATUS_SUCCESS);
+    }
+
+    // The active power management is disabled by default, so disabling it to revert back to default state
+    input_buff[input_size] = {device_mgmt_api::ACTIVE_POWER_MANAGEMENT_TURN_OFF};
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_ACTIVE_POWER_MANAGEMENT,
+                                input_buff, input_size, set_output_buff, set_output_size, hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      EXPECT_EQ((uint32_t)set_output_buff[0], device_mgmt_api::DM_STATUS_SUCCESS);
+    }
+  }
+}
+
+#define DM_TDP_LEVEL 25
+
+void TestDevMgmtApiSyncCmds::setAndGetModuleStaticTDPLevel(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  uint8_t cur_tdp_level;
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    const uint32_t input_size = sizeof(uint8_t);
+    char input_buff[input_size] = {DM_TDP_LEVEL};
+    const uint32_t set_output_size = sizeof(uint32_t);
+    char set_output_buff[set_output_size] = {0};
+    const uint32_t get_output_size = sizeof(uint8_t);
+    char get_output_buff[get_output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_STATIC_TDP_LEVEL, nullptr, 0,
+                                get_output_buff, get_output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    /* save current TDP level*/
+    cur_tdp_level = static_cast<int>(get_output_buff[0]);
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_STATIC_TDP_LEVEL, input_buff,
+                                input_size, set_output_buff, set_output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      EXPECT_EQ((uint32_t)set_output_buff[0], device_mgmt_api::DM_STATUS_SUCCESS);
+    }
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_STATIC_TDP_LEVEL, nullptr, 0,
+                                get_output_buff, get_output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      uint8_t tdp_level = get_output_buff[0];
+      EXPECT_EQ(tdp_level, DM_TDP_LEVEL);
+    }
+
+    /* Restore TDP level */
+    input_buff[0] = (char)cur_tdp_level;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_STATIC_TDP_LEVEL, input_buff,
+                                input_size, set_output_buff, set_output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::setAndGetModuleTemperatureThreshold(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    const uint32_t input_size = sizeof(device_mgmt_api::temperature_threshold_t);
+    char input_buff[input_size] = {(uint8_t)56};
+
+    // Device rsp will be of type device_mgmt_default_rsp_t and payload is uint32_t
+    const uint32_t set_output_size = sizeof(uint32_t);
+    char set_output_buff[set_output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    const uint32_t get_output_size = sizeof(device_mgmt_api::temperature_threshold_t);
+    char get_output_buff[get_output_size] = {0};
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_TEMPERATURE_THRESHOLDS, nullptr,
+                                0, get_output_buff, get_output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    device_mgmt_api::temperature_threshold_t* temperature_threshold =
+      (device_mgmt_api::temperature_threshold_t*)get_output_buff;
+    uint8_t temp_val = temperature_threshold->sw_temperature_c;
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_TEMPERATURE_THRESHOLDS,
+                                input_buff, input_size, set_output_buff, set_output_size, hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      EXPECT_EQ(set_output_buff[0], device_mgmt_api::DM_STATUS_SUCCESS);
+    }
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_TEMPERATURE_THRESHOLDS, nullptr,
+                                0, get_output_buff, get_output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      device_mgmt_api::temperature_threshold_t* temperature_threshold =
+        (device_mgmt_api::temperature_threshold_t*)get_output_buff;
+      EXPECT_EQ(temperature_threshold->sw_temperature_c, 56);
+
+      /* Restore temperature threshold */
+      input_buff[0] = temp_val;
+      ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_TEMPERATURE_THRESHOLDS,
+                                  input_buff, input_size, set_output_buff, set_output_size, hst_latency.get(),
+                                  dev_latency.get(), DURATION2MS(end - Clock::now())),
+                device_mgmt_api::DM_STATUS_SUCCESS);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModuleResidencyThrottleState(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+  std::string throttle_state_name[7] = {"POWER_THROTTLE_STATE_POWER_IDLE",   "POWER_THROTTLE_STATE_THERMAL_IDLE",
+                                        "POWER_THROTTLE_STATE_POWER_UP",     "POWER_THROTTLE_STATE_POWER_DOWN",
+                                        "POWER_THROTTLE_STATE_THERMAL_DOWN", "POWER_THROTTLE_STATE_POWER_SAFE",
+                                        "POWER_THROTTLE_STATE_THERMAL_SAFE"};
+
+  const uint32_t output_size = sizeof(device_mgmt_api::residency_t);
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    for (device_mgmt_api::power_throttle_state_e throttle_state = device_mgmt_api::POWER_THROTTLE_STATE_POWER_UP;
+         throttle_state <= device_mgmt_api::POWER_THROTTLE_STATE_THERMAL_SAFE; throttle_state++) {
+      const uint32_t input_size = sizeof(device_mgmt_api::power_throttle_state_e);
+      const char input_buff[input_size] = {(char)throttle_state};
+      char output_buff[output_size] = {0};
+      auto hst_latency = std::make_unique<uint32_t>();
+      auto dev_latency = std::make_unique<uint64_t>();
+
+      ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_RESIDENCY_THROTTLE_STATES,
+                                  input_buff, input_size, output_buff, output_size, hst_latency.get(),
+                                  dev_latency.get(), DURATION2MS(end - Clock::now())),
+                device_mgmt_api::DM_STATUS_SUCCESS);
+      DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+      // Skip printing if loopback driver
+      if (getTestTarget() != Target::Loopback) {
+        // Note: Throttle time could vary. So there cannot be expected value for throttle time in the test
+        device_mgmt_api::residency_t* residency = (device_mgmt_api::residency_t*)output_buff;
+        printf("throttle_residency %s (in usecs):\n", throttle_state_name[throttle_state].c_str());
+        printf("\tcumulative: %ld\n", residency->cumulative);
+        printf("\taverage: %ld\n", residency->average);
+        printf("\tmaximum: %ld\n", residency->maximum);
+        printf("\tminimum: %ld\n", residency->minimum);
+      }
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModuleUptime(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::module_uptime_t);
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_UPTIME, nullptr, 0, output_buff,
+                                output_size, hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip printing if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      device_mgmt_api::module_uptime_t* module_uptime = (device_mgmt_api::module_uptime_t*)output_buff;
+      printf("Module uptime (day:hours:mins): %d:%d:%d\r\n", module_uptime->day, module_uptime->hours,
+             module_uptime->mins);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModulePower(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::module_power_t);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_POWER, nullptr, 0, output_buff,
+                                output_size, hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver or SysEMU
+    if (!targetInList({Target::Loopback, Target::SysEMU})) {
+      // Note: Module power could vary. So there cannot be expected value for Module power in the test
+      device_mgmt_api::module_power_t* module_power = (device_mgmt_api::module_power_t*)output_buff;
+      float power = POWER_10MW_TO_W((float)module_power->power);
+      DV_LOG(INFO) << "Module power (in Watts): \n" << power;
+
+      EXPECT_NE(module_power->power, 0);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getAsicVoltage(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    device_mgmt_api::asic_voltage_t* moduleVoltage;
+    const uint32_t output_size = sizeof(device_mgmt_api::asic_voltage_t);
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_VOLTAGE, nullptr, 0, output_buff,
+                                output_size, hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+    device_mgmt_api::asic_voltage_t* voltages = (device_mgmt_api::asic_voltage_t*)output_buff;
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received DDR={} mV", deviceIdx, BIN2VOLTAGE(voltages->ddr, 250, 5, 1));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received L2CACHE={} mV", deviceIdx,
+                                BIN2VOLTAGE(voltages->l2_cache, 250, 5, 1));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received MAXION={} mV", deviceIdx,
+                                BIN2VOLTAGE(voltages->maxion, 250, 5, 1));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received MINION={} mV", deviceIdx,
+                                BIN2VOLTAGE(voltages->minion, 250, 5, 1));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received PShire={} mV", deviceIdx,
+                                BIN2VOLTAGE(voltages->pshire_0p75, 600, 125, 10));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received NOC={} mV", deviceIdx, BIN2VOLTAGE(voltages->noc, 250, 5, 1));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received IOShire={} mV", deviceIdx,
+                                BIN2VOLTAGE(voltages->ioshire_0p75, 600, 625, 100));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received VDDQ={} mV", deviceIdx, BIN2VOLTAGE(voltages->vddq, 250, 10, 1));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received VDDQLP={} mV", deviceIdx,
+                                BIN2VOLTAGE(voltages->vddqlp, 250, 10, 1));
+    // Skip validation if loopback driver or SysEMU
+    if (!targetInList({Target::Loopback, Target::SysEMU})) {
+      // Expect that output_buff is non-zero
+      EXPECT_TRUE(
+        std::any_of(output_buff, output_buff + output_size, [](unsigned char const byte) { return byte != 0; }));
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModuleVoltage(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    device_mgmt_api::module_voltage_t* moduleVoltage;
+    const uint32_t output_size = sizeof(device_mgmt_api::module_voltage_t);
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_VOLTAGE, nullptr, 0, output_buff,
+                                output_size, hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+    device_mgmt_api::module_voltage_t* voltages = (device_mgmt_api::module_voltage_t*)output_buff;
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received DDR={} mV", deviceIdx, BIN2VOLTAGE(voltages->ddr, 250, 5, 1));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received L2CACHE={} mV", deviceIdx,
+                                BIN2VOLTAGE(voltages->l2_cache, 250, 5, 1));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received MAXION={} mV", deviceIdx,
+                                BIN2VOLTAGE(voltages->maxion, 250, 5, 1));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received MINION={} mV", deviceIdx,
+                                BIN2VOLTAGE(voltages->minion, 250, 5, 1));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received PCIE={} mV", deviceIdx,
+                                BIN2VOLTAGE(voltages->pcie, 600, 125, 10));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received NOC={} mV", deviceIdx, BIN2VOLTAGE(voltages->noc, 250, 5, 1));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received PCIE_LOGIC={} mV", deviceIdx,
+                                BIN2VOLTAGE(voltages->pcie_logic, 600, 625, 100));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received VDDQ={} mV", deviceIdx, BIN2VOLTAGE(voltages->vddq, 250, 10, 1));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received VDDQLP={} mV", deviceIdx,
+                                BIN2VOLTAGE(voltages->vddqlp, 250, 10, 1));
+    // Skip validation if loopback driver or SysEMU
+    if (!targetInList({Target::Loopback, Target::SysEMU})) {
+      // Expect that output_buff is non-zero
+      EXPECT_TRUE(
+        std::any_of(output_buff, output_buff + output_size, [](unsigned char const byte) { return byte != 0; }));
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::setAndGetModuleVoltage(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+  double voltagePercentDrop = 0.0;
+
+  auto setModuleVoltages = [&](int deviceIdx, const device_mgmt_api::module_voltage_t& voltages) {
+    const uint32_t input_size = sizeof(device_mgmt_api::module_e) + sizeof(uint8_t);
+    char input_buff[input_size];
+    DV_LOG(INFO) << fmt::format("Device[{}]: Setting DDR={} mV", deviceIdx, BIN2VOLTAGE(voltages.ddr, 250, 5, 1));
+    input_buff[0] = (char)device_mgmt_api::MODULE_DDR;
+    input_buff[1] = (char)(voltages.ddr);
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    if (dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_VOLTAGE, input_buff, input_size,
+                          nullptr, 0, hst_latency.get(), dev_latency.get(),
+                          DURATION2MS(end - Clock::now())) != device_mgmt_api::DM_STATUS_SUCCESS) {
+      return false;
+    }
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+    DV_LOG(INFO) << fmt::format("Device[{}]: Setting L2CACHE={} mV", deviceIdx,
+                                BIN2VOLTAGE(voltages.l2_cache, 250, 5, 1));
+    input_buff[0] = (char)device_mgmt_api::MODULE_L2CACHE;
+    input_buff[1] = (char)(voltages.l2_cache);
+    if (dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_VOLTAGE, input_buff, input_size,
+                          nullptr, 0, hst_latency.get(), dev_latency.get(),
+                          DURATION2MS(end - Clock::now())) != device_mgmt_api::DM_STATUS_SUCCESS) {
+      return false;
+    }
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+    DV_LOG(INFO) << fmt::format("Device[{}]: Setting MAXION={} mV", deviceIdx, BIN2VOLTAGE(voltages.maxion, 250, 5, 1));
+    input_buff[0] = (char)device_mgmt_api::MODULE_MAXION;
+    input_buff[1] = (char)(voltages.maxion);
+    if (dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_VOLTAGE, input_buff, input_size,
+                          nullptr, 0, hst_latency.get(), dev_latency.get(),
+                          DURATION2MS(end - Clock::now())) != device_mgmt_api::DM_STATUS_SUCCESS) {
+      return false;
+    }
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+    DV_LOG(INFO) << fmt::format("Device[{}]: Setting MINION={} mV", deviceIdx, BIN2VOLTAGE(voltages.minion, 250, 5, 1));
+    input_buff[0] = (char)device_mgmt_api::MODULE_MINION;
+    input_buff[1] = (char)(voltages.minion);
+    if (dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_VOLTAGE, input_buff, input_size,
+                          nullptr, 0, hst_latency.get(), dev_latency.get(),
+                          DURATION2MS(end - Clock::now())) != device_mgmt_api::DM_STATUS_SUCCESS) {
+      return false;
+    }
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+    DV_LOG(INFO) << fmt::format("Device[{}]: Setting PCIE={} mV", deviceIdx, BIN2VOLTAGE(voltages.pcie, 600, 125, 10));
+    input_buff[0] = (char)device_mgmt_api::MODULE_PCIE;
+    input_buff[1] = (char)(voltages.pcie);
+    if (dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_VOLTAGE, input_buff, input_size,
+                          nullptr, 0, hst_latency.get(), dev_latency.get(),
+                          DURATION2MS(end - Clock::now())) != device_mgmt_api::DM_STATUS_SUCCESS) {
+      return false;
+    }
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+    DV_LOG(INFO) << fmt::format("Device[{}]: Setting NOC={} mV", deviceIdx, BIN2VOLTAGE(voltages.noc, 250, 5, 1));
+    input_buff[0] = (char)device_mgmt_api::MODULE_NOC;
+    input_buff[1] = (char)(voltages.noc);
+    if (dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_VOLTAGE, input_buff, input_size,
+                          nullptr, 0, hst_latency.get(), dev_latency.get(),
+                          DURATION2MS(end - Clock::now())) != device_mgmt_api::DM_STATUS_SUCCESS) {
+      return false;
+    }
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+    DV_LOG(INFO) << fmt::format("Device[{}]: Setting PCIE_LOGIC={} mV", deviceIdx,
+                                BIN2VOLTAGE(voltages.pcie_logic, 600, 625, 100));
+    input_buff[0] = (char)device_mgmt_api::MODULE_PCIE_LOGIC;
+    input_buff[1] = (char)(voltages.pcie_logic);
+    if (dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_VOLTAGE, input_buff, input_size,
+                          nullptr, 0, hst_latency.get(), dev_latency.get(),
+                          DURATION2MS(end - Clock::now())) != device_mgmt_api::DM_STATUS_SUCCESS) {
+      return false;
+    }
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+    DV_LOG(INFO) << fmt::format("Device[{}]: Setting VDDQ={} mV", deviceIdx, BIN2VOLTAGE(voltages.vddq, 250, 10, 1));
+    input_buff[0] = (char)device_mgmt_api::MODULE_VDDQ;
+    input_buff[1] = (char)(voltages.vddq);
+    if (dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_VOLTAGE, input_buff, input_size,
+                          nullptr, 0, hst_latency.get(), dev_latency.get(),
+                          DURATION2MS(end - Clock::now())) != device_mgmt_api::DM_STATUS_SUCCESS) {
+      return false;
+    }
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+    DV_LOG(INFO) << fmt::format("Device[{}]: Setting VDDQLP={} mV", deviceIdx,
+                                BIN2VOLTAGE(voltages.vddqlp, 250, 10, 1));
+    input_buff[0] = (char)device_mgmt_api::MODULE_VDDQLP;
+    input_buff[1] = (char)(voltages.vddqlp);
+    if (dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_VOLTAGE, input_buff, input_size,
+                          nullptr, 0, hst_latency.get(), dev_latency.get(),
+                          DURATION2MS(end - Clock::now())) != device_mgmt_api::DM_STATUS_SUCCESS) {
+      return false;
+    }
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+    return true;
+  };
+
+  auto getModuleVoltages = [&](int deviceIdx) -> std::optional<device_mgmt_api::module_voltage_t> {
+    device_mgmt_api::module_voltage_t* moduleVoltage;
+    const uint32_t output_size = sizeof(device_mgmt_api::module_voltage_t);
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    if (dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_VOLTAGE, nullptr, 0, output_buff,
+                          output_size, hst_latency.get(), dev_latency.get(),
+                          DURATION2MS(end - Clock::now())) != device_mgmt_api::DM_STATUS_SUCCESS) {
+      return std::nullopt;
+    }
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+    device_mgmt_api::module_voltage_t* voltages = (device_mgmt_api::module_voltage_t*)output_buff;
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received DDR={} mV", deviceIdx, BIN2VOLTAGE(voltages->ddr, 250, 5, 1));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received L2CACHE={} mV", deviceIdx,
+                                BIN2VOLTAGE(voltages->l2_cache, 250, 5, 1));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received MAXION={} mV", deviceIdx,
+                                BIN2VOLTAGE(voltages->maxion, 250, 5, 1));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received MINION={} mV", deviceIdx,
+                                BIN2VOLTAGE(voltages->minion, 250, 5, 1));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received PCIE={} mV", deviceIdx,
+                                BIN2VOLTAGE(voltages->pcie, 600, 125, 10));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received NOC={} mV", deviceIdx, BIN2VOLTAGE(voltages->noc, 250, 5, 1));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received PCIE_LOGIC={} mV", deviceIdx,
+                                BIN2VOLTAGE(voltages->pcie_logic, 600, 625, 100));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received VDDQ={} mV", deviceIdx, BIN2VOLTAGE(voltages->vddq, 250, 10, 1));
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received VDDQLP={} mV", deviceIdx,
+                                BIN2VOLTAGE(voltages->vddqlp, 250, 10, 1));
+
+    return *voltages;
+  };
+
+  auto percentVoltageChange = [](uint8_t newBinVoltage, uint8_t refBinVoltage, uint32_t base, uint32_t multiplier,
+                                 uint32_t divider) {
+    auto newVoltage = static_cast<double>(BIN2VOLTAGE(newBinVoltage, base, multiplier, divider));
+    auto refVoltage = static_cast<double>(BIN2VOLTAGE(refBinVoltage, base, multiplier, divider));
+    return std::abs(newVoltage - refVoltage) / refVoltage;
+  };
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    // Get default voltages
+    auto container = getModuleVoltages(deviceIdx);
+    ASSERT_TRUE(container.has_value()) << "getModuleVoltages() failed!";
+    auto defaultVoltages = container.value();
+
+    // Set test voltages (5 steps (25mV/30mV) greater than default)
+    device_mgmt_api::module_voltage_t testVoltages;
+    testVoltages.ddr = defaultVoltages.ddr + 5;
+    testVoltages.l2_cache = defaultVoltages.l2_cache + 5;
+    testVoltages.maxion = defaultVoltages.maxion + 5;
+    testVoltages.minion = defaultVoltages.minion + 5;
+    testVoltages.pcie = defaultVoltages.pcie + 5;
+    testVoltages.noc = defaultVoltages.noc + 5;
+    testVoltages.pcie_logic = defaultVoltages.pcie_logic + 5;
+    testVoltages.vddq = defaultVoltages.vddq + 1;
+    testVoltages.vddqlp = defaultVoltages.vddqlp + 1;
+    ASSERT_TRUE(setModuleVoltages(deviceIdx, testVoltages)) << "setModuleVoltages() failed!";
+
+    // Skip validation if loopback driver or SysEMU
+    if (!targetInList({Target::Loopback, Target::SysEMU})) {
+      for (auto retry = 0; retry < 3; retry++) {
+        // Wait for voltages to settle
+        std::this_thread::sleep_for(std::chrono::milliseconds(500));
+        // Validate test voltages
+        container = getModuleVoltages(deviceIdx);
+        ASSERT_TRUE(container.has_value()) << "getModuleVoltages() failed!";
+        if (memcmp(&defaultVoltages, &container.value(), sizeof(defaultVoltages)) != 0) {
+          break;
+        }
+      }
+      EXPECT_LE(percentVoltageChange(container.value().ddr, testVoltages.ddr, 250, 5, 1), voltagePercentDrop)
+        << "Unable to set DDR test voltage";
+      EXPECT_LE(percentVoltageChange(container.value().l2_cache, testVoltages.l2_cache, 250, 5, 1), voltagePercentDrop)
+        << "Unable to set L2CACHE test voltage";
+      EXPECT_LE(percentVoltageChange(container.value().maxion, testVoltages.maxion, 250, 5, 1), voltagePercentDrop)
+        << "Unable to set MAXION test voltage";
+      EXPECT_LE(percentVoltageChange(container.value().minion, testVoltages.minion, 250, 5, 1), voltagePercentDrop)
+        << "Unable to set MINION test voltage";
+      EXPECT_LE(percentVoltageChange(container.value().pcie, testVoltages.pcie, 600, 125, 10), voltagePercentDrop)
+        << "Unable to set PCIE test voltage";
+      EXPECT_LE(percentVoltageChange(container.value().noc, testVoltages.noc, 250, 5, 1), voltagePercentDrop)
+        << "Unable to set NOC test voltage";
+      EXPECT_LE(percentVoltageChange(container.value().pcie_logic, testVoltages.pcie_logic, 600, 625, 100),
+                voltagePercentDrop)
+        << "Unable to set PCIE_LOGIC test voltage";
+      EXPECT_LE(percentVoltageChange(container.value().vddq, testVoltages.vddq, 250, 10, 1), voltagePercentDrop)
+        << "Unable to set VDDQ test voltage";
+      EXPECT_LE(percentVoltageChange(container.value().vddqlp, testVoltages.vddqlp, 250, 10, 1), voltagePercentDrop)
+        << "Unable to set VDDQLP test voltage";
+      EXPECT_NE(memcmp(&defaultVoltages, &container.value(), sizeof(defaultVoltages)), 0)
+        << "No changes in voltage after SET_MODULE_VOLTAGE command";
+    }
+
+    // Revert back to original voltages
+    ASSERT_TRUE(setModuleVoltages(deviceIdx, defaultVoltages)) << "setModuleVoltages() failed";
+
+    // Skip validation if loopback driver or SysEMU
+    if (!targetInList({Target::Loopback, Target::SysEMU})) {
+      for (auto retry = 0; retry < 3; retry++) {
+        // Wait for voltages to settle
+        std::this_thread::sleep_for(std::chrono::milliseconds(500));
+        // Validate default voltages are set
+        container = getModuleVoltages(deviceIdx);
+        ASSERT_TRUE(container.has_value()) << "getModuleVoltages() failed!";
+        if (memcmp(&testVoltages, &container.value(), sizeof(testVoltages)) != 0) {
+          break;
+        }
+      }
+      EXPECT_LE(percentVoltageChange(container.value().ddr, defaultVoltages.ddr, 250, 5, 1), voltagePercentDrop)
+        << "Unable to set DDR default voltage";
+      EXPECT_LE(percentVoltageChange(container.value().l2_cache, defaultVoltages.l2_cache, 250, 5, 1),
+                voltagePercentDrop)
+        << "Unable to set L2CACHE default voltage";
+      EXPECT_LE(percentVoltageChange(container.value().maxion, defaultVoltages.maxion, 250, 5, 1), voltagePercentDrop)
+        << "Unable to set MAXION default voltage";
+      EXPECT_LE(percentVoltageChange(container.value().minion, defaultVoltages.minion, 250, 5, 1), voltagePercentDrop)
+        << "Unable to set MINION default voltage";
+      EXPECT_LE(percentVoltageChange(container.value().pcie, defaultVoltages.pcie, 600, 125, 10), voltagePercentDrop)
+        << "Unable to set PCIE default voltage";
+      EXPECT_LE(percentVoltageChange(container.value().noc, defaultVoltages.noc, 250, 5, 1), voltagePercentDrop)
+        << "Unable to set NOC default voltage";
+      EXPECT_LE(percentVoltageChange(container.value().pcie_logic, defaultVoltages.pcie_logic, 600, 625, 100),
+                voltagePercentDrop)
+        << "Unable to set PCIE_LOGIC default voltage";
+      EXPECT_LE(percentVoltageChange(container.value().vddq, defaultVoltages.vddq, 250, 10, 1), voltagePercentDrop)
+        << "Unable to set VDDQ test voltage";
+      EXPECT_LE(percentVoltageChange(container.value().vddqlp, defaultVoltages.vddqlp, 250, 10, 1), voltagePercentDrop)
+        << "Unable to set VDDQLP test voltage";
+      EXPECT_NE(memcmp(&testVoltages, &container.value(), sizeof(testVoltages)), 0)
+        << "No changes in voltage after SET_MODULE_VOLTAGE command";
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModuleCurrentTemperature(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::current_temperature_t);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_CURRENT_TEMPERATURE, nullptr, 0,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      device_mgmt_api::current_temperature_t* cur_temp = (device_mgmt_api::current_temperature_t*)output_buff;
+
+      printf(" PMIC SYS current temperature (in C): %d\r\n", cur_temp->pmic_sys);
+      printf(" IOSHIRE current temperature (in C): %d\r\n", cur_temp->ioshire_current);
+      printf(" IOSHIRE low temperature (in C): %d\r\n", cur_temp->ioshire_low);
+      printf(" IOSHIRE high temperature (in C): %d\r\n", cur_temp->ioshire_high);
+      printf(" MINSHIRE average temperature (in C): %d\r\n", cur_temp->minshire_avg);
+      printf(" MINSHIRE low temperature (in C): %d\r\n", cur_temp->minshire_low);
+      printf(" MINSHIRE high temperature (in C): %d\r\n", cur_temp->minshire_high);
+
+      EXPECT_NE(cur_temp->pmic_sys, 0);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModuleMaxTemperature(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::max_temperature_t);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MAX_TEMPERATURE, nullptr, 0,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip printing if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      device_mgmt_api::max_temperature_t* max_temperature = (device_mgmt_api::max_temperature_t*)output_buff;
+
+      // Note: Module's Max Temperature could vary. So there cannot be expected value for max temperature in the test
+      printf("Module's Max Temperature: %d\n", max_temperature->max_temperature_c);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModuleMaxMemoryErrors(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::max_ecc_count_t);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MAX_MEMORY_ERROR, nullptr, 0,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip printing if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      device_mgmt_api::max_ecc_count_t* max_ecc_count = (device_mgmt_api::max_ecc_count_t*)output_buff;
+
+      // Note: ECC count could vary. So there cannot be expected value for max_ecc_count in the test
+      printf("Max ECC Count: %d\n", max_ecc_count->count);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModuleMaxDDRBW(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::max_dram_bw_t);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MAX_DDR_BW, nullptr, 0,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModuleResidencyPowerState(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+  std::string power_state_name[4] = {"POWER_STATE_MAX_POWER", "POWER_STATE_MANAGED_POWER", "POWER_STATE_SAFE_POWER",
+                                     "POWER_STATE_LOW_POWER"};
+
+  const uint32_t output_size = sizeof(device_mgmt_api::residency_t);
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    for (device_mgmt_api::power_state_e power_state = device_mgmt_api::POWER_STATE_MAX_POWER;
+         power_state <= device_mgmt_api::POWER_STATE_SAFE_POWER; power_state++) {
+      const uint32_t input_size = sizeof(device_mgmt_api::power_state_e);
+      const char input_buff[input_size] = {(char)power_state};
+      char output_buff[output_size] = {0};
+      auto hst_latency = std::make_unique<uint32_t>();
+      auto dev_latency = std::make_unique<uint64_t>();
+
+      ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_RESIDENCY_POWER_STATES,
+                                  input_buff, input_size, output_buff, output_size, hst_latency.get(),
+                                  dev_latency.get(), DURATION2MS(end - Clock::now())),
+                device_mgmt_api::DM_STATUS_SUCCESS);
+      DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+      // Skip printing if loopback driver
+      if (getTestTarget() != Target::Loopback) {
+        // Note: Throttle time could vary. So there cannot be expected value for throttle time in the test
+        device_mgmt_api::residency_t* residency = (device_mgmt_api::residency_t*)output_buff;
+        printf("power_residency %s (in usecs):\n", power_state_name[power_state].c_str());
+        printf("\tcumulative: %ld\n", residency->cumulative);
+        printf("\taverage: %ld\n", residency->average);
+        printf("\tmaximum: %ld\n", residency->maximum);
+        printf("\tminimum: %ld\n", residency->minimum);
+      }
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::setAndGetModuleFrequency(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto setMinionAndNocFrequencies = [&](int deviceIdx,
+                                        const std::pair<uint16_t /* minionFreq */, uint16_t /* nocFreq */>& freqs) {
+    DV_LOG(INFO) << fmt::format("Device[{}]: Setting Minion={}, NOC={} MHz Frequencies.", deviceIdx, freqs.first,
+                                freqs.second);
+    for (device_mgmt_api::pll_id_e pll_id = device_mgmt_api::PLL_ID_NOC_PLL;
+         pll_id <= device_mgmt_api::PLL_ID_MINION_PLL; pll_id++) {
+      uint16_t pll_freq = (pll_id == device_mgmt_api::PLL_ID_NOC_PLL) ? freqs.second : freqs.first;
+      const uint32_t input_size =
+        sizeof(uint16_t) + sizeof(device_mgmt_api::pll_id_e) + sizeof(device_mgmt_api::use_step_e);
+      char input_buff[input_size];
+      input_buff[0] = (char)(pll_freq & 0xff);
+      input_buff[1] = (char)((pll_freq >> 8) & 0xff);
+      input_buff[2] = (char)pll_id;
+      input_buff[3] = (char)device_mgmt_api::USE_STEP_CLOCK_TRUE;
+      auto hst_latency = std::make_unique<uint32_t>();
+      auto dev_latency = std::make_unique<uint64_t>();
+      if (dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_FREQUENCY, input_buff, input_size, nullptr,
+                            0, hst_latency.get(), dev_latency.get(),
+                            DURATION2MS(end - Clock::now())) != device_mgmt_api::DM_STATUS_SUCCESS) {
+        return false;
+      }
+      DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+    }
+    return true;
+  };
+
+  auto getMinionAndNocFrequencies = [&](int deviceIdx) -> std::optional<std::pair<uint16_t, uint16_t>> {
+    const uint32_t output_size = sizeof(device_mgmt_api::asic_frequencies_t);
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    if (dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_FREQUENCIES, nullptr, 0, output_buff,
+                          output_size, hst_latency.get(), dev_latency.get(),
+                          DURATION2MS(end - Clock::now())) != device_mgmt_api::DM_STATUS_SUCCESS) {
+      return std::nullopt;
+    }
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+    auto* asic_frequencies = reinterpret_cast<const device_mgmt_api::asic_frequencies_t*>(output_buff);
+    DV_LOG(INFO) << fmt::format("Device[{}]: Received Frequencies: Minion={}, NOC={} MHz.", deviceIdx,
+                                static_cast<uint16_t>(asic_frequencies->minion_shire_mhz),
+                                static_cast<uint16_t>(asic_frequencies->noc_mhz));
+    return std::make_pair<uint16_t, uint16_t>(asic_frequencies->minion_shire_mhz, asic_frequencies->noc_mhz);
+  };
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    // Get current frequencies
+    auto origFreqs = getMinionAndNocFrequencies(deviceIdx);
+    ASSERT_TRUE(origFreqs.has_value()) << "Unable to get current Minion and NOC Frequencies!";
+
+    std::vector<std::pair<uint16_t, uint16_t>> testFreqsList = {{400, 200}, {500, 250}, {600, 300}};
+    for (auto testFreqs : testFreqsList) {
+      // Set test frequencies
+      ASSERT_TRUE(setMinionAndNocFrequencies(deviceIdx, testFreqs))
+        << fmt::format("Unable to set Minion={} MHz and NOC={} MHz Frequencies!", testFreqs.first, testFreqs.second);
+      auto freqs = getMinionAndNocFrequencies(deviceIdx);
+      ASSERT_TRUE(freqs.has_value()) << "Unable to get test Minion and NOC Frequencies!";
+      EXPECT_EQ(freqs.value().first, testFreqs.first)
+        << fmt::format("Couldn't set test Minion={} MHz Frequency!", testFreqs.first);
+      EXPECT_EQ(freqs.value().second, testFreqs.second)
+        << fmt::format("Couldn't set test NOC={} Frequency!", testFreqs.second);
+    }
+
+    // Revert back to original frequencies
+    ASSERT_TRUE(setMinionAndNocFrequencies(deviceIdx, origFreqs.value())) << fmt::format(
+      "Unable to set Minion={} MHz and NOC={} MHz Frequencies!", origFreqs.value().first, origFreqs.value().second);
+    auto freqs = getMinionAndNocFrequencies(deviceIdx);
+    ASSERT_TRUE(freqs.has_value()) << "Unable to get current Minion and NOC Frequencies!";
+    EXPECT_EQ(freqs.value().first, origFreqs.value().first)
+      << fmt::format("Couldn't revert to original Minion={} Frequency!", origFreqs.value().first);
+    EXPECT_EQ(freqs.value().second, origFreqs.value().second)
+      << fmt::format("Couldn't revert to original NOC={} Frequency!", origFreqs.value().second);
+  }
+}
+
+void TestDevMgmtApiSyncCmds::setAndGetDDRECCThresholdCount(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    const uint32_t input_size = sizeof(uint8_t);
+    const char input_buff[input_size] = {10};
+
+    // Device rsp will be of type device_mgmt_default_rsp_t and payload is uint32_t
+    const uint32_t output_size = sizeof(uint32_t);
+    char output_buff[output_size] = {0};
+
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_DDR_ECC_COUNT, input_buff, input_size,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      EXPECT_EQ(output_buff[0], device_mgmt_api::DM_STATUS_SUCCESS);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::setAndGetSRAMECCThresholdCount(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    const uint32_t input_size = sizeof(uint8_t);
+    const char input_buff[input_size] = {20};
+
+    // Device rsp will be of type device_mgmt_default_rsp_t and payload is uint32_t
+    const uint32_t output_size = sizeof(uint32_t);
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_SRAM_ECC_COUNT, input_buff, input_size,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      EXPECT_EQ(output_buff[0], device_mgmt_api::DM_STATUS_SUCCESS);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::setAndGetPCIEECCThresholdCount(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    const uint32_t input_size = sizeof(uint8_t);
+    const char input_buff[input_size] = {30};
+
+    // Device rsp will be of type device_mgmt_default_rsp_t and payload is uint32_t
+    const uint32_t output_size = sizeof(uint32_t);
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_PCIE_ECC_COUNT, input_buff, input_size,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      EXPECT_EQ(output_buff[0], device_mgmt_api::DM_STATUS_SUCCESS);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getPCIEECCUECCCount(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::errors_count_t);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_PCIE_ECC_UECC, nullptr, 0,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      device_mgmt_api::errors_count_t* errors_count = (device_mgmt_api::errors_count_t*)output_buff;
+
+      EXPECT_EQ(errors_count->ecc, 0);
+      EXPECT_EQ(errors_count->uecc, 0);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getDDRECCUECCCount(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::errors_count_t);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_DDR_ECC_UECC, nullptr, 0,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      device_mgmt_api::errors_count_t* errors_count = (device_mgmt_api::errors_count_t*)output_buff;
+
+      EXPECT_EQ(errors_count->ecc, 0);
+      EXPECT_EQ(errors_count->uecc, 0);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getSRAMECCUECCCount(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::errors_count_t);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_SRAM_ECC_UECC, nullptr, 0,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      device_mgmt_api::errors_count_t* errors_count = (device_mgmt_api::errors_count_t*)output_buff;
+
+      EXPECT_EQ(errors_count->ecc, 0);
+      EXPECT_EQ(errors_count->uecc, 0);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getDDRBWCounter(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::dram_bw_counter_t);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_DDR_BW_COUNTER, nullptr, 0,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::setPCIELinkSpeed(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    const uint32_t input_size = sizeof(device_mgmt_api::pcie_link_speed_e);
+    const char input_buff[input_size] = {device_mgmt_api::PCIE_LINK_SPEED_GEN3};
+
+    // Device rsp will be of type device_mgmt_default_rsp_t and payload is uint32_t
+    const uint32_t output_size = sizeof(uint32_t);
+    char output_buff[output_size] = {0};
+
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_PCIE_MAX_LINK_SPEED, input_buff,
+                                input_size, output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      EXPECT_EQ(output_buff[0], device_mgmt_api::DM_STATUS_SUCCESS);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::setPCIELaneWidth(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto setLaneWidth = [&](int deviceIdx, const device_mgmt_api::pcie_lane_w_split_e laneWidth) {
+    std::array<char, sizeof(device_mgmt_api::pcie_lane_w_split_e)> input_buff;
+    memcpy(input_buff.data(), &laneWidth, input_buff.size());
+    DV_LOG(INFO) << fmt::format("Device[{}]: Setting Lane Width x{}", deviceIdx,
+                                laneWidth == device_mgmt_api::PCIE_LANE_W_SPLIT_x8 ? 8 : 4);
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    if (dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_PCIE_LANE_WIDTH, input_buff.data(),
+                          input_buff.size(), nullptr, 0, hst_latency.get(), dev_latency.get(),
+                          DURATION2MS(end - Clock::now())) != device_mgmt_api::DM_STATUS_SUCCESS) {
+      return false;
+    }
+    DV_LOG(INFO) << fmt::format("Service Request Completed for Device: {}", deviceIdx);
+    return true;
+  };
+
+  auto getLaneWidth = [&](int deviceIdx) -> std::optional<device_mgmt_api::pcie_lane_w_split_e> {
+    auto laneWidth =
+      std::stoi(devLayer_->getDeviceAttribute(deviceIdx, "max_link_width")); // available for silicon only
+    if (laneWidth == 4) {
+      return device_mgmt_api::PCIE_LANE_W_SPLIT_x4;
+    } else if (laneWidth == 8) {
+      return device_mgmt_api::PCIE_LANE_W_SPLIT_x8;
+    }
+    return std::nullopt;
+  };
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    device_mgmt_api::pcie_lane_w_split_e defaultLaneWidth;
+    device_mgmt_api::pcie_lane_w_split_e testLaneWidth;
+    if (getTestTarget() == Target::Silicon) {
+      auto container = getLaneWidth(deviceIdx);
+      if (!container.has_value()) {
+        DV_LOG(INFO) << fmt::format("Device[{}]: The default lane width is not restorable, skipping the test",
+                                    deviceIdx);
+        continue;
+      }
+      defaultLaneWidth = container.value();
+    } else {
+      defaultLaneWidth = device_mgmt_api::PCIE_LANE_W_SPLIT_x4;
+    }
+
+    if (defaultLaneWidth == device_mgmt_api::PCIE_LANE_W_SPLIT_x4) {
+      testLaneWidth = device_mgmt_api::PCIE_LANE_W_SPLIT_x8;
+    } else {
+      testLaneWidth = device_mgmt_api::PCIE_LANE_W_SPLIT_x4;
+    }
+
+    // Set test lane width
+    ASSERT_TRUE(setLaneWidth(deviceIdx, testLaneWidth)) << fmt::format("Device[{}]: setLaneWidth() failed!", deviceIdx);
+    // Validate on Target::Silicon only
+    if (getTestTarget() == Target::Silicon) {
+      ASSERT_EQ(testLaneWidth, getLaneWidth(deviceIdx).value())
+        << fmt::format("Device[{}]: Failed to set testLaneWidth!", deviceIdx);
+    }
+
+    // Restore default lane width
+    ASSERT_TRUE(setLaneWidth(deviceIdx, defaultLaneWidth))
+      << fmt::format("Device[{}]: setLaneWidth() failed!", deviceIdx);
+    // Validate on Target::Silicon only
+    if (getTestTarget() == Target::Silicon) {
+      ASSERT_EQ(defaultLaneWidth, getLaneWidth(deviceIdx).value())
+        << fmt::format("Device[{}]: Failed to restore defaultLaneWidth!", deviceIdx);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::setPCIERetrainPhy(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    const uint32_t input_size = sizeof(uint8_t);
+    const char input_buff[input_size] = {0};
+
+    // Device rsp will be of type device_mgmt_default_rsp_t and payload is uint32_t
+    const uint32_t output_size = sizeof(uint32_t);
+    char output_buff[output_size] = {0};
+
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_PCIE_RETRAIN_PHY, input_buff, input_size,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      EXPECT_EQ(output_buff[0], device_mgmt_api::DM_STATUS_SUCCESS);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getASICFrequencies(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::asic_frequencies_t);
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_FREQUENCIES, nullptr, 0,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getDRAMBW(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    const uint32_t output_size = sizeof(device_mgmt_api::dram_bw_t);
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_DRAM_BANDWIDTH, nullptr, 0, output_buff,
+                                output_size, hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getDRAMCapacityUtilization(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    const uint32_t output_size = sizeof(device_mgmt_api::percentage_cap_t);
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_DRAM_CAPACITY_UTILIZATION, nullptr, 0,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getASICPerCoreDatapathUtilization(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    // Actual Payload is TBD. So device is currently returning the status of cmd execution
+    const uint32_t output_size = sizeof(uint8_t);
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_PER_CORE_DATAPATH_UTILIZATION,
+                                nullptr, 0, output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      EXPECT_EQ(output_buff[0], device_mgmt_api::DM_STATUS_SUCCESS);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getASICUtilization(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    // Actual Payload is TBD. So device is currently returning the status of cmd execution
+    const uint32_t output_size = sizeof(uint8_t);
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_UTILIZATION, nullptr, 0,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      EXPECT_EQ(output_buff[0], device_mgmt_api::DM_STATUS_SUCCESS);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getASICStalls(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    // Actual Payload is TBD. So device is currently returning the status of cmd execution
+    const uint32_t output_size = sizeof(uint8_t);
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_STALLS, nullptr, 0, output_buff,
+                                output_size, hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      EXPECT_EQ(output_buff[0], device_mgmt_api::DM_STATUS_SUCCESS);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getASICLatency(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    // Actual Payload is TBD. So device is currently returning the status of cmd execution
+    const uint32_t output_size = sizeof(uint8_t);
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_LATENCY, nullptr, 0, output_buff,
+                                output_size, hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      EXPECT_EQ(output_buff[0], device_mgmt_api::DM_STATUS_SUCCESS);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getMMErrorCount(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    const uint32_t output_size = sizeof(device_mgmt_api::mm_error_count_t);
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MM_ERROR_COUNT, nullptr, 0, output_buff,
+                                output_size, hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getFWBootstatus(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    // DM_CMD_GET_FIRMWARE_BOOT_STATUS : Device returns response of type device_mgmt_default_rsp_t.
+    // Payload in response is of type uint32_t
+    const uint32_t output_size = sizeof(uint32_t);
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_FIRMWARE_BOOT_STATUS, nullptr, 0,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip printing and validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      EXPECT_EQ(output_buff[0], 0);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModuleFWRevision(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    const uint32_t output_size = sizeof(device_mgmt_api::firmware_version_t);
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_FIRMWARE_REVISIONS, nullptr, 0,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip printing and validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      printf("output_buff: %.*s\n", output_size, output_buff);
+
+      device_mgmt_api::firmware_version_t* firmware_versions = (device_mgmt_api::firmware_version_t*)output_buff;
+
+      std::stringstream ss;
+      ss << "\nFirmware Versions:" << std::endl;
+      ss << fmt::format("\tbl1_v:   {}.{}.{}", MAJOR_VERSION(firmware_versions->bl1_v),
+                        MINOR_VERSION(firmware_versions->bl1_v), REVISION_VERSION(firmware_versions->bl1_v))
+         << std::endl;
+      ss << fmt::format("\tbl2_v:   {}.{}.{}", MAJOR_VERSION(firmware_versions->bl2_v),
+                        MINOR_VERSION(firmware_versions->bl2_v), REVISION_VERSION(firmware_versions->bl2_v))
+         << std::endl;
+      ss << fmt::format("\tpmic_v: {}.{}.{}", MAJOR_VERSION(firmware_versions->pmic_v),
+                        MINOR_VERSION(firmware_versions->pmic_v), REVISION_VERSION(firmware_versions->pmic_v))
+         << std::endl;
+      ss << fmt::format("\tmm_v:    {}.{}.{}", MAJOR_VERSION(firmware_versions->mm_v),
+                        MINOR_VERSION(firmware_versions->mm_v), REVISION_VERSION(firmware_versions->mm_v))
+         << std::endl;
+      ss << fmt::format("\twm_v:    {}.{}.{}", MAJOR_VERSION(firmware_versions->wm_v),
+                        MINOR_VERSION(firmware_versions->wm_v), REVISION_VERSION(firmware_versions->wm_v))
+         << std::endl;
+      ss << fmt::format("\tmachm_v: {}.{}.{}", MAJOR_VERSION(firmware_versions->machm_v),
+                        MINOR_VERSION(firmware_versions->machm_v), REVISION_VERSION(firmware_versions->machm_v))
+         << std::endl;
+      DV_LOG(INFO) << ss.str();
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::serializeAccessMgmtNode(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    // Creating 100 threads and they all try to perform serviceRequest() after a single point of sync
+    const auto totalThreads = 100;
+    std::array<int, totalThreads> results;
+    std::promise<void> syncPromise;
+    std::shared_future syncFuture(syncPromise.get_future());
+
+    auto testSerial = [&](int* result) {
+      const uint32_t output_size = sizeof(device_mgmt_api::asset_info_t);
+      char output_buff[output_size] = {0};
+      auto hst_latency = std::make_unique<uint32_t>();
+      auto dev_latency = std::make_unique<uint64_t>();
+      syncFuture.wait();
+      *result = dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MANUFACTURE_NAME, nullptr, 0,
+                                  output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                  DURATION2MS(end - Clock::now()));
+    };
+
+    std::vector<std::thread> threads;
+    for (auto threadId = 0; threadId < totalThreads; threadId++) {
+      threads.push_back(std::thread(testSerial, &results[threadId]));
+    }
+
+    // Delay to ensure all threads started and reached the same point of sync
+    std::this_thread::sleep_for(std::chrono::milliseconds(100));
+    syncPromise.set_value();
+
+    // Wait for threads completion
+    for (auto& thread : threads) {
+      if (thread.joinable()) {
+        thread.join();
+      }
+    }
+
+    for (auto threadId = 0; threadId < totalThreads; threadId++) {
+      EXPECT_EQ(results[threadId], device_mgmt_api::DM_STATUS_SUCCESS);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getDeviceErrorEvents(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+  std::vector<std::string> errTypes = {"DramCeEvent",        "MinionCeEvent",   "PcieCeEvent", "PmicCeEvent",
+                                       "SpCeEvent",          "SpExceptCeEvent", "SramCeEvent", "DramUceEvent",
+                                       "MinionHangUceEvent", "PcieUceEvent",    "SramUceEvent"};
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    std::vector<uint64_t> oldErrCount(errTypes.size(), 0);
+    std::vector<uint64_t> newErrCount(errTypes.size(), 0);
+
+    // Skip counters reading if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      // Read error statistics from sysfs counters
+      auto errStats = devLayer_->getDeviceAttribute(deviceIdx, "err_stats/ce_count") +
+                      devLayer_->getDeviceAttribute(deviceIdx, "err_stats/uce_count");
+      for (auto typeIdx = 0; typeIdx < errTypes.size(); typeIdx++) {
+        std::smatch match;
+        std::regex rgx(errTypes[typeIdx] + ":\\s+(\\d+)");
+        ASSERT_TRUE(std::regex_search(errStats, match, rgx)) << "" << errTypes[typeIdx] << "not found!";
+        oldErrCount[typeIdx] = std::strtoull(match.str(1).c_str(), nullptr, 10);
+      }
+    }
+
+    // Device rsp will be of type device_mgmt_default_rsp_t and payload is uint32_t
+    const uint32_t output_size = sizeof(uint32_t);
+    char output_buff[output_size] = {0};
+
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_DEVICE_ERROR_EVENTS, nullptr, 0,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() == Target::Loopback) {
+      continue;
+    }
+
+    EXPECT_EQ(output_buff[0], device_mgmt_api::DM_STATUS_SUCCESS);
+
+    // Read error statistics again from sysfs counters
+    auto errStats = devLayer_->getDeviceAttribute(deviceIdx, "err_stats/ce_count") +
+                    devLayer_->getDeviceAttribute(deviceIdx, "err_stats/uce_count");
+    for (auto typeIdx = 0; typeIdx < errTypes.size(); typeIdx++) {
+      std::smatch match;
+      std::regex rgx(errTypes[typeIdx] + ":\\s+(\\d+)");
+      ASSERT_TRUE(std::regex_search(errStats, match, rgx)) << "" << errTypes[typeIdx] << "not found!";
+      newErrCount[typeIdx] = std::strtoull(match.str(1).c_str(), nullptr, 10);
+
+      // The counter value must be incremented by now
+      EXPECT_GT(newErrCount[typeIdx], oldErrCount[typeIdx]) << errTypes[typeIdx] << " not received!";
+      DV_LOG(INFO) << errTypes[typeIdx] << ": " << oldErrCount[typeIdx] << " -> " << newErrCount[typeIdx];
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::isUnsupportedService(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    const uint32_t output_size = sizeof(device_mgmt_api::asset_info_t);
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    // Invalid device node
+    ASSERT_EQ(dm.serviceRequest(deviceIdx + 66, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MEMORY_TYPE, nullptr, 0,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              -EINVAL);
+
+    // Invalid command code
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, 99999, nullptr, 0, output_buff, output_size, hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              -EINVAL);
+
+    // Invalid input_buffer
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_ACTIVE_POWER_MANAGEMENT, nullptr,
+                                0, output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              -EINVAL);
+
+    // Invalid output_buffer
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MEMORY_TYPE, nullptr, 0, nullptr,
+                                output_size, hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+              -EINVAL);
+
+    // Invalid host latency
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MEMORY_TYPE, nullptr, 0,
+                                output_buff, output_size, nullptr, dev_latency.get(), DURATION2MS(end - Clock::now())),
+              -EINVAL);
+
+    // Invalid device latency
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MEMORY_TYPE, nullptr, 0,
+                                output_buff, output_size, hst_latency.get(), nullptr, DURATION2MS(end - Clock::now())),
+              -EINVAL);
+    DV_LOG(INFO) << "Service Requests Completed for Device: " << deviceIdx;
+  }
+}
+
+#define SP_CRT_512_V002 "../include/hash.txt"
+
+void TestDevMgmtApiSyncCmds::setSpRootCertificate(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    // Payload in response is of type uint32_t
+    const uint32_t output_size = sizeof(uint32_t);
+    char output_buff[output_size] = {0};
+
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_SP_BOOT_ROOT_CERT, SP_CRT_512_V002, 1,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      char expected[output_size] = {0};
+      strncpy(expected, "0", output_size);
+
+      EXPECT_EQ(strncmp(output_buff, expected, output_size), 0);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::setTraceControl(bool singleDevice, uint32_t control_bitmap) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    const uint32_t input_size = sizeof(device_mgmt_api::trace_control_e);
+    const char input_buff[input_size] = {(char)control_bitmap};
+
+    const uint32_t set_output_size = sizeof(uint8_t);
+    char set_output_buff[set_output_size] = {0};
+
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_DM_TRACE_RUN_CONTROL, input_buff,
+                                input_size, set_output_buff, set_output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      EXPECT_EQ((uint32_t)set_output_buff[0], device_mgmt_api::DM_STATUS_SUCCESS);
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::setTraceConfigure(bool singleDevice, uint32_t event_mask, uint32_t filter_mask) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    const uint32_t input_size =
+      sizeof(device_mgmt_api::trace_configure_e) + sizeof(device_mgmt_api::trace_configure_filter_mask_e);
+    const uint32_t input_buff[input_size] = {event_mask, filter_mask};
+
+    const uint32_t set_output_size = sizeof(uint8_t);
+    char set_output_buff[set_output_size] = {0};
+
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_DM_TRACE_CONFIG,
+                                reinterpret_cast<const char*>(input_buff), input_size, set_output_buff, set_output_size,
+                                hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      EXPECT_EQ((uint32_t)set_output_buff[0], device_mgmt_api::DM_STATUS_SUCCESS);
+    }
+  }
+}
+
+// Note this test should always be the last one
+void TestDevMgmtApiSyncCmds::getTraceBuffer(bool singleDevice, TraceBufferType bufferType) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+  std::vector<std::byte> response;
+  bool validEventFound = false;
+  const struct trace_entry_header_t* entry = NULL;
+
+  // Skip validation if loopback driver
+  if (getTestTarget() == Target::Loopback) {
+    DV_LOG(INFO) << "Get Trace Buffer is not supported on loopback driver";
+    return;
+  }
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    EXPECT_EQ(dm.getTraceBufferServiceProcessor(deviceIdx, bufferType, response), device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    while (entry = Trace_Decode(reinterpret_cast<struct trace_buffer_std_header_t*>(response.data()), entry)) {
+      if (entry->type == TRACE_TYPE_STRING || entry->type == TRACE_TYPE_EXCEPTION ||
+          entry->type == TRACE_TYPE_POWER_STATUS) {
+        validEventFound = true;
+        break;
+      }
+    }
+    validEventFound = true;
+    EXPECT_TRUE(validEventFound) << "No SP trace event found!" << std::endl;
+    validEventFound = false;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::setModuleActivePowerManagementRange(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    const uint32_t input_size = sizeof(device_mgmt_api::active_power_management_e);
+    const char input_buff[input_size] = {9}; // Invalid active power management
+
+    const uint32_t set_output_size = sizeof(uint8_t);
+    char set_output_buff[set_output_size] = {0};
+
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_ACTIVE_POWER_MANAGEMENT,
+                                input_buff, input_size, set_output_buff, set_output_size, hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              -EINVAL);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::setModuleActivePowerManagementRangeInvalidInputSize(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    const uint32_t input_size = sizeof(device_mgmt_api::active_power_management_e);
+    const char input_buff[input_size] = {device_mgmt_api::ACTIVE_POWER_MANAGEMENT_TURN_ON};
+
+    const uint32_t set_output_size = sizeof(uint8_t);
+    char set_output_buff[set_output_size] = {0};
+
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_ACTIVE_POWER_MANAGEMENT,
+                                input_buff, 0 /* Invalid size*/, set_output_buff, set_output_size, hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              -EINVAL);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModuleManufactureNameInvalidOutputSize(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::asset_info_t);
+  char expected[output_size] = {0};
+  strncpy(expected, "Esperan", output_size);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MANUFACTURE_NAME, nullptr, 0,
+                                output_buff, 0 /*Invalid output size*/, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              -EINVAL);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModuleManufactureNameInvalidDeviceNode(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::asset_info_t);
+  char expected[output_size] = {0};
+  strncpy(expected, "Esperan", output_size);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    ASSERT_EQ(dm.serviceRequest(deviceIdx + 250, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MANUFACTURE_NAME, nullptr,
+                                0, output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              -EINVAL);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModuleManufactureNameInvalidHostLatency(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::asset_info_t);
+  char expected[output_size] = {0};
+  strncpy(expected, "Esperan", output_size);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto dev_latency = std::make_unique<uint64_t>();
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MANUFACTURE_NAME, nullptr, 0,
+                                output_buff, output_size, nullptr /*nullptr for invalid testing*/, dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              -EINVAL);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModuleManufactureNameInvalidDeviceLatency(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::asset_info_t);
+  char expected[output_size] = {0};
+  strncpy(expected, "Esperan", output_size);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MANUFACTURE_NAME, nullptr, 0,
+                                output_buff, output_size, hst_latency.get(), nullptr /*nullptr for invalid testing*/,
+                                DURATION2MS(end - Clock::now())),
+              -EINVAL);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getModuleManufactureNameInvalidOutputBuffer(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::asset_info_t);
+  char expected[output_size] = {0};
+  strncpy(expected, "Esperan", output_size);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MANUFACTURE_NAME, nullptr, 0,
+                                nullptr /*nullptr instaed of output buffer*/, output_size, hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              -EINVAL);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::setModuleActivePowerManagementRangeInvalidInputBuffer(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    const uint32_t input_size = sizeof(device_mgmt_api::active_power_management_e);
+    const uint32_t set_output_size = sizeof(uint8_t);
+    char set_output_buff[set_output_size] = {0};
+
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_MODULE_ACTIVE_POWER_MANAGEMENT,
+                                nullptr /*Nullptr instead of input buffer*/, input_size, set_output_buff,
+                                set_output_size, hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+              -EINVAL);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::setFirmwareUpdateImage(bool singleDevice, bool resetDev, int iterations) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto timeoutMulFactor = singleDevice ? 1 : 2; // doubling timeout for running on multiple devices
+  auto end = Clock::now() + timeoutMulFactor * std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  // Verify the paths for flash image and its tools
+  ASSERT_TRUE(fs::exists(FLASH_TOOL_PATH));
+  ASSERT_TRUE(fs::exists(FLASH_IMG_PATH));
+  ASSERT_TRUE(fs::exists(FLASH_32MBIT_TEMPLATE_PATH));
+  ASSERT_TRUE(fs::exists(DEVICE_SIGNED_ARTIFACTS_PATH));
+
+  std::string pmicSlot0ImgPath = DEVICE_SIGNED_ARTIFACTS_PATH + std::string("/signed_pmic_s0_fw.img");
+  std::string pmicSlot1ImgPath = DEVICE_SIGNED_ARTIFACTS_PATH + std::string("/signed_pmic_s1_fw.img");
+  std::string flashToolCmd =
+    FLASH_TOOL_PATH + std::string(" create ") + FLASH_IMG_PATH + std::string(" ") + FLASH_32MBIT_TEMPLATE_PATH;
+  char testHash1[16] = "dead";
+  char testHash2[16] = "beef";
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int iter = 0; iter < iterations; iter++) {
+    char s0OldHash[16];
+    char s1OldHash[16];
+    char* testHashPtr = (iter % 2) ? testHash1 : testHash2;
+    // Change the pmic slot 0 fw hash
+    ASSERT_TRUE(updatePmicMetaFwHash(pmicSlot0ImgPath, testHashPtr, s0OldHash));
+    // Change the pmic slot 1 fw hash
+    ASSERT_TRUE(updatePmicMetaFwHash(pmicSlot1ImgPath, testHashPtr, s1OldHash));
+
+    // Run command to invoke flash tool to re-create the flash image
+    ASSERT_EQ(system(flashToolCmd.c_str()), 0);
+
+    for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+      // DM_CMD_SET_FIRMWARE_UPDATE : Device returns response of type device_mgmt_default_rsp_t.
+      // Payload in response is of type uint32_t
+      uint32_t output_size = sizeof(uint32_t);
+      char output_buff[output_size] = {0};
+      auto hst_latency = std::make_unique<uint32_t>();
+      auto dev_latency = std::make_unique<uint64_t>();
+
+      ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_FIRMWARE_UPDATE, FLASH_IMG_PATH, 1,
+                                  output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                  DURATION2MS(end - Clock::now())),
+                device_mgmt_api::DM_STATUS_SUCCESS);
+      DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+      // Skip validation if loopback driver
+      if (getTestTarget() != Target::Loopback) {
+        ASSERT_EQ(output_buff[0], 0);
+      }
+
+      // Optionally reset the device
+      if (resetDev) {
+        ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_RESET_ETSOC, nullptr, 0, nullptr, 0,
+                                    hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+                  device_mgmt_api::DM_STATUS_SUCCESS);
+        DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+      }
+      // TODO: Validate the hash once the ability to read PMIC has is available
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::setPCIELinkSpeedToInvalidLinkSpeed(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    const uint32_t input_size = sizeof(device_mgmt_api::pcie_link_speed_e);
+    const char input_buff[input_size] = {54}; // Invalid link speed
+
+    // Device rsp will be of type device_mgmt_default_rsp_t and payload is uint32_t
+    const uint32_t output_size = sizeof(uint32_t);
+    char output_buff[output_size] = {0};
+
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_PCIE_MAX_LINK_SPEED, input_buff,
+                                input_size, output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              -EINVAL);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::setPCIELaneWidthToInvalidLaneWidth(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    const uint32_t input_size = sizeof(device_mgmt_api::pcie_lane_w_split_e);
+    const char input_buff[input_size] = {86}; // Invalid lane width
+
+    // Device rsp will be of type device_mgmt_default_rsp_t and payload is uint32_t
+    const uint32_t output_size = sizeof(uint32_t);
+    char output_buff[output_size] = {0};
+
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_PCIE_LANE_WIDTH, input_buff, input_size,
+                                output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              -EINVAL);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::testInvalidOutputSize(int32_t dmCmdType, bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = INVALID_OUTPUT_SIZE; /*Invalid output size*/
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[OUTPUT_SIZE_TEST] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, dmCmdType, nullptr, 0, output_buff, output_size, hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              -EINVAL);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::testInvalidDeviceNode(int32_t dmCmdType, bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = OUTPUT_SIZE_TEST;
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    int device_node = deviceIdx + MAX_DEVICE_NODE; /*Invalid device node*/
+    ASSERT_EQ(dm.serviceRequest(device_node, dmCmdType, nullptr, 0, output_buff, output_size, hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              -EINVAL);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::testInvalidHostLatency(int32_t dmCmdType, bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = OUTPUT_SIZE_TEST;
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto dev_latency = std::make_unique<uint64_t>();
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, dmCmdType, nullptr, 0, output_buff, output_size,
+                                nullptr /*nullptr for invalid testing*/, dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              -EINVAL);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::testInvalidDeviceLatency(int32_t dmCmdType, bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = OUTPUT_SIZE_TEST;
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, dmCmdType, nullptr, 0, output_buff, output_size, hst_latency.get(),
+                                nullptr /*nullptr for invalid testing*/, DURATION2MS(end - Clock::now())),
+              -EINVAL);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::testInvalidOutputBuffer(int32_t dmCmdType, bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = OUTPUT_SIZE_TEST;
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char* output_buff = nullptr; /*nullptr for invalid testing*/
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, dmCmdType, nullptr, 0, output_buff, output_size, hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              -EINVAL);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getASICFrequenciesInvalidOutputSize(bool singleDevice) {
+  testInvalidOutputSize(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_FREQUENCIES, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICFrequenciesInvalidDeviceNode(bool singleDevice) {
+  testInvalidDeviceNode(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_FREQUENCIES, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICFrequenciesInvalidHostLatency(bool singleDevice) {
+  testInvalidHostLatency(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_FREQUENCIES, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICFrequenciesInvalidDeviceLatency(bool singleDevice) {
+  testInvalidDeviceLatency(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_FREQUENCIES, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICFrequenciesInvalidOutputBuffer(bool singleDevice) {
+  testInvalidOutputBuffer(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_FREQUENCIES, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getDRAMBandwidthInvalidOutputSize(bool singleDevice) {
+  testInvalidOutputSize(device_mgmt_api::DM_CMD::DM_CMD_GET_DRAM_BANDWIDTH, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getDRAMBandwidthInvalidDeviceNode(bool singleDevice) {
+  testInvalidDeviceNode(device_mgmt_api::DM_CMD::DM_CMD_GET_DRAM_BANDWIDTH, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getDRAMBandwidthInvalidHostLatency(bool singleDevice) {
+  testInvalidHostLatency(device_mgmt_api::DM_CMD::DM_CMD_GET_DRAM_BANDWIDTH, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getDRAMBandwidthInvalidDeviceLatency(bool singleDevice) {
+  testInvalidDeviceLatency(device_mgmt_api::DM_CMD::DM_CMD_GET_DRAM_BANDWIDTH, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getDRAMBandwidthInvalidOutputBuffer(bool singleDevice) {
+  testInvalidOutputBuffer(device_mgmt_api::DM_CMD::DM_CMD_GET_DRAM_BANDWIDTH, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getDRAMCapacityUtilizationInvalidOutputSize(bool singleDevice) {
+  testInvalidOutputSize(device_mgmt_api::DM_CMD::DM_CMD_GET_DRAM_CAPACITY_UTILIZATION, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getDRAMCapacityUtilizationInvalidDeviceNode(bool singleDevice) {
+  testInvalidDeviceNode(device_mgmt_api::DM_CMD::DM_CMD_GET_DRAM_CAPACITY_UTILIZATION, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getDRAMCapacityUtilizationInvalidHostLatency(bool singleDevice) {
+  testInvalidHostLatency(device_mgmt_api::DM_CMD::DM_CMD_GET_DRAM_CAPACITY_UTILIZATION, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getDRAMCapacityUtilizationInvalidDeviceLatency(bool singleDevice) {
+  testInvalidDeviceLatency(device_mgmt_api::DM_CMD::DM_CMD_GET_DRAM_CAPACITY_UTILIZATION, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getDRAMCapacityUtilizationInvalidOutputBuffer(bool singleDevice) {
+  testInvalidOutputBuffer(device_mgmt_api::DM_CMD::DM_CMD_GET_DRAM_CAPACITY_UTILIZATION, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICPerCoreDatapathUtilizationInvalidOutputSize(bool singleDevice) {
+  testInvalidOutputSize(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_PER_CORE_DATAPATH_UTILIZATION, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICPerCoreDatapathUtilizationInvalidDeviceNode(bool singleDevice) {
+  testInvalidDeviceNode(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_PER_CORE_DATAPATH_UTILIZATION, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICPerCoreDatapathUtilizationInvalidHostLatency(bool singleDevice) {
+  testInvalidHostLatency(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_PER_CORE_DATAPATH_UTILIZATION, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICPerCoreDatapathUtilizationInvalidDeviceLatency(bool singleDevice) {
+  testInvalidDeviceLatency(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_PER_CORE_DATAPATH_UTILIZATION, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICPerCoreDatapathUtilizationInvalidOutputBuffer(bool singleDevice) {
+  testInvalidOutputBuffer(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_PER_CORE_DATAPATH_UTILIZATION, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICUtilizationInvalidOutputSize(bool singleDevice) {
+  testInvalidOutputSize(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_UTILIZATION, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICUtilizationInvalidDeviceNode(bool singleDevice) {
+  testInvalidDeviceNode(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_UTILIZATION, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICUtilizationInvalidHostLatency(bool singleDevice) {
+  testInvalidHostLatency(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_UTILIZATION, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICUtilizationInvalidDeviceLatency(bool singleDevice) {
+  testInvalidDeviceLatency(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_UTILIZATION, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICUtilizationInvalidOutputBuffer(bool singleDevice) {
+  testInvalidOutputBuffer(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_UTILIZATION, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICStallsInvalidOutputSize(bool singleDevice) {
+  testInvalidOutputSize(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_STALLS, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICStallsInvalidDeviceNode(bool singleDevice) {
+  testInvalidDeviceNode(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_STALLS, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICStallsInvalidHostLatency(bool singleDevice) {
+  testInvalidHostLatency(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_STALLS, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICStallsInvalidDeviceLatency(bool singleDevice) {
+  testInvalidDeviceLatency(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_STALLS, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICStallsInvalidOutputBuffer(bool singleDevice) {
+  testInvalidOutputBuffer(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_STALLS, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICLatencyInvalidOutputSize(bool singleDevice) {
+  testInvalidOutputSize(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_LATENCY, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICLatencyInvalidDeviceNode(bool singleDevice) {
+  testInvalidDeviceNode(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_LATENCY, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICLatencyInvalidHostLatency(bool singleDevice) {
+  testInvalidHostLatency(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_LATENCY, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICLatencyInvalidDeviceLatency(bool singleDevice) {
+  testInvalidDeviceLatency(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_LATENCY, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getASICLatencyInvalidOutputBuffer(bool singleDevice) {
+  testInvalidOutputBuffer(device_mgmt_api::DM_CMD::DM_CMD_GET_ASIC_LATENCY, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::testInvalidCmdCode(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = OUTPUT_SIZE_TEST;
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, DM_CMD_INVALID, nullptr, 0, output_buff, output_size, hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              -EINVAL);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::testInvalidInputBuffer(int32_t dmCmdType, bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    const uint32_t input_size = INPUT_SIZE_TEST;
+    const char* input_buff = nullptr; /*nullptr for invalid testing*/
+
+    const uint32_t output_size = OUTPUT_SIZE_TEST;
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, dmCmdType, input_buff, input_size, output_buff, output_size,
+                                hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+              -EINVAL);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::testInvalidInputSize(int32_t dmCmdType, bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    const uint32_t input_size = INVALID_INPUT_SIZE;
+    const char input_buff[INPUT_SIZE_TEST] = {0};
+
+    const uint32_t output_size = OUTPUT_SIZE_TEST;
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, dmCmdType, input_buff, input_size, output_buff, output_size,
+                                hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+              -EINVAL);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::setDDRECCCountInvalidInputBuffer(bool singleDevice) {
+  testInvalidInputBuffer(device_mgmt_api::DM_CMD::DM_CMD_SET_DDR_ECC_COUNT, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::setDDRECCCountInvalidInputSize(bool singleDevice) {
+  testInvalidInputSize(device_mgmt_api::DM_CMD::DM_CMD_SET_DDR_ECC_COUNT, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::setDDRECCCountInvalidOutputSize(bool singleDevice) {
+  testInvalidOutputSize(device_mgmt_api::DM_CMD::DM_CMD_SET_DDR_ECC_COUNT, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::setDDRECCCountInvalidDeviceNode(bool singleDevice) {
+  testInvalidDeviceNode(device_mgmt_api::DM_CMD::DM_CMD_SET_DDR_ECC_COUNT, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::setDDRECCCountInvalidHostLatency(bool singleDevice) {
+  testInvalidHostLatency(device_mgmt_api::DM_CMD::DM_CMD_SET_DDR_ECC_COUNT, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::setDDRECCCountInvalidDeviceLatency(bool singleDevice) {
+  testInvalidDeviceLatency(device_mgmt_api::DM_CMD::DM_CMD_SET_DDR_ECC_COUNT, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::setDDRECCCountInvalidOutputBuffer(bool singleDevice) {
+  testInvalidOutputBuffer(device_mgmt_api::DM_CMD::DM_CMD_SET_DDR_ECC_COUNT, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::setPCIEECCCountInvalidInputBuffer(bool singleDevice) {
+  testInvalidInputBuffer(device_mgmt_api::DM_CMD::DM_CMD_SET_PCIE_ECC_COUNT, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::setPCIEECCountInvalidInputSize(bool singleDevice) {
+  testInvalidInputBuffer(device_mgmt_api::DM_CMD::DM_CMD_SET_PCIE_ECC_COUNT, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::setPCIEECCountInvalidOutputSize(bool singleDevice) {
+  testInvalidOutputSize(device_mgmt_api::DM_CMD::DM_CMD_SET_PCIE_ECC_COUNT, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::setPCIEECCountInvalidDeviceNode(bool singleDevice) {
+  testInvalidDeviceNode(device_mgmt_api::DM_CMD::DM_CMD_SET_PCIE_ECC_COUNT, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::setPCIEECCountInvalidHostLatency(bool singleDevice) {
+  testInvalidHostLatency(device_mgmt_api::DM_CMD::DM_CMD_SET_PCIE_ECC_COUNT, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::setPCIEECCountInvalidDeviceLatency(bool singleDevice) {
+  testInvalidDeviceLatency(device_mgmt_api::DM_CMD::DM_CMD_SET_PCIE_ECC_COUNT, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::setPCIEECCountInvalidOutputBuffer(bool singleDevice) {
+  testInvalidOutputBuffer(device_mgmt_api::DM_CMD::DM_CMD_SET_PCIE_ECC_COUNT, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::setSRAMECCCountInvalidInputBuffer(bool singleDevice) {
+  testInvalidInputBuffer(device_mgmt_api::DM_CMD::DM_CMD_SET_SRAM_ECC_COUNT, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::setSRAMECCCountInvalidInputSize(bool singleDevice) {
+  testInvalidInputBuffer(device_mgmt_api::DM_CMD::DM_CMD_SET_SRAM_ECC_COUNT, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::setSRAMECCountInvalidOutputSize(bool singleDevice) {
+  testInvalidOutputSize(device_mgmt_api::DM_CMD::DM_CMD_SET_SRAM_ECC_COUNT, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::setSRAMECCountInvalidDeviceNode(bool singleDevice) {
+  testInvalidDeviceNode(device_mgmt_api::DM_CMD::DM_CMD_SET_SRAM_ECC_COUNT, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::setSRAMECCountInvalidHostLatency(bool singleDevice) {
+  testInvalidHostLatency(device_mgmt_api::DM_CMD::DM_CMD_SET_SRAM_ECC_COUNT, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::setSRAMECCountInvalidDeviceLatency(bool singleDevice) {
+  testInvalidDeviceLatency(device_mgmt_api::DM_CMD::DM_CMD_SET_SRAM_ECC_COUNT, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::setSRAMECCountInvalidOutputBuffer(bool singleDevice) {
+  testInvalidOutputBuffer(device_mgmt_api::DM_CMD::DM_CMD_SET_SRAM_ECC_COUNT, singleDevice);
+}
+
+void TestDevMgmtApiSyncCmds::getHistoricalExtremeWithInvalidDeviceNode(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::dm_cmd_e);
+  char expected[output_size] = {0};
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    ASSERT_EQ(dm.serviceRequest(deviceIdx + deviceCount, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MAX_TEMPERATURE,
+                                nullptr, 0, output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              -EINVAL);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getHistoricalExtremeWithInvalidHostLatency(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::dm_cmd_e);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto dev_latency = std::make_unique<uint64_t>();
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MAX_TEMPERATURE, nullptr, 0,
+                                output_buff, output_size, nullptr, dev_latency.get(), DURATION2MS(end - Clock::now())),
+              -EINVAL);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getHistoricalExtremeWithInvalidDeviceLatency(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::dm_cmd_e);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MODULE_MAX_DDR_BW, nullptr, 0,
+                                output_buff, output_size, hst_latency.get(), nullptr, DURATION2MS(end - Clock::now())),
+              -EINVAL);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getHistoricalExtremeWithInvalidOutputBuffer(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::dm_cmd_e);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MAX_MEMORY_ERROR, nullptr, 0, nullptr,
+                                output_size, hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+              -EINVAL);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::getHistoricalExtremeWithInvalidOutputSize(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t output_size = sizeof(device_mgmt_api::dm_cmd_e);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_MAX_MEMORY_ERROR, nullptr, 0,
+                                output_buff, 0, hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+              -EINVAL);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::setThrottlePowerStatus(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  bool validEventFound = false;
+  std::vector<std::byte> response;
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+  auto hst_latency = std::make_unique<uint32_t>();
+  auto dev_latency = std::make_unique<uint64_t>();
+  const uint32_t output_size = sizeof(uint32_t);
+  char output_buff[output_size] = {0};
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    uint32_t input_size = sizeof(device_mgmt_api::power_throttle_state_e);
+    for (device_mgmt_api::power_throttle_state_e throttle_state = device_mgmt_api::POWER_THROTTLE_STATE_POWER_DOWN;
+         throttle_state >= device_mgmt_api::POWER_THROTTLE_STATE_POWER_UP; throttle_state--) {
+      char input_buff[input_size] = {(char)throttle_state};
+      ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_THROTTLE_POWER_STATE_TEST, input_buff,
+                                  input_size, output_buff, output_size, hst_latency.get(), dev_latency.get(),
+                                  DURATION2MS(end - Clock::now())),
+                device_mgmt_api::DM_STATUS_SUCCESS);
+
+      DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+    }
+
+    if (getTestTarget() != Target::Loopback) {
+      const struct trace_entry_header_t* entry = NULL;
+      if (dm.getTraceBufferServiceProcessor(deviceIdx, TraceBufferType::TraceBufferSP, response) !=
+          device_mgmt_api::DM_STATUS_SUCCESS) {
+        DV_LOG(INFO) << "Unable to get SP trace buffer for device: " << deviceIdx << ". Disabling Trace.";
+      } else {
+        while (entry = Trace_Decode(reinterpret_cast<struct trace_buffer_std_header_t*>(response.data()), entry)) {
+          if (entry->type == TRACE_TYPE_POWER_STATUS) {
+            validEventFound = true;
+            break;
+          }
+        }
+      }
+      EXPECT_TRUE(validEventFound) << "No SP Power status trace event found for Device: " << deviceIdx << std::endl;
+      validEventFound = false;
+    }
+  }
+}
+void TestDevMgmtApiSyncCmds::resetMM(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MM_RESET, nullptr, 0, nullptr, 0,
+                                hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::resetMMWithOpsInUse(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    try {
+      dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MM_RESET, nullptr, 0, nullptr, 0, hst_latency.get(),
+                        dev_latency.get(), DURATION2MS(end - Clock::now()));
+
+    } catch (const dev::Exception& ex) {
+      // Resetting of MM is not permitted when Ops node is open.
+      EXPECT_THAT(ex.what(), testing::HasSubstr("Operation not permitted"));
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::readMem_unprivileged(uint64_t readAddr) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t input_size = sizeof(device_mgmt_api::mdi_mem_read_t);
+  device_mgmt_api::mdi_mem_read_t input_buff;
+  /* Test address in un-privileged memory regions. */
+  input_buff.address = readAddr;
+  input_buff.hart_id = 0;
+  input_buff.access_type = 2; /* MEM_ACCESS_TYPE_NORMAL */
+  input_buff.size = sizeof(uint64_t);
+  const uint32_t output_size = sizeof(uint64_t);
+
+  auto deviceCount = dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    uint64_t output = 0;
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_READ_MEM, (char*)&input_buff, input_size,
+                                (char*)&output, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    // Skip validation if loopback driver
+    if (getTestTarget() != Target::Loopback) {
+      DV_LOG(INFO) << "Mem addr: 0x" << std::hex << input_buff.address << " Value:" << std::hex << output;
+    }
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::readMem_privileged(uint64_t readAddr) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  const uint32_t input_size = sizeof(device_mgmt_api::mdi_mem_read_t);
+  device_mgmt_api::mdi_mem_read_t input_buff;
+  /* Test address in privileged memory regions. */
+  input_buff.address = readAddr;
+  input_buff.hart_id = 0;
+  input_buff.access_type = 2; /* MEM_ACCESS_TYPE_NORMAL */
+  input_buff.size = sizeof(uint64_t);
+  const uint32_t output_size = sizeof(uint64_t);
+
+  auto deviceCount = dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    uint64_t output = 0;
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_READ_MEM, (char*)&input_buff, input_size,
+                                (char*)&output, output_size, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              -EIO);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::writeMem_unprivileged(uint64_t testInputData, uint64_t writeAddr) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    const uint32_t mdi_mem_write_cmd_size = sizeof(device_mgmt_api::mdi_mem_write_t);
+    device_mgmt_api::mdi_mem_write_t mdi_mem_write;
+    mdi_mem_write.address = writeAddr;
+    mdi_mem_write.size = sizeof(uint64_t);
+    mdi_mem_write.data = testInputData;
+    uint64_t mem_write_status = 0;
+
+    DV_LOG(INFO) << "Mem addr: 0x" << std::hex << mdi_mem_write.address << " Write Value:" << std::hex
+                 << mdi_mem_write.data;
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_WRITE_MEM, (char*)&mdi_mem_write,
+                                mdi_mem_write_cmd_size, (char*)&mem_write_status, sizeof(uint64_t), hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(mem_write_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    const uint32_t mdi_mem_read_cmd_size = sizeof(device_mgmt_api::mdi_mem_read_t);
+    device_mgmt_api::mdi_mem_read_t mdi_mem_read;
+    mdi_mem_read.address = writeAddr;
+    mdi_mem_read.hart_id = 0;
+    mdi_mem_read.access_type = 2; /* MEM_ACCESS_TYPE_NORMAL */
+    mdi_mem_read.size = sizeof(uint64_t);
+    mdi_mem_read.hart_id = 0;
+    mdi_mem_read.access_type = 2; /* MEM_ACCESS_TYPE_NORMAL */
+    uint64_t mem_read_output = 0;
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_READ_MEM, (char*)&mdi_mem_read,
+                                mdi_mem_read_cmd_size, (char*)&mem_read_output, sizeof(uint64_t), hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "Mem addr: 0x" << std::hex << mdi_mem_read.address << " Read Value:" << std::hex << mem_read_output;
+
+    EXPECT_EQ(mem_read_output, testInputData);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::writeMem_privileged(uint64_t testInputData, uint64_t writeAddr) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    const uint32_t mdi_mem_write_cmd_size = sizeof(device_mgmt_api::mdi_mem_write_t);
+    device_mgmt_api::mdi_mem_write_t mdi_mem_write;
+    mdi_mem_write.address = writeAddr;
+    mdi_mem_write.size = sizeof(uint64_t);
+    mdi_mem_write.data = testInputData;
+    uint64_t mem_write_status = 0;
+
+    DV_LOG(INFO) << "Mem addr: 0x" << std::hex << mdi_mem_write.address << " Write Value:" << std::hex
+                 << mdi_mem_write.data;
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_WRITE_MEM, (char*)&mdi_mem_write,
+                                mdi_mem_write_cmd_size, (char*)&mem_write_status, sizeof(uint64_t), hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              -EIO);
+
+    EXPECT_EQ(mem_write_status, device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::testRunControlCmdsSetandUnsetBreakpoint(uint64_t shireID, uint64_t threadMask,
+                                                                     uint64_t hartID, uint64_t bpAddr) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    /* Select Hart */
+    const uint32_t mdi_hart_select_input_size = sizeof(device_mgmt_api::mdi_hart_selection_t);
+    device_mgmt_api::mdi_hart_selection_t mdi_hart_select_input_buff;
+    // Set the Shire ID and Neigh ID.
+    mdi_hart_select_input_buff.shire_id = shireID;
+    mdi_hart_select_input_buff.thread_mask = threadMask;
+    int32_t hart_select_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_SELECT_HART,
+                                (char*)&mdi_hart_select_input_buff, mdi_hart_select_input_size,
+                                (char*)&hart_select_status, sizeof(int32_t), hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(hart_select_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    /* Halt Hart */
+    uint32_t hart_control_input_size = sizeof(device_mgmt_api::mdi_hart_control_t);
+    char hart_control_input_buff[hart_control_input_size] = {device_mgmt_api::MDI_HART_CTRL_FLAG_HALT_HART};
+    int32_t halt_hart_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_HALT_HART, hart_control_input_buff,
+                                hart_control_input_size, (char*)&halt_hart_status, sizeof(int32_t), hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(halt_hart_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    /* Set Breakpoint */
+    const uint32_t mdi_bp_input_size = sizeof(device_mgmt_api::mdi_bp_control_t);
+    device_mgmt_api::mdi_bp_control_t mdi_bp_input_buff;
+
+    // Set the Hart ID/BP address/mode
+    mdi_bp_input_buff.hart_id = hartID;
+    mdi_bp_input_buff.bp_address = bpAddr;
+    mdi_bp_input_buff.mode = device_mgmt_api::PRIV_MASK_PRIV_UMODE;
+    int32_t bp_cmd_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_SET_BREAKPOINT,
+                                (char*)&mdi_bp_input_buff, mdi_bp_input_size, (char*)&bp_cmd_status, sizeof(int32_t),
+                                hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    /* Wait for set break point event */
+    std::vector<std::byte> buf;
+    EXPECT_TRUE(dm.getEvent(deviceIdx, buf, DURATION2MS(end - Clock::now())));
+
+    auto rCB = reinterpret_cast<const dm_evt*>(buf.data());
+    EXPECT_EQ(rCB->info.event_hdr.msg_id, device_mgmt_api::DM_CMD_MDI_SET_BREAKPOINT_EVENT);
+
+    /* UnSet Breakpoint */
+    mdi_bp_input_buff = {0};
+    mdi_bp_input_buff.hart_id = hartID;
+    bp_cmd_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_UNSET_BREAKPOINT,
+                                (char*)&mdi_bp_input_buff, mdi_bp_input_size, (char*)&bp_cmd_status, sizeof(int32_t),
+                                hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(bp_cmd_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    /* Resume Hart */
+    hart_control_input_size = sizeof(device_mgmt_api::mdi_hart_control_t);
+    hart_control_input_buff[hart_control_input_size] = {device_mgmt_api::MDI_HART_CTRL_FLAG_RESUME_HART};
+    int32_t resume_hart_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_RESUME_HART, hart_control_input_buff,
+                                hart_control_input_size, (char*)&resume_hart_status, sizeof(int32_t), hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(resume_hart_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    int32_t unselect_hart_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_UNSELECT_HART,
+                                (char*)&mdi_hart_select_input_buff, mdi_hart_select_input_size,
+                                (char*)&unselect_hart_status, sizeof(int32_t), hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(unselect_hart_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::testRunControlCmdsGetHartStatus(uint64_t shireID, uint64_t threadMask, uint64_t hartID) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    const uint32_t output_size = sizeof(uint64_t);
+    char output_buff[output_size] = {0};
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    /* Select Hart */
+    const uint32_t mdi_hart_select_input_size = sizeof(device_mgmt_api::mdi_hart_selection_t);
+    device_mgmt_api::mdi_hart_selection_t mdi_hart_select_input_buff;
+    // Set the Shire ID and Neigh ID.
+    mdi_hart_select_input_buff.shire_id = shireID;
+    mdi_hart_select_input_buff.thread_mask = threadMask;
+    int32_t hart_select_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_SELECT_HART,
+                                (char*)&mdi_hart_select_input_buff, mdi_hart_select_input_size,
+                                (char*)&hart_select_status, sizeof(int32_t), hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(hart_select_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    /* Halt Hart */
+    uint32_t hart_control_input_size = sizeof(device_mgmt_api::mdi_hart_control_t);
+    char hart_control_input_buff[hart_control_input_size] = {device_mgmt_api::MDI_HART_CTRL_FLAG_HALT_HART};
+    int32_t halt_hart_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_HALT_HART, hart_control_input_buff,
+                                hart_control_input_size, (char*)&halt_hart_status, sizeof(int32_t), hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(halt_hart_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    /* Get the Hart Status */
+    device_mgmt_api::mdi_hart_control_t mdi_hart_control_input;
+    mdi_hart_control_input.hart_id = hartID;
+    uint32_t hart_status;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_GET_HART_STATUS,
+                                (char*)&mdi_hart_control_input, sizeof(mdi_hart_control_input), (char*)&hart_status,
+                                sizeof(uint32_t), hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    if (getTestTarget() != Target::Loopback) {
+      DV_LOG(INFO) << "HartID:" << std::hex << mdi_hart_control_input.hart_id << " Status:" << std::hex << hart_status;
+    }
+
+    EXPECT_EQ(hart_status, device_mgmt_api::MDI_HART_STATUS_HALTED);
+
+    /* Resume Hart */
+    hart_control_input_size = sizeof(device_mgmt_api::mdi_hart_control_t);
+    hart_control_input_buff[hart_control_input_size] = {device_mgmt_api::MDI_HART_CTRL_FLAG_RESUME_HART};
+    int32_t resume_hart_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_RESUME_HART, hart_control_input_buff,
+                                hart_control_input_size, (char*)&resume_hart_status, sizeof(int32_t), hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(resume_hart_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    /* Get the Hart Status */
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_GET_HART_STATUS,
+                                (char*)&mdi_hart_control_input, sizeof(mdi_hart_control_input), (char*)&hart_status,
+                                sizeof(uint32_t), hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    if (getTestTarget() != Target::Loopback) {
+      DV_LOG(INFO) << "HartID:" << std::hex << mdi_hart_control_input.hart_id << " Status:" << std::hex << hart_status;
+    }
+
+    EXPECT_EQ(hart_status, device_mgmt_api::MDI_HART_STATUS_RUNNING);
+
+    /* Unselect Hart */
+    int32_t unselect_hart_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_UNSELECT_HART,
+                                (char*)&mdi_hart_select_input_buff, mdi_hart_select_input_size,
+                                (char*)&unselect_hart_status, sizeof(int32_t), hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(unselect_hart_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::testStateInspectionReadGPR(uint64_t shireID, uint64_t threadMask, uint64_t hartID) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    /* Select Hart */
+    const uint32_t mdi_hart_select_input_size = sizeof(device_mgmt_api::mdi_hart_selection_t);
+    device_mgmt_api::mdi_hart_selection_t mdi_hart_select_input_buff;
+    // Set the Shire ID and Neigh ID.
+    mdi_hart_select_input_buff.shire_id = shireID;
+    mdi_hart_select_input_buff.thread_mask = threadMask;
+    int32_t hart_select_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_SELECT_HART,
+                                (char*)&mdi_hart_select_input_buff, mdi_hart_select_input_size,
+                                (char*)&hart_select_status, sizeof(int32_t), hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(hart_select_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    /* Halt Hart */
+    uint32_t hart_control_input_size = sizeof(device_mgmt_api::mdi_hart_control_t);
+    char hart_control_input_buff[hart_control_input_size] = {device_mgmt_api::MDI_HART_CTRL_FLAG_HALT_HART};
+    int32_t halt_hart_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_HALT_HART, hart_control_input_buff,
+                                hart_control_input_size, (char*)&halt_hart_status, sizeof(int32_t), hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(halt_hart_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    const uint32_t gpr_read_input_size = sizeof(device_mgmt_api::mdi_gpr_read_t);
+    device_mgmt_api::mdi_gpr_read_t gpr_read_input_buff;
+    gpr_read_input_buff.hart_id = hartID;
+    /* Read starting from GPR index 1 */
+    for (int i = 1; i < 32; i++) {
+      uint64_t output = 0;
+      gpr_read_input_buff.gpr_index = i;
+      const uint32_t read_output_size = sizeof(uint64_t);
+      ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_READ_GPR, (char*)&gpr_read_input_buff,
+                                  gpr_read_input_size, (char*)&output, read_output_size, hst_latency.get(),
+                                  dev_latency.get(), DURATION2MS(end - Clock::now())),
+                device_mgmt_api::DM_STATUS_SUCCESS);
+
+      if (getTestTarget() != Target::Loopback) {
+        DV_LOG(INFO) << "HartID:" << std::hex << gpr_read_input_buff.hart_id
+                     << " GPR Index:" << gpr_read_input_buff.gpr_index << " GPR REG Value:" << std::hex << output;
+      }
+    }
+
+    /* Resume Hart */
+    hart_control_input_size = sizeof(device_mgmt_api::mdi_hart_control_t);
+    hart_control_input_buff[hart_control_input_size] = {device_mgmt_api::MDI_HART_CTRL_FLAG_RESUME_HART};
+    int32_t resume_hart_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_RESUME_HART, hart_control_input_buff,
+                                hart_control_input_size, (char*)&resume_hart_status, sizeof(int32_t), hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(resume_hart_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    /* Unselect Hart */
+    int32_t unselect_hart_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_UNSELECT_HART,
+                                (char*)&mdi_hart_select_input_buff, mdi_hart_select_input_size,
+                                (char*)&unselect_hart_status, sizeof(int32_t), hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(unselect_hart_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::testStateInspectionWriteGPR(uint64_t shireID, uint64_t threadMask, uint64_t hartID,
+                                                         uint64_t writeTestData) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    /* Select Hart */
+    const uint32_t mdi_hart_select_input_size = sizeof(device_mgmt_api::mdi_hart_selection_t);
+    device_mgmt_api::mdi_hart_selection_t mdi_hart_select_input_buff;
+    // Set the Shire ID and Neigh ID.
+    mdi_hart_select_input_buff.shire_id = shireID;
+    mdi_hart_select_input_buff.thread_mask = threadMask;
+    int32_t hart_select_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_SELECT_HART,
+                                (char*)&mdi_hart_select_input_buff, mdi_hart_select_input_size,
+                                (char*)&hart_select_status, sizeof(int32_t), hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(hart_select_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    /* Halt Hart */
+    uint32_t hart_control_input_size = sizeof(device_mgmt_api::mdi_hart_control_t);
+    char hart_control_input_buff[hart_control_input_size] = {device_mgmt_api::MDI_HART_CTRL_FLAG_HALT_HART};
+    int32_t halt_hart_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_HALT_HART, hart_control_input_buff,
+                                hart_control_input_size, (char*)&halt_hart_status, sizeof(int32_t), hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(halt_hart_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    const uint32_t gpr_read_input_size = sizeof(device_mgmt_api::mdi_gpr_read_t);
+    device_mgmt_api::mdi_gpr_read_t gpr_read_input_buff;
+    gpr_read_input_buff.hart_id = hartID;
+
+    const uint32_t gpr_write_input_size = sizeof(device_mgmt_api::mdi_gpr_write_t);
+    device_mgmt_api::mdi_gpr_write_t gpr_write_input_buff;
+    uint64_t dummy;
+    gpr_write_input_buff.hart_id = hartID;
+
+    uint64_t output = 0;
+    uint64_t gpr_val = 0;
+    const uint32_t read_output_size = sizeof(uint64_t);
+    for (int i = 1; i < 32; i++) {
+      gpr_read_input_buff.gpr_index = i;
+      gpr_write_input_buff.gpr_index = i;
+
+      ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_READ_GPR, (char*)&gpr_read_input_buff,
+                                  gpr_read_input_size, (char*)&gpr_val, read_output_size, hst_latency.get(),
+                                  dev_latency.get(), DURATION2MS(end - Clock::now())),
+                device_mgmt_api::DM_STATUS_SUCCESS);
+
+      DV_LOG(INFO) << "Before update HartID:" << std::hex << gpr_read_input_buff.hart_id
+                   << " GPR Index:" << gpr_read_input_buff.gpr_index << " Value:" << std::hex << gpr_val;
+
+      gpr_write_input_buff.data = writeTestData + i; /* Test Data */
+      DV_LOG(INFO) << "Write Value:" << std::hex << gpr_write_input_buff.data;
+      ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_WRITE_GPR,
+                                  (char*)&gpr_write_input_buff, gpr_write_input_size, (char*)&dummy, sizeof(uint64_t),
+                                  hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+                device_mgmt_api::DM_STATUS_SUCCESS);
+
+      ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_READ_GPR, (char*)&gpr_read_input_buff,
+                                  gpr_read_input_size, (char*)&output, read_output_size, hst_latency.get(),
+                                  dev_latency.get(), DURATION2MS(end - Clock::now())),
+                device_mgmt_api::DM_STATUS_SUCCESS);
+
+      DV_LOG(INFO) << "After update HartID:" << std::hex << gpr_read_input_buff.hart_id
+                   << " GPR Index:" << gpr_read_input_buff.gpr_index << " Value:" << std::hex << output;
+
+      EXPECT_EQ(gpr_write_input_buff.data, output);
+
+      /* Restore GPR value */
+      gpr_write_input_buff.data = gpr_val;
+      ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_WRITE_GPR,
+                                  (char*)&gpr_write_input_buff, gpr_write_input_size, (char*)&dummy, sizeof(uint64_t),
+                                  hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+                device_mgmt_api::DM_STATUS_SUCCESS);
+    }
+
+    /* Resume Hart */
+    hart_control_input_size = sizeof(device_mgmt_api::mdi_hart_control_t);
+    hart_control_input_buff[hart_control_input_size] = {device_mgmt_api::MDI_HART_CTRL_FLAG_RESUME_HART};
+    int32_t resume_hart_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_RESUME_HART, hart_control_input_buff,
+                                hart_control_input_size, (char*)&resume_hart_status, sizeof(int32_t), hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(resume_hart_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    /* Unselect Hart */
+    int32_t unselect_hart_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_UNSELECT_HART,
+                                (char*)&mdi_hart_select_input_buff, mdi_hart_select_input_size,
+                                (char*)&unselect_hart_status, sizeof(int32_t), hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(unselect_hart_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::testStateInspectionReadCSR(uint64_t shireID, uint64_t threadMask, uint64_t hartID,
+                                                        uint64_t csrName) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    /* Select Hart */
+    const uint32_t mdi_hart_select_input_size = sizeof(device_mgmt_api::mdi_hart_selection_t);
+    device_mgmt_api::mdi_hart_selection_t mdi_hart_select_input_buff;
+    // Set the Shire ID and Neigh ID.
+    mdi_hart_select_input_buff.shire_id = shireID;
+    mdi_hart_select_input_buff.thread_mask = threadMask;
+    int32_t hart_select_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_SELECT_HART,
+                                (char*)&mdi_hart_select_input_buff, mdi_hart_select_input_size,
+                                (char*)&hart_select_status, sizeof(int32_t), hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(hart_select_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    /* Halt Hart */
+    uint32_t hart_control_input_size = sizeof(device_mgmt_api::mdi_hart_control_t);
+    char hart_control_input_buff[hart_control_input_size] = {device_mgmt_api::MDI_HART_CTRL_FLAG_HALT_HART};
+    int32_t halt_hart_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_HALT_HART, hart_control_input_buff,
+                                hart_control_input_size, (char*)&halt_hart_status, sizeof(int32_t), hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(halt_hart_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    const uint32_t csr_read_input_size = sizeof(device_mgmt_api::mdi_csr_read_t);
+    device_mgmt_api::mdi_csr_read_t csr_read_input_buff;
+    csr_read_input_buff.hart_id = hartID;
+    /* PC offset */
+    csr_read_input_buff.csr_name = csrName;
+    uint64_t csr_value = 0;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_READ_CSR, (char*)&csr_read_input_buff,
+                                csr_read_input_size, (char*)&csr_value, sizeof(uint64_t), hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    if (getTestTarget() != Target::Loopback) {
+      DV_LOG(INFO) << "HartID:" << std::hex << csr_read_input_buff.hart_id << " PC Value:" << std::hex << csr_value;
+    }
+
+    /* Resume Hart */
+    hart_control_input_size = sizeof(device_mgmt_api::mdi_hart_control_t);
+    hart_control_input_buff[hart_control_input_size] = {device_mgmt_api::MDI_HART_CTRL_FLAG_RESUME_HART};
+    int32_t resume_hart_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_RESUME_HART, hart_control_input_buff,
+                                hart_control_input_size, (char*)&resume_hart_status, sizeof(int32_t), hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(resume_hart_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    /* Unselect Hart */
+    int32_t unselect_hart_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_UNSELECT_HART,
+                                (char*)&mdi_hart_select_input_buff, mdi_hart_select_input_size,
+                                (char*)&unselect_hart_status, sizeof(int32_t), hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(unselect_hart_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::testStateInspectionWriteCSR(uint64_t shireID, uint64_t threadMask, uint64_t hartID,
+                                                         uint64_t csrName, uint64_t csrData) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    /* Select Hart */
+    const uint32_t mdi_hart_select_input_size = sizeof(device_mgmt_api::mdi_hart_selection_t);
+    device_mgmt_api::mdi_hart_selection_t mdi_hart_select_input_buff;
+    mdi_hart_select_input_buff.shire_id = shireID;
+    mdi_hart_select_input_buff.thread_mask = threadMask;
+    int32_t hart_select_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_SELECT_HART,
+                                (char*)&mdi_hart_select_input_buff, mdi_hart_select_input_size,
+                                (char*)&hart_select_status, sizeof(int32_t), hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(hart_select_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    /* Halt Hart */
+    uint32_t hart_control_input_size = sizeof(device_mgmt_api::mdi_hart_control_t);
+    char hart_control_input_buff[hart_control_input_size] = {device_mgmt_api::MDI_HART_CTRL_FLAG_HALT_HART};
+    int32_t halt_hart_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_HALT_HART, hart_control_input_buff,
+                                hart_control_input_size, (char*)&halt_hart_status, sizeof(int32_t), hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(halt_hart_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    const uint32_t csr_read_input_size = sizeof(device_mgmt_api::mdi_csr_read_t);
+    device_mgmt_api::mdi_csr_read_t csr_read_input_buff;
+    csr_read_input_buff.hart_id = hartID;
+    /* PC offset */
+    csr_read_input_buff.csr_name = csrName;
+    uint64_t intial_pc_addr = 0;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_READ_CSR, (char*)&csr_read_input_buff,
+                                csr_read_input_size, (char*)&intial_pc_addr, sizeof(uint64_t), hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "HartID:" << std::hex << csr_read_input_buff.hart_id << " Initial PC Value:" << std::hex
+                 << intial_pc_addr;
+
+    const uint32_t csr_write_input_size = sizeof(device_mgmt_api::mdi_csr_write_t);
+    device_mgmt_api::mdi_csr_write_t csr_write_input_buff;
+    csr_write_input_buff.hart_id = hartID;
+    csr_write_input_buff.csr_name = csrName;
+    csr_write_input_buff.data = csrData;
+    uint64_t dummy = 0;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_WRITE_CSR, (char*)&csr_write_input_buff,
+                                csr_write_input_size, (char*)&dummy, sizeof(uint64_t), hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    uint64_t updated_pc_addr = 0;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_READ_CSR, (char*)&csr_read_input_buff,
+                                csr_read_input_size, (char*)&updated_pc_addr, sizeof(uint64_t), hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "HartID:" << std::hex << csr_read_input_buff.hart_id << " Updated PC Value:" << std::hex
+                 << updated_pc_addr;
+
+    EXPECT_EQ(csr_write_input_buff.data, updated_pc_addr);
+
+    /* Reset the PC to initial PC address */
+    csr_write_input_buff.data = intial_pc_addr; /* Reset it to initial PC address */
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_WRITE_CSR, (char*)&csr_write_input_buff,
+                                csr_write_input_size, (char*)&dummy, sizeof(uint64_t), hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    updated_pc_addr = 0;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_READ_CSR, (char*)&csr_read_input_buff,
+                                csr_read_input_size, (char*)&updated_pc_addr, sizeof(uint64_t), hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "HartID:" << std::hex << csr_read_input_buff.hart_id << " Changed PC to initial value:" << std::hex
+                 << updated_pc_addr;
+
+    EXPECT_EQ(intial_pc_addr, updated_pc_addr);
+
+    /* Resume Hart */
+    hart_control_input_size = sizeof(device_mgmt_api::mdi_hart_control_t);
+    hart_control_input_buff[hart_control_input_size] = {device_mgmt_api::MDI_HART_CTRL_FLAG_RESUME_HART};
+    int32_t resume_hart_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_RESUME_HART, hart_control_input_buff,
+                                hart_control_input_size, (char*)&resume_hart_status, sizeof(int32_t), hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(resume_hart_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    /* Unselect Hart */
+    int32_t unselect_hart_status = device_mgmt_api::DM_STATUS_ERROR;
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_MDI_UNSELECT_HART,
+                                (char*)&mdi_hart_select_input_buff, mdi_hart_select_input_size,
+                                (char*)&unselect_hart_status, sizeof(int32_t), hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    EXPECT_EQ(unselect_hart_status, device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+  }
+}
+
+void TestDevMgmtApiSyncCmds::resetSOC(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_RESET_ETSOC, nullptr, 0, nullptr, 0,
+                                hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Check if trace control works after reset
+    controlTraceLogging();
+  }
+}
+
+void TestDevMgmtApiSyncCmds::resetSOCWithOpsInUse(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+    auto hst_latency = std::make_unique<uint32_t>();
+    auto dev_latency = std::make_unique<uint64_t>();
+    try {
+      dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_RESET_ETSOC, nullptr, 0, nullptr, 0,
+                        hst_latency.get(), dev_latency.get(), DURATION2MS(end - Clock::now()));
+    } catch (const dev::Exception& ex) {
+      // ETSOC reset is not permitted when Ops node is open.
+      EXPECT_THAT(ex.what(), testing::HasSubstr("Operation not permitted"));
+    }
+  }
+}
+
+void TestDevMgmtApiSyncCmds::testShireCacheConfig(bool singleDevice) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement& dm = (*dmi)(devLayer_.get());
+  auto end = Clock::now() + std::chrono::milliseconds(FLAGS_exec_timeout_ms);
+  auto hst_latency = std::make_unique<uint32_t>();
+  auto dev_latency = std::make_unique<uint64_t>();
+
+  auto deviceCount = singleDevice ? 1 : dm.getDevicesCount();
+  for (int deviceIdx = 0; deviceIdx < deviceCount; deviceIdx++) {
+
+    /* Fetch shire cache config */
+    device_mgmt_api::shire_cache_config_t sc_config = {0};
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_SHIRE_CACHE_CONFIG, nullptr, 0,
+                                (char*)&sc_config, sizeof(sc_config), hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+    DV_LOG(INFO) << "SC config scp size: " << sc_config.scp_size << "  L2 size " << sc_config.l2_size << " L3 size "
+                 << sc_config.l3_size;
+
+    device_mgmt_api::shire_cache_config_t sc_config_modified = {64, 32, 32};
+    DV_LOG(INFO) << "Modifying SC config to scp size: " << sc_config_modified.scp_size << "  L2 size "
+                 << sc_config_modified.l2_size << " L3 size " << sc_config_modified.l3_size;
+
+    /* Modify shire cache config*/
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_SHIRE_CACHE_CONFIG,
+                                (char*)&sc_config_modified, sizeof(sc_config_modified), nullptr, 0, hst_latency.get(),
+                                dev_latency.get(), DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    /* Fetch shire cache config */
+    device_mgmt_api::shire_cache_config_t tmp_sc_config = {0};
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_GET_SHIRE_CACHE_CONFIG, nullptr, 0,
+                                (char*)&tmp_sc_config, sizeof(tmp_sc_config), hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    /* Validate if the configuration has changed */
+    EXPECT_EQ(sc_config_modified.scp_size, tmp_sc_config.scp_size);
+    EXPECT_EQ(sc_config_modified.l2_size, tmp_sc_config.l2_size);
+    EXPECT_EQ(sc_config_modified.l3_size, tmp_sc_config.l3_size);
+
+    /* Restore shire cache config values */
+    ASSERT_EQ(dm.serviceRequest(deviceIdx, device_mgmt_api::DM_CMD::DM_CMD_SET_SHIRE_CACHE_CONFIG, (char*)&sc_config,
+                                sizeof(sc_config), nullptr, 0, hst_latency.get(), dev_latency.get(),
+                                DURATION2MS(end - Clock::now())),
+              device_mgmt_api::DM_STATUS_SUCCESS);
+    DV_LOG(INFO) << "Service Request Completed for Device: " << deviceIdx;
+
+    // Check if trace control works after reset
+    controlTraceLogging();
+  }
+}
diff --git a/device-management/tests/TestDevMgmtApiSyncCmds.h b/device-management/tests/TestDevMgmtApiSyncCmds.h
new file mode 100644
index 00000000..baa30c30
--- /dev/null
+++ b/device-management/tests/TestDevMgmtApiSyncCmds.h
@@ -0,0 +1,354 @@
+//******************************************************************************
+// Copyright (C) 2020 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#ifndef TEST_DEVICE_M_H
+#define TEST_DEVICE_M_H
+
+#include "DevErrorEvent.h"
+#include "deviceManagement/DeviceManagement.h"
+#include "utils.h"
+
+#include <cstring>
+#include <dlfcn.h>
+#include <gflags/gflags.h>
+#include <glog/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace dev;
+using namespace device_management;
+using Clock = std::chrono::system_clock;
+using Timepoint = Clock::time_point;
+using TimeDuration = Clock::duration;
+
+#define MAX_DEVICE_NODE (250)
+#define INPUT_SIZE_TEST (1)
+#define OUTPUT_SIZE_TEST (24)
+#define DM_CMD_INVALID (256)
+#define INVALID_INPUT_SIZE (0)
+#define INVALID_OUTPUT_SIZE (0)
+#define ECID_LOT_ID_LENGTH 6
+#define FRU_SIZE 256
+
+DECLARE_bool(enable_trace_dump);
+DECLARE_bool(enable_bin_trace_dump);
+DECLARE_string(trace_base_dir);
+DECLARE_string(trace_txt_dir);
+DECLARE_string(trace_bin_dir);
+
+typedef struct {
+  uint64_t lot_id;
+  uint8_t wafer_id;
+  uint8_t x_coordinate;
+  uint8_t y_coordinate;
+  char lot_id_str[ECID_LOT_ID_LENGTH + 1];
+} ecid_t;
+
+enum class Target { Silicon, Bemu, FullBoot, FullChip, SysEMU, Loopback };
+
+class TestDevMgmtApiSyncCmds : public ::testing::Test {
+protected:
+  device_management::getDM_t getInstance();
+
+  // Functional tests asset tracking service
+  void getModuleManufactureName(bool singleDevice);
+  void getModulePartNumber(bool singleDevice);
+  void getFRUTest(bool singleDevice);
+  void setFRUTest(bool singleDevice);
+  void setAndGetModulePartNumber(bool singleDevice);
+  void getModuleSerialNumber(bool singleDevice);
+  void getASICChipRevision(bool singleDevice);
+  void getModulePCIEPortsMaxSpeed(bool singleDevice);
+  void getModuleMemorySizeMB(bool singleDevice);
+  void getModuleRevision(bool singleDevice);
+  void getModuleFormFactor(bool singleDevice);
+  void getModuleMemoryVendorPartNumber(bool singleDevice);
+  void getModuleMemoryType(bool singleDevice);
+
+  // Functional tests thermal and power management service
+  void getModulePowerState(bool singleDevice);
+  void setAndGetModuleStaticTDPLevel(bool singleDevice);
+  void setAndGetModuleTemperatureThreshold(bool singleDevice);
+  void getModuleResidencyThrottleState(bool singleDevice);
+  void getModuleUptime(bool singleDevice);
+  void getModulePower(bool singleDevice);
+  void getAsicVoltage(bool singleDevice);
+  void getModuleVoltage(bool singleDevice);
+  void setAndGetModuleVoltage(bool singleDevice);
+  void getModuleCurrentTemperature(bool singleDevice);
+  void getModuleResidencyPowerState(bool singleDevice);
+  void setModuleActivePowerManagement(bool singleDevice);
+  void setThrottlePowerStatus(bool singleDevice);
+  void setAndGetModuleFrequency(bool singleDevice);
+  void dmStatsRunControl(bool singleDevice);
+
+  // Functional tests historical extreme value service
+  void getModuleMaxTemperature(bool singleDevice);
+  void getModuleMaxMemoryErrors(bool singleDevice);
+  void getModuleMaxDDRBW(bool singleDevice);
+
+  // Functional tests error control service
+  void setAndGetDDRECCThresholdCount(bool singleDevice);
+  void setAndGetSRAMECCThresholdCount(bool singleDevice);
+  void setAndGetPCIEECCThresholdCount(bool singleDevice);
+
+  // Functional tests link management service
+  void getPCIEECCUECCCount(bool singleDevice);
+  void getDDRECCUECCCount(bool singleDevice);
+  void getSRAMECCUECCCount(bool singleDevice);
+  void getDDRBWCounter(bool singleDevice);
+  void setPCIELinkSpeed(bool singleDevice);
+  void setPCIELaneWidth(bool singleDevice);
+  void setPCIERetrainPhy(bool singleDevice);
+
+  // Functional tests performance management service
+  void getASICFrequencies(bool singleDevice);
+  void getDRAMBW(bool singleDevice);
+  void getDRAMCapacityUtilization(bool singleDevice);
+  void getASICPerCoreDatapathUtilization(bool singleDevice);
+  void getASICUtilization(bool singleDevice);
+  void getASICStalls(bool singleDevice);
+  void getASICLatency(bool singleDevice);
+  void getMMErrorCount(bool singleDevice);
+  void getFWBootstatus(bool singleDevice);
+  void getModuleFWRevision(bool singleDevice);
+  void setSpRootCertificate(bool singleDevice);
+  void setFirmwareUpdateImage(bool singleDevice, bool resetDev, int iterations = 1);
+  void testShireCacheConfig(bool singleDevice);
+
+  // Integration tests for SP tracing and error events
+  void initTestTrace();
+  void initEventProcessor();
+  void launchEventProcessor(int deviceIdx);
+  void cleanupEventProcessor();
+  void initDevErrorEvent(std::initializer_list<DevErrorEvent::EventType> skipList = {
+                           DevErrorEvent::EventType::SpTraceBufferFullCeEvent});
+  void checkDevErrorEvent();
+  bool decodeTraceEvents(int deviceIdx, const std::vector<std::byte>& traceBuf, TraceBufferType bufferType) const;
+  void dumpRawTraceBuffer(int deviceIdx, const std::vector<std::byte>& traceBuf, TraceBufferType bufferType) const;
+
+  void controlTraceLogging(void);
+  bool extractAndPrintTraceData(bool singleDevice, TraceBufferType bufferType);
+  void serializeAccessMgmtNode(bool singleDevice);
+  void getDeviceErrorEvents(bool singleDevice);
+  void setTraceControl(bool singleDevice, uint32_t control_bitmap);
+  void setTraceConfigure(bool singleDevice, uint32_t event_type, uint32_t filter_level);
+  void getTraceBuffer(bool singleDevice, TraceBufferType bufferType);
+
+  // Security tests general checks
+  void isUnsupportedService(bool singleDevice);
+  void testInvalidCmdCode(bool singleDevice);
+
+  // Security tests asset tracking service
+  void getModuleManufactureNameInvalidOutputSize(bool singleDevice);
+  void getModuleManufactureNameInvalidDeviceNode(bool singleDevice);
+  void getModuleManufactureNameInvalidHostLatency(bool singleDevice);
+  void getModuleManufactureNameInvalidDeviceLatency(bool singleDevice);
+  void getModuleManufactureNameInvalidOutputBuffer(bool singleDevice);
+
+  // Security tests thermal and power management service
+  void setModuleActivePowerManagementRange(bool singleDevice);
+  void setModuleActivePowerManagementRangeInvalidInputSize(bool singleDevice);
+  void setModuleActivePowerManagementRangeInvalidInputBuffer(bool singleDevice);
+
+  // Security tests historical extreme value service
+  void getHistoricalExtremeWithInvalidDeviceNode(bool singleDevice);
+  void getHistoricalExtremeWithInvalidHostLatency(bool singleDevice);
+  void getHistoricalExtremeWithInvalidDeviceLatency(bool singleDevice);
+  void getHistoricalExtremeWithInvalidOutputBuffer(bool singleDevice);
+  void getHistoricalExtremeWithInvalidOutputSize(bool singleDevice);
+
+  // Security tests error control service
+  void setDDRECCCountInvalidInputBuffer(bool singleDevice);
+  void setDDRECCCountInvalidInputSize(bool singleDevice);
+  void setDDRECCCountInvalidOutputSize(bool singleDevice);
+  void setDDRECCCountInvalidDeviceNode(bool singleDevice);
+  void setDDRECCCountInvalidHostLatency(bool singleDevice);
+  void setDDRECCCountInvalidDeviceLatency(bool singleDevice);
+  void setDDRECCCountInvalidOutputBuffer(bool singleDevice);
+  void setPCIEECCCountInvalidInputBuffer(bool singleDevice);
+  void setPCIEECCountInvalidInputSize(bool singleDevice);
+  void setPCIEECCountInvalidOutputSize(bool singleDevice);
+  void setPCIEECCountInvalidDeviceNode(bool singleDevice);
+  void setPCIEECCountInvalidHostLatency(bool singleDevice);
+  void setPCIEECCountInvalidDeviceLatency(bool singleDevice);
+  void setPCIEECCountInvalidOutputBuffer(bool singleDevice);
+  void setSRAMECCCountInvalidInputBuffer(bool singleDevice);
+  void setSRAMECCCountInvalidInputSize(bool singleDevice);
+  void setSRAMECCountInvalidOutputSize(bool singleDevice);
+  void setSRAMECCountInvalidDeviceNode(bool singleDevice);
+  void setSRAMECCountInvalidHostLatency(bool singleDevice);
+  void setSRAMECCountInvalidDeviceLatency(bool singleDevice);
+  void setSRAMECCountInvalidOutputBuffer(bool singleDevice);
+
+  // Security tests link management service
+  void setPCIELinkSpeedToInvalidLinkSpeed(bool singleDevice);
+  void setPCIELaneWidthToInvalidLaneWidth(bool singleDevice);
+
+  // Security tests performance management
+  void testInvalidOutputSize(int32_t dmCmdType, bool singleDevice);
+  void testInvalidDeviceNode(int32_t dmCmdType, bool singleDevice);
+  void testInvalidHostLatency(int32_t dmCmdType, bool singleDevice);
+  void testInvalidDeviceLatency(int32_t dmCmdType, bool singleDevice);
+  void testInvalidOutputBuffer(int32_t dmCmdType, bool singleDevice);
+  void testInvalidInputBuffer(int32_t dmCmdType, bool singleDevice);
+  void testInvalidInputSize(int32_t dmCmdType, bool singleDevice);
+  void getASICFrequenciesInvalidOutputSize(bool singleDevice);
+  void getASICFrequenciesInvalidDeviceNode(bool singleDevice);
+  void getASICFrequenciesInvalidHostLatency(bool singleDevice);
+  void getASICFrequenciesInvalidDeviceLatency(bool singleDevice);
+  void getASICFrequenciesInvalidOutputBuffer(bool singleDevice);
+  void getDRAMBandwidthInvalidOutputSize(bool singleDevice);
+  void getDRAMBandwidthInvalidDeviceNode(bool singleDevice);
+  void getDRAMBandwidthInvalidHostLatency(bool singleDevice);
+  void getDRAMBandwidthInvalidDeviceLatency(bool singleDevice);
+  void getDRAMBandwidthInvalidOutputBuffer(bool singleDevice);
+  void getDRAMCapacityUtilizationInvalidOutputSize(bool singleDevice);
+  void getDRAMCapacityUtilizationInvalidDeviceNode(bool singleDevice);
+  void getDRAMCapacityUtilizationInvalidHostLatency(bool singleDevice);
+  void getDRAMCapacityUtilizationInvalidDeviceLatency(bool singleDevice);
+  void getDRAMCapacityUtilizationInvalidOutputBuffer(bool singleDevice);
+  void getASICPerCoreDatapathUtilizationInvalidOutputSize(bool singleDevice);
+  void getASICPerCoreDatapathUtilizationInvalidDeviceNode(bool singleDevice);
+  void getASICPerCoreDatapathUtilizationInvalidHostLatency(bool singleDevice);
+  void getASICPerCoreDatapathUtilizationInvalidDeviceLatency(bool singleDevice);
+  void getASICPerCoreDatapathUtilizationInvalidOutputBuffer(bool singleDevice);
+  void getASICUtilizationInvalidOutputSize(bool singleDevice);
+  void getASICUtilizationInvalidDeviceNode(bool singleDevice);
+  void getASICUtilizationInvalidHostLatency(bool singleDevice);
+  void getASICUtilizationInvalidDeviceLatency(bool singleDevice);
+  void getASICUtilizationInvalidOutputBuffer(bool singleDevice);
+  void getASICStallsInvalidOutputSize(bool singleDevice);
+  void getASICStallsInvalidDeviceNode(bool singleDevice);
+  void getASICStallsInvalidHostLatency(bool singleDevice);
+  void getASICStallsInvalidDeviceLatency(bool singleDevice);
+  void getASICStallsInvalidOutputBuffer(bool singleDevice);
+  void getASICLatencyInvalidOutputSize(bool singleDevice);
+  void getASICLatencyInvalidDeviceNode(bool singleDevice);
+  void getASICLatencyInvalidHostLatency(bool singleDevice);
+  void getASICLatencyInvalidDeviceLatency(bool singleDevice);
+  void getASICLatencyInvalidOutputBuffer(bool singleDevice);
+  void resetMM(bool singleDevice);
+  void resetMMWithOpsInUse(bool singleDevice);
+  void resetSOC(bool singleDevice);
+  void resetSOCWithOpsInUse(bool singleDevice);
+
+  // Functional tests for  MDI Run control/State Inspection APIs
+  void testRunControlCmdsSetandUnsetBreakpoint(uint64_t shireID, uint64_t threadMask, uint64_t hartID, uint64_t bpAddr);
+  void testRunControlCmdsGetHartStatus(uint64_t shireID, uint64_t threadMask, uint64_t hartID);
+  void testStateInspectionReadGPR(uint64_t shireID, uint64_t threadMask, uint64_t hartID);
+  void testStateInspectionWriteGPR(uint64_t shireID, uint64_t threadMask, uint64_t hartID, uint64_t writeTestData);
+  void testStateInspectionReadCSR(uint64_t shireID, uint64_t threadMask, uint64_t hartID, uint64_t csrName);
+  void testStateInspectionWriteCSR(uint64_t shireID, uint64_t threadMask, uint64_t hartID, uint64_t csrName,
+                                   uint64_t csrData);
+  void readMem_unprivileged(uint64_t readAddr);
+  void readMem_privileged(uint64_t readAddr);
+  void writeMem_unprivileged(uint64_t testInputData, uint64_t writeAddr);
+  void writeMem_privileged(uint64_t testInputData, uint64_t writeAddr);
+
+  /* DM test service APIs*/
+  void inline initDMTestFramework() {
+    handle_ = dlopen("libDM.so", RTLD_LAZY);
+    devLayer_ = IDeviceLayer::createPcieDeviceLayer(false, true);
+    initTestTrace();
+    controlTraceLogging();
+    initEventProcessor();
+    initDevErrorEvent({DevErrorEvent::EventType::SpTraceBufferFullCeEvent});
+  }
+  void inline cleanupDMTestFramework() {
+    eventProcessorRunning_ = false;
+    checkDevErrorEvent();
+    extractAndPrintTraceData(false /* multiple devices */, TraceBufferType::TraceBufferSP);
+    if (handle_ != nullptr) {
+      dlclose(handle_);
+    }
+  }
+
+  inline Target getTestTarget(void) const {
+    auto envTarget = getenv("TARGET");
+    auto currentTarget = Target::Silicon;
+    if (envTarget != nullptr) {
+      if (std::strncmp(envTarget, "silicon", 7) == 0) {
+        currentTarget = Target::Silicon;
+      } else if (std::strncmp(envTarget, "bemu", 4) == 0) {
+        currentTarget = Target::Bemu;
+      } else if (std::strncmp(envTarget, "fullboot", 8) == 0) {
+        currentTarget = Target::FullBoot;
+      } else if (std::strncmp(envTarget, "fullchip", 8) == 0) {
+        currentTarget = Target::FullChip;
+      } else if (std::strncmp(envTarget, "sysemu", 6) == 0) {
+        currentTarget = Target::SysEMU;
+      } else if (std::strncmp(envTarget, "loopback", 8) == 0) {
+        currentTarget = Target::Loopback;
+      } else {
+        DV_LOG(INFO) << "Unknown target: " << envTarget << ", using default target (silicon)";
+      }
+    }
+    return currentTarget;
+  }
+
+  inline bool targetInList(std::initializer_list<Target> list) {
+    return std::find(list.begin(), list.end(), getTestTarget()) != list.end();
+  }
+
+  inline bool isParallelRun(void) const {
+    auto envParallel = getenv("PARALLEL");
+    if (envParallel != nullptr && envParallel[0] != '\0') {
+      return true;
+    }
+    return false;
+  }
+
+  void inline setDevErrorEventCheckList(const std::vector<DevErrorEvent::EventType>& checkList) {
+    static std::remove_const_t<std::remove_reference_t<decltype(checkList)>> fullList;
+    static std::once_flag listOnceFlag;
+    std::call_once(listOnceFlag, []() {
+      for (auto typeIdx = 0U; typeIdx < static_cast<uint8_t>(DevErrorEvent::EventType::TotalEvents); typeIdx++) {
+        fullList.push_back(static_cast<DevErrorEvent::EventType>(typeIdx));
+      }
+      assert(fullList.size() == static_cast<int>(DevErrorEvent::EventType::TotalEvents));
+    });
+    std::remove_const_t<std::remove_reference_t<decltype(checkList)>> sortedCheckList = checkList;
+    std::sort(sortedCheckList.begin(), sortedCheckList.end(), [this](auto a, auto b) { return a < b; });
+    devErrorEventSkipList_.clear();
+    std::set_difference(fullList.begin(), fullList.end(), sortedCheckList.begin(), sortedCheckList.end(),
+                        std::back_inserter(devErrorEventSkipList_), [this](auto a, auto b) { return a < b; });
+  }
+
+  void inline setDevErrorEventSkipList(const std::vector<DevErrorEvent::EventType>& list) {
+    devErrorEventSkipList_.clear();
+    std::copy(list.begin(), list.end(), std::back_inserter(devErrorEventSkipList_));
+  }
+
+  void inline addToDevErrorEventSkipList(const std::vector<DevErrorEvent::EventType>& list) {
+    for (auto eventType : list) {
+      if (auto it = std::find(devErrorEventSkipList_.begin(), devErrorEventSkipList_.end(), eventType);
+          it == devErrorEventSkipList_.end()) {
+        devErrorEventSkipList_.push_back(eventType);
+      }
+    }
+  }
+  void inline removeFromDevErrorEventSkipList(const std::vector<DevErrorEvent::EventType>& list) {
+    for (auto eventType : list) {
+      devErrorEventSkipList_.erase(std::remove(devErrorEventSkipList_.begin(), devErrorEventSkipList_.end(), eventType),
+                                   devErrorEventSkipList_.end());
+    }
+  }
+
+  void* handle_ = nullptr;
+  std::unique_ptr<IDeviceLayer> devLayer_;
+  logging::LoggerDefault logger_;
+  std::unordered_map<int, DevErrorEvent> eventsAtStartMap_;
+  std::vector<DevErrorEvent::EventType> devErrorEventSkipList_;
+  std::vector<std::thread> eventThreads_;
+  bool eventProcessorRunning_ = true;
+};
+
+#endif // TEST_DEVICE_M_H
diff --git a/device-management/tests/functional/FunctionalTestDevMgmtApiAssetTrackingCmds.cpp b/device-management/tests/functional/FunctionalTestDevMgmtApiAssetTrackingCmds.cpp
new file mode 100644
index 00000000..fbb556ab
--- /dev/null
+++ b/device-management/tests/functional/FunctionalTestDevMgmtApiAssetTrackingCmds.cpp
@@ -0,0 +1,148 @@
+//******************************************************************************
+// Copyright (C) 2020 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "TestDevMgmtApiSyncCmds.h"
+#include <dlfcn.h>
+#include <glog/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace dev;
+using namespace device_management;
+
+class FunctionalTestDevMgmtApiAssetTrackingCmds : public TestDevMgmtApiSyncCmds {
+  void SetUp() override {
+    initDMTestFramework();
+  }
+  void TearDown() override {
+    cleanupDMTestFramework();
+  }
+};
+
+TEST_F(FunctionalTestDevMgmtApiAssetTrackingCmds, getModuleManufactureName) {
+  if (targetInList({Target::FullBoot, Target::Silicon})) {
+    getModuleManufactureName(false /* Multiple devices */);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(FunctionalTestDevMgmtApiAssetTrackingCmds, getFRUTest) {
+  if (targetInList({Target::FullBoot, Target::Silicon})) {
+    getFRUTest(false /* Multiple devices */);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(FunctionalTestDevMgmtApiAssetTrackingCmds, setFRUTest) {
+  if (targetInList({Target::FullBoot, Target::Silicon})) {
+    setFRUTest(false /* Multiple devices */);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(FunctionalTestDevMgmtApiAssetTrackingCmds, getModulePartNumber) {
+  if (targetInList({Target::FullBoot, Target::Silicon})) {
+    getModulePartNumber(false /* Multiple devices */);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(FunctionalTestDevMgmtApiAssetTrackingCmds, setAndGetModulePartNumber) {
+  if (targetInList({Target::FullBoot, Target::Silicon})) {
+    setAndGetModulePartNumber(false /* Multiple devices */);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(FunctionalTestDevMgmtApiAssetTrackingCmds, getModuleSerialNumber) {
+  if (targetInList({Target::FullBoot, Target::Silicon})) {
+    getModuleSerialNumber(false /* Multiple devices */);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(FunctionalTestDevMgmtApiAssetTrackingCmds, getASICChipRevision) {
+  // TODO: SW-13220: Enable back on Target::Silicon, following failure is seen with V2/V3 card
+  // received: 255, expected: 160
+  // if (targetInList({Target::FullBoot, Target::FullChip, Target::Bemu, Target::Silicon})) {
+  if (targetInList({Target::FullBoot, Target::FullChip, Target::Bemu})) {
+    getASICChipRevision(false /* Multiple devices */);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(FunctionalTestDevMgmtApiAssetTrackingCmds, getModulePCIEPortsMaxSpeed) {
+  // Test not applicable on SysEMU
+  if (getTestTarget() != Target::SysEMU) {
+    getModulePCIEPortsMaxSpeed(false /* Multiple devices */);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(FunctionalTestDevMgmtApiAssetTrackingCmds, getModuleMemorySizeMB) {
+  if (targetInList({Target::FullBoot, Target::Silicon})) {
+    getModuleMemorySizeMB(false /* Multiple devices */);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(FunctionalTestDevMgmtApiAssetTrackingCmds, getModuleRevision) {
+  if (targetInList({Target::FullBoot, Target::Silicon})) {
+    getModuleRevision(false /* Multiple devices */);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(FunctionalTestDevMgmtApiAssetTrackingCmds, getModuleFormFactor) {
+  if (targetInList({Target::FullBoot, Target::Silicon})) {
+    getModuleFormFactor(false /* Multiple devices */);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(FunctionalTestDevMgmtApiAssetTrackingCmds, getModuleMemoryVendorPartNumber) {
+  getModuleMemoryVendorPartNumber(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiAssetTrackingCmds, getModuleMemoryType) {
+  getModuleMemoryType(false /* Multiple devices */);
+}
+
+int main(int argc, char** argv) {
+  google::InitGoogleLogging(argv[0]);
+  google::SetCommandLineOption("GLOG_minloglevel", "0");
+  FLAGS_minloglevel = 0;
+  FLAGS_logtostderr = 1;
+  testing::InitGoogleTest(&argc, argv);
+  google::ParseCommandLineFlags(&argc, &argv, true);
+  return RUN_ALL_TESTS();
+}
diff --git a/device-management/tests/functional/FunctionalTestDevMgmtApiErrorControlCmds.cpp b/device-management/tests/functional/FunctionalTestDevMgmtApiErrorControlCmds.cpp
new file mode 100644
index 00000000..28d7a16c
--- /dev/null
+++ b/device-management/tests/functional/FunctionalTestDevMgmtApiErrorControlCmds.cpp
@@ -0,0 +1,49 @@
+//******************************************************************************
+// Copyright (C) 2020 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "TestDevMgmtApiSyncCmds.h"
+#include <dlfcn.h>
+#include <glog/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace dev;
+using namespace device_management;
+
+class FunctionalTestDevMgmtApiErrorControlCmds : public TestDevMgmtApiSyncCmds {
+  void SetUp() override {
+    initDMTestFramework();
+  }
+  void TearDown() override {
+    cleanupDMTestFramework();
+  }
+};
+
+TEST_F(FunctionalTestDevMgmtApiErrorControlCmds, setAndGetDDRECCThresholdCount) {
+  setAndGetDDRECCThresholdCount(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiErrorControlCmds, setAndGetSRAMECCThresholdCount) {
+  setAndGetSRAMECCThresholdCount(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiErrorControlCmds, setAndGetPCIEECCThresholdCount) {
+  setAndGetPCIEECCThresholdCount(false /* Multiple devices */);
+}
+
+int main(int argc, char** argv) {
+  google::InitGoogleLogging(argv[0]);
+  google::SetCommandLineOption("GLOG_minloglevel", "0");
+  FLAGS_minloglevel = 0;
+  FLAGS_logtostderr = 1;
+  testing::InitGoogleTest(&argc, argv);
+  google::ParseCommandLineFlags(&argc, &argv, true);
+  return RUN_ALL_TESTS();
+}
diff --git a/device-management/tests/functional/FunctionalTestDevMgmtApiFirmwareMgmtCmds.cpp b/device-management/tests/functional/FunctionalTestDevMgmtApiFirmwareMgmtCmds.cpp
new file mode 100644
index 00000000..95f1d8b0
--- /dev/null
+++ b/device-management/tests/functional/FunctionalTestDevMgmtApiFirmwareMgmtCmds.cpp
@@ -0,0 +1,133 @@
+//******************************************************************************
+// Copyright (C) 2020 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "TestDevMgmtApiSyncCmds.h"
+#include <dlfcn.h>
+#include <glog/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace dev;
+using namespace device_management;
+
+class FunctionalTestDevMgmtApiFirmwareMgmtCmds : public TestDevMgmtApiSyncCmds {
+  void SetUp() override {
+    handle_ = dlopen("libDM.so", RTLD_LAZY);
+    devLayer_ = IDeviceLayer::createPcieDeviceLayer(false, true);
+    initTestTrace();
+    controlTraceLogging();
+    initDevErrorEvent();
+    // NOTE: DM Event processor cannot run during ETSOC reset
+    // TODO: SW-18858: Add support to stop and restart event processor for ETSOC
+    // reset keeping the option to run the event processor threads in detach mode
+  }
+  void TearDown() override {
+    checkDevErrorEvent();
+    extractAndPrintTraceData(false /* multiple devices */, TraceBufferType::TraceBufferSP);
+    if (handle_ != nullptr) {
+      dlclose(handle_);
+    }
+  }
+};
+
+TEST_F(FunctionalTestDevMgmtApiFirmwareMgmtCmds, getMMErrorCount) {
+  initEventProcessor();
+  getMMErrorCount(false /* Multiple devices */);
+  cleanupEventProcessor();
+}
+
+TEST_F(FunctionalTestDevMgmtApiFirmwareMgmtCmds, getFWBootstatus) {
+  // TODO: SW-13807: Enable back on silicon after fix
+  // if (targetInList({Target::FullBoot, Target::Silicon})) {
+  if (targetInList({Target::FullBoot})) {
+    initEventProcessor();
+    getFWBootstatus(false /* Multiple devices */);
+    cleanupEventProcessor();
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(FunctionalTestDevMgmtApiFirmwareMgmtCmds, getModuleFWRevision) {
+  if (targetInList({Target::FullBoot, Target::Silicon})) {
+    initEventProcessor();
+    getModuleFWRevision(false /* Multiple devices */);
+    cleanupEventProcessor();
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+/*TEST_F(FunctionalTestDevMgmtApiFirmwareMgmtCmds, setSpRootCertificate) {
+  setSpRootCertificate(false);
+}*/
+
+TEST_F(FunctionalTestDevMgmtApiFirmwareMgmtCmds, DISABLED_updateFirmwareImage) {
+  if (targetInList({Target::FullBoot, Target::Silicon})) {
+    if (isParallelRun()) {
+      DV_LOG(INFO) << "Skipping the test since it cannot be run in parallel with ops device";
+      FLAGS_enable_trace_dump = false;
+      return;
+    }
+    initEventProcessor();
+    setFirmwareUpdateImage(false /* Multiple Devices */, false);
+    cleanupEventProcessor();
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(FunctionalTestDevMgmtApiFirmwareMgmtCmds, resetSOCSingleDevice) {
+  if (isParallelRun()) {
+    DV_LOG(INFO) << "Skipping the test since it cannot be run in parallel with ops device";
+    FLAGS_enable_trace_dump = false;
+    return;
+  }
+  // NOTE: Skip checking of device error events in ETSOC reset tests because error counters
+  // are also reset during the reset
+  setDevErrorEventCheckList({});
+  resetSOC(true /* Single Device */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiFirmwareMgmtCmds, resetSOCMultiDevice) {
+  if (isParallelRun()) {
+    DV_LOG(INFO) << "Skipping the test since it cannot be run in parallel with ops device";
+    FLAGS_enable_trace_dump = false;
+    return;
+  }
+  // NOTE: Skip checking of device error events in ETSOC reset tests because error counters
+  // are also reset during the reset
+  setDevErrorEventCheckList({});
+  resetSOC(false /* Multiple Devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiFirmwareMgmtCmds, testShireCacheConfig) {
+  if (targetInList({Target::FullBoot, Target::Silicon})) {
+    initEventProcessor();
+    testShireCacheConfig(false /* Multiple Devices */);
+    cleanupEventProcessor();
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+int main(int argc, char** argv) {
+  google::InitGoogleLogging(argv[0]);
+  google::SetCommandLineOption("GLOG_minloglevel", "0");
+  FLAGS_minloglevel = 0;
+  FLAGS_logtostderr = 1;
+  testing::InitGoogleTest(&argc, argv);
+  google::ParseCommandLineFlags(&argc, &argv, true);
+  return RUN_ALL_TESTS();
+}
diff --git a/device-management/tests/functional/FunctionalTestDevMgmtApiHistoricalExtremeValCmds.cpp b/device-management/tests/functional/FunctionalTestDevMgmtApiHistoricalExtremeValCmds.cpp
new file mode 100644
index 00000000..8e08ca20
--- /dev/null
+++ b/device-management/tests/functional/FunctionalTestDevMgmtApiHistoricalExtremeValCmds.cpp
@@ -0,0 +1,49 @@
+//******************************************************************************
+// Copyright (C) 2020 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "TestDevMgmtApiSyncCmds.h"
+#include <dlfcn.h>
+#include <glog/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace dev;
+using namespace device_management;
+
+class FunctionalTestDevMgmtApiHistoricalExtremeValCmds : public TestDevMgmtApiSyncCmds {
+  void SetUp() override {
+    initDMTestFramework();
+  }
+  void TearDown() override {
+    cleanupDMTestFramework();
+  }
+};
+
+TEST_F(FunctionalTestDevMgmtApiHistoricalExtremeValCmds, getModuleMaxTemperature) {
+  getModuleMaxTemperature(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiHistoricalExtremeValCmds, getModuleMaxMemoryErrors) {
+  getModuleMaxMemoryErrors(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiHistoricalExtremeValCmds, getModuleMaxDDRBW) {
+  getModuleMaxDDRBW(false /* Multiple devices */);
+}
+
+int main(int argc, char** argv) {
+  google::InitGoogleLogging(argv[0]);
+  google::SetCommandLineOption("GLOG_minloglevel", "0");
+  FLAGS_minloglevel = 0;
+  FLAGS_logtostderr = 1;
+  testing::InitGoogleTest(&argc, argv);
+  google::ParseCommandLineFlags(&argc, &argv, true);
+  return RUN_ALL_TESTS();
+}
diff --git a/device-management/tests/functional/FunctionalTestDevMgmtApiLinkMgmtCmds.cpp b/device-management/tests/functional/FunctionalTestDevMgmtApiLinkMgmtCmds.cpp
new file mode 100644
index 00000000..de875997
--- /dev/null
+++ b/device-management/tests/functional/FunctionalTestDevMgmtApiLinkMgmtCmds.cpp
@@ -0,0 +1,94 @@
+//******************************************************************************
+// Copyright (C) 2020 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "TestDevMgmtApiSyncCmds.h"
+#include <dlfcn.h>
+#include <glog/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace dev;
+using namespace device_management;
+
+class FunctionalTestDevMgmtApiLinkMgmtCmds : public TestDevMgmtApiSyncCmds {
+  void SetUp() override {
+    initDMTestFramework();
+  }
+  void TearDown() override {
+    cleanupDMTestFramework();
+  }
+};
+
+TEST_F(FunctionalTestDevMgmtApiLinkMgmtCmds, getPCIEECCUECCCount) {
+  getPCIEECCUECCCount(false /* Multiple devices */);
+}
+
+/*
+TEST_F(FunctionalTestDevMgmtApiLinkMgmtCmds, setPCIEReset) {
+  getDM_t dmi = getInstance();
+  ASSERT_TRUE(dmi);
+  DeviceManagement &dm = (*dmi)(devLayer_.get());
+
+  const uint32_t input_size = sizeof(device_mgmt_api::pcie_reset_e);
+  const char input_buff[input_size] = {device_mgmt_api::PCIE_RESET_FLR};
+
+  //Device rsp will be of type device_mgmt_default_rsp_t and payload is uint32_t
+  const uint32_t output_size = sizeof(uint32_t);
+  char output_buff[output_size] = {0};
+  auto hst_latency = std::make_unique<uint32_t>();
+  auto dev_latency = std::make_unique<uint64_t>();
+
+  ASSERT_EQ(dm.serviceRequest("et0_mgmt", device_mgmt_api::DM_CMD::DM_CMD_SET_PCIE_RESET, input_buff, input_size,
+                              output_buff, output_size, hst_latency.get(), dev_latency.get(), 2000),
+            device_mgmt_api::DM_STATUS_SUCCESS);
+
+  ASSERT_EQ(output_buff[0], device_mgmt_api::DM_STATUS_SUCCESS);
+}
+*/
+
+TEST_F(FunctionalTestDevMgmtApiLinkMgmtCmds, getDDRECCUECCCount) {
+  getDDRECCUECCCount(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiLinkMgmtCmds, getSRAMECCUECCCount) {
+  getSRAMECCUECCCount(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiLinkMgmtCmds, getDDRBWCounter) {
+  getDDRBWCounter(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiLinkMgmtCmds, setPCIELinkSpeed) {
+  // TODO: SW-13272: Enable it back for Target::Silicon
+  if (getTestTarget() != Target::Silicon) {
+    setPCIELinkSpeed(false /* Multiple devices */);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(FunctionalTestDevMgmtApiLinkMgmtCmds, setPCIELaneWidth) {
+  setPCIELaneWidth(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiLinkMgmtCmds, setPCIERetrainPhy) {
+  setPCIERetrainPhy(false /* Multiple devices */);
+}
+
+int main(int argc, char** argv) {
+  google::InitGoogleLogging(argv[0]);
+  google::SetCommandLineOption("GLOG_minloglevel", "0");
+  FLAGS_minloglevel = 0;
+  FLAGS_logtostderr = 1;
+  testing::InitGoogleTest(&argc, argv);
+  google::ParseCommandLineFlags(&argc, &argv, true);
+  return RUN_ALL_TESTS();
+}
diff --git a/device-management/tests/functional/FunctionalTestDevMgmtApiPerfMgmtCmds.cpp b/device-management/tests/functional/FunctionalTestDevMgmtApiPerfMgmtCmds.cpp
new file mode 100644
index 00000000..f9f82099
--- /dev/null
+++ b/device-management/tests/functional/FunctionalTestDevMgmtApiPerfMgmtCmds.cpp
@@ -0,0 +1,65 @@
+//******************************************************************************
+// Copyright (C) 2020 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "TestDevMgmtApiSyncCmds.h"
+#include <dlfcn.h>
+#include <glog/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace dev;
+using namespace device_management;
+
+class FunctionalTestDevMgmtApiPerfMgmtCmds : public TestDevMgmtApiSyncCmds {
+  void SetUp() override {
+    initDMTestFramework();
+  }
+  void TearDown() override {
+    cleanupDMTestFramework();
+  }
+};
+
+TEST_F(FunctionalTestDevMgmtApiPerfMgmtCmds, getASICFrequencies) {
+  getASICFrequencies(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiPerfMgmtCmds, getDRAMBW) {
+  getDRAMBW(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiPerfMgmtCmds, getDRAMCapacityUtilization) {
+  getDRAMCapacityUtilization(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiPerfMgmtCmds, getASICPerCoreDatapathUtilization) {
+  getASICPerCoreDatapathUtilization(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiPerfMgmtCmds, getASICUtilization) {
+  getASICUtilization(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiPerfMgmtCmds, getASICStalls) {
+  getASICStalls(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiPerfMgmtCmds, getASICLatency) {
+  getASICLatency(false /* Multiple devices */);
+}
+
+int main(int argc, char** argv) {
+  google::InitGoogleLogging(argv[0]);
+  google::SetCommandLineOption("GLOG_minloglevel", "0");
+  FLAGS_minloglevel = 0;
+  FLAGS_logtostderr = 1;
+  testing::InitGoogleTest(&argc, argv);
+  google::ParseCommandLineFlags(&argc, &argv, true);
+  return RUN_ALL_TESTS();
+}
diff --git a/device-management/tests/functional/FunctionalTestDevMgmtApiThermalAndPowerMonitoringCmds.cpp b/device-management/tests/functional/FunctionalTestDevMgmtApiThermalAndPowerMonitoringCmds.cpp
new file mode 100644
index 00000000..c4320c07
--- /dev/null
+++ b/device-management/tests/functional/FunctionalTestDevMgmtApiThermalAndPowerMonitoringCmds.cpp
@@ -0,0 +1,110 @@
+//******************************************************************************
+// Copyright (C) 2020 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "TestDevMgmtApiSyncCmds.h"
+#include <dlfcn.h>
+#include <glog/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace dev;
+using namespace device_management;
+
+class FunctionalTestDevMgmtApiThermalAndPowerMonitoringCmds : public TestDevMgmtApiSyncCmds {
+  void SetUp() override {
+    initDMTestFramework();
+  }
+  void TearDown() override {
+    cleanupDMTestFramework();
+  }
+};
+
+TEST_F(FunctionalTestDevMgmtApiThermalAndPowerMonitoringCmds, getModulePowerState) {
+  getModulePowerState(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiThermalAndPowerMonitoringCmds, setAndGetModuleStaticTDPLevel) {
+  setAndGetModuleStaticTDPLevel(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiThermalAndPowerMonitoringCmds, setAndGetModuleTemperatureThreshold) {
+  setAndGetModuleTemperatureThreshold(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiThermalAndPowerMonitoringCmds, getModuleResidencyThrottleState) {
+  getModuleResidencyThrottleState(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiThermalAndPowerMonitoringCmds, getModuleUptime) {
+  getModuleUptime(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiThermalAndPowerMonitoringCmds, getModulePower) {
+  getModulePower(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiThermalAndPowerMonitoringCmds, getAsicVoltage) {
+  getAsicVoltage(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiThermalAndPowerMonitoringCmds, getModuleVoltage) {
+  getModuleVoltage(false /* Multiple devices */);
+}
+
+// TODO: SW-16538: Enable back when fixed
+TEST_F(FunctionalTestDevMgmtApiThermalAndPowerMonitoringCmds, DISABLED_setAndGetModuleVoltage) {
+  if (isParallelRun()) {
+    DV_LOG(INFO) << "Skipping the test since it cannot be run in parallel with ops device";
+    FLAGS_enable_trace_dump = false;
+    return;
+  }
+  setAndGetModuleVoltage(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiThermalAndPowerMonitoringCmds, getModuleCurrentTemperature) {
+  getModuleCurrentTemperature(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiThermalAndPowerMonitoringCmds, getModuleResidencyPowerState) {
+  getModuleResidencyPowerState(false /* Multiple devices */);
+}
+
+/* TODO: SW-19495: Enable the test once the issue is resolved */
+TEST_F(FunctionalTestDevMgmtApiThermalAndPowerMonitoringCmds, DISABLED_setModuleActivePowerManagement) {
+  setModuleActivePowerManagement(false /* Multiple devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiThermalAndPowerMonitoringCmds, setThrottlePowerStatus) {
+  setThrottlePowerStatus(false /* Multiple Devices */);
+}
+
+TEST_F(FunctionalTestDevMgmtApiThermalAndPowerMonitoringCmds, setAndGetModuleFrequency) {
+  if (isParallelRun()) {
+    DV_LOG(INFO) << "Skipping the test since it cannot be run in parallel with ops device";
+    FLAGS_enable_trace_dump = false;
+    return;
+  }
+  if (targetInList({Target::FullBoot, Target::FullChip, Target::Bemu, Target::Silicon})) {
+    setAndGetModuleFrequency(false /* Multiple devices */);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+int main(int argc, char** argv) {
+  google::InitGoogleLogging(argv[0]);
+  google::SetCommandLineOption("GLOG_minloglevel", "0");
+  FLAGS_minloglevel = 0;
+  FLAGS_logtostderr = 1;
+  testing::InitGoogleTest(&argc, argv);
+  google::ParseCommandLineFlags(&argc, &argv, true);
+  return RUN_ALL_TESTS();
+}
diff --git a/device-management/tests/integration/IntegrationTestDevMgmtApiCmds.cpp b/device-management/tests/integration/IntegrationTestDevMgmtApiCmds.cpp
new file mode 100644
index 00000000..9240d9ee
--- /dev/null
+++ b/device-management/tests/integration/IntegrationTestDevMgmtApiCmds.cpp
@@ -0,0 +1,78 @@
+//******************************************************************************
+// Copyright (C) 2020 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "TestDevMgmtApiSyncCmds.h"
+#include <dlfcn.h>
+#include <glog/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace dev;
+using namespace device_management;
+
+class IntegrationTestDevMgmtApiCmds : public TestDevMgmtApiSyncCmds {
+  void SetUp() override {
+    handle_ = dlopen("libDM.so", RTLD_LAZY);
+    devLayer_ = IDeviceLayer::createPcieDeviceLayer(false, true);
+    initTestTrace();
+    initEventProcessor();
+    controlTraceLogging();
+  }
+  void TearDown() override {
+    cleanupEventProcessor();
+    extractAndPrintTraceData(false /* multiple devices */, TraceBufferType::TraceBufferSP);
+    if (handle_ != nullptr) {
+      dlclose(handle_);
+    }
+  }
+};
+
+TEST_F(IntegrationTestDevMgmtApiCmds, serializeAccessMgmtNode) {
+  initDevErrorEvent();
+  serializeAccessMgmtNode(false);
+  checkDevErrorEvent();
+}
+
+TEST_F(IntegrationTestDevMgmtApiCmds, getDeviceErrorEvents) {
+  getDeviceErrorEvents(false /* Multiple devices */);
+}
+
+TEST_F(IntegrationTestDevMgmtApiCmds, setTraceControl) {
+  initDevErrorEvent();
+  DV_LOG(INFO) << "setTraceControl: verifying disable trace control command";
+  setTraceControl(false /* Multiple devices */, device_mgmt_api::TRACE_CONTROL_TRACE_DISABLE);
+  DV_LOG(INFO) << "setTraceControl: verifying enabling trace (dump to UART) control command";
+  setTraceControl(false /* Multiple devices */, device_mgmt_api::TRACE_CONTROL_TRACE_UART_ENABLE);
+  DV_LOG(INFO) << "setTraceControl: verifying enabling trace (dump to trace buffer) control command";
+  setTraceControl(false /* Multiple devices */,
+                  device_mgmt_api::TRACE_CONTROL_TRACE_ENABLE | device_mgmt_api::TRACE_CONTROL_TRACE_UART_ENABLE);
+  checkDevErrorEvent();
+}
+
+TEST_F(IntegrationTestDevMgmtApiCmds, setTraceConfigure) {
+  initDevErrorEvent();
+  setTraceConfigure(false /* Multiple devices */, device_mgmt_api::TRACE_CONFIGURE_EVENT_STRING,
+                    device_mgmt_api::TRACE_CONFIGURE_FILTER_MASK_EVENT_STRING_DEBUG);
+
+  /* Restore the logging level back */
+  setTraceConfigure(false /* Multiple devices */, device_mgmt_api::TRACE_CONFIGURE_EVENT_STRING,
+                    device_mgmt_api::TRACE_CONFIGURE_FILTER_MASK_EVENT_STRING_WARNING);
+  checkDevErrorEvent();
+}
+
+int main(int argc, char** argv) {
+  google::InitGoogleLogging(argv[0]);
+  google::SetCommandLineOption("GLOG_minloglevel", "0");
+  FLAGS_minloglevel = 0;
+  FLAGS_logtostderr = 1;
+  testing::InitGoogleTest(&argc, argv);
+  google::ParseCommandLineFlags(&argc, &argv, true);
+  return RUN_ALL_TESTS();
+}
diff --git a/device-management/tests/integration/IntegrationTestDevMgmtApiFirmwareMgmtCmds.cpp b/device-management/tests/integration/IntegrationTestDevMgmtApiFirmwareMgmtCmds.cpp
new file mode 100644
index 00000000..9031d19d
--- /dev/null
+++ b/device-management/tests/integration/IntegrationTestDevMgmtApiFirmwareMgmtCmds.cpp
@@ -0,0 +1,62 @@
+//******************************************************************************
+// Copyright (C) 2023 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "TestDevMgmtApiSyncCmds.h"
+#include <dlfcn.h>
+#include <glog/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace dev;
+using namespace device_management;
+
+class IntegrationTestDevMgmtApiFirmwareMgmtCmds : public TestDevMgmtApiSyncCmds {
+  void SetUp() override {
+    handle_ = dlopen("libDM.so", RTLD_LAZY);
+    devLayer_ = IDeviceLayer::createPcieDeviceLayer(false, true);
+    initTestTrace();
+    controlTraceLogging();
+    // NOTE: DM Event processor cannot run during ETSOC reset
+    // TODO: SW-18858: Add support to stop and restart event processor for ETSOC
+    // reset keeping the option to run the event processor threads in detach mode
+    // NOTE: Skip checking of device error events in ETSOC reset tests because error counters
+    // are also reset during the reset
+  }
+  void TearDown() override {
+    extractAndPrintTraceData(false /* multiple devices */, TraceBufferType::TraceBufferSP);
+    if (handle_ != nullptr) {
+      dlclose(handle_);
+    }
+  }
+};
+
+TEST_F(IntegrationTestDevMgmtApiFirmwareMgmtCmds, DISABLED_updateFirmwareImageAndReset) {
+  if (targetInList({Target::FullBoot, Target::Silicon})) {
+    if (isParallelRun()) {
+      DV_LOG(INFO) << "Skipping the test since it cannot be run in parallel with ops device";
+      FLAGS_enable_trace_dump = false;
+      return;
+    }
+    setFirmwareUpdateImage(false /* Multiple Devices */, true);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+int main(int argc, char** argv) {
+  google::InitGoogleLogging(argv[0]);
+  google::SetCommandLineOption("GLOG_minloglevel", "0");
+  FLAGS_minloglevel = 0;
+  FLAGS_logtostderr = 1;
+  testing::InitGoogleTest(&argc, argv);
+  google::ParseCommandLineFlags(&argc, &argv, true);
+  return RUN_ALL_TESTS();
+}
diff --git a/device-management/tests/integration/IntegrationTestDevMgmtApiTraceCmds.cpp b/device-management/tests/integration/IntegrationTestDevMgmtApiTraceCmds.cpp
new file mode 100644
index 00000000..642313cc
--- /dev/null
+++ b/device-management/tests/integration/IntegrationTestDevMgmtApiTraceCmds.cpp
@@ -0,0 +1,100 @@
+//******************************************************************************
+// Copyright (C) 2022 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "TestDevMgmtApiSyncCmds.h"
+#include <dlfcn.h>
+#include <glog/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace dev;
+using namespace device_management;
+
+class IntegrationTestDevMgmtApiTraceCmds : public TestDevMgmtApiSyncCmds {
+  void SetUp() override {
+    handle_ = dlopen("libDM.so", RTLD_LAZY);
+    devLayer_ = IDeviceLayer::createPcieDeviceLayer(false, true);
+    initTestTrace();
+    initEventProcessor();
+    initDevErrorEvent();
+  }
+  void TearDown() override {
+    cleanupEventProcessor();
+    checkDevErrorEvent();
+    if (handle_ != nullptr) {
+      dlclose(handle_);
+    }
+  }
+};
+
+TEST_F(IntegrationTestDevMgmtApiTraceCmds, getSpTraceBuffer) {
+  if (!FLAGS_enable_trace_dump) {
+    DV_LOG(INFO) << "Skipping the test since enable_trace_dump is set to false";
+    return;
+  }
+  setTraceControl(false /* Multiple devices */, device_mgmt_api::TRACE_CONTROL_TRACE_ENABLE);
+  setTraceConfigure(false /* Multiple devices */, device_mgmt_api::TRACE_CONFIGURE_EVENT_STRING,
+                    device_mgmt_api::TRACE_CONFIGURE_FILTER_MASK_EVENT_STRING_DEBUG);
+  setAndGetModuleStaticTDPLevel(false /* Multiple devices */);
+
+  /* Restore the logging level back */
+  setTraceConfigure(false /* Multiple devices */, device_mgmt_api::TRACE_CONFIGURE_EVENT_STRING,
+                    device_mgmt_api::TRACE_CONFIGURE_FILTER_MASK_EVENT_STRING_WARNING);
+
+  ASSERT_TRUE(extractAndPrintTraceData(false /* multiple devices */, TraceBufferType::TraceBufferSP));
+}
+
+TEST_F(IntegrationTestDevMgmtApiTraceCmds, getMmTraceBuffer) {
+  if (targetInList({Target::Silicon, Target::SysEMU})) {
+    /* Only verifying pulling of MM trace buffer from device, trace data validation is being done in firmware tests */
+    extractAndPrintTraceData(false /* multiple devices */, TraceBufferType::TraceBufferMM);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(IntegrationTestDevMgmtApiTraceCmds, getCmTraceBuffer) {
+  if (targetInList({Target::Silicon, Target::SysEMU})) {
+    /* Only verifying pulling of CM trace buffer from device, trace data validation is being done in firmware tests */
+    extractAndPrintTraceData(false /* multiple devices */, TraceBufferType::TraceBufferCM);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(IntegrationTestDevMgmtApiTraceCmds, getSPStatsTraceBuffer) {
+  if (targetInList({Target::Silicon, Target::SysEMU})) {
+    ASSERT_TRUE(extractAndPrintTraceData(false /* multiple devices */, TraceBufferType::TraceBufferSPStats));
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(IntegrationTestDevMgmtApiTraceCmds, dmStatsRunControl) {
+  if (targetInList({Target::Silicon})) {
+    dmStatsRunControl(false /* Multiple Devices */);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+int main(int argc, char** argv) {
+  google::InitGoogleLogging(argv[0]);
+  google::SetCommandLineOption("GLOG_minloglevel", "0");
+  FLAGS_minloglevel = 0;
+  FLAGS_logtostderr = 1;
+  testing::InitGoogleTest(&argc, argv);
+  google::ParseCommandLineFlags(&argc, &argv, true);
+  return RUN_ALL_TESTS();
+}
diff --git a/device-management/tests/mdi_debug/MDIApiTest.h b/device-management/tests/mdi_debug/MDIApiTest.h
new file mode 100644
index 00000000..44506b19
--- /dev/null
+++ b/device-management/tests/mdi_debug/MDIApiTest.h
@@ -0,0 +1,25 @@
+//******************************************************************************
+// Copyright (C) 2020 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#ifndef MDIAPITEST_H
+#define MDIAPITEST_H
+
+#define COMPUTE_KERNEL_DEVICE_ADDRESS 0x8005802000
+#define MM_FW_MASTER_SDATA_BASE 0x8001000000
+#define MDI_TEST_DEFAULT_SHIRE_ID 0
+#define MDI_TEST_DEFAULT_THREAD_MASK 0x1
+#define MDI_TEST_DEFAULT_HARTID 0
+#define MDI_TEST_GPR_WRITE_TEST_DATA 0xa5a5a5a512345678
+#define MDI_TEST_WRITE_MEM_TEST_DATA 0x12345678
+#define MDI_TEST_CSR_PC_REG 0x20
+#define MDI_TEST_CSR_WRITE_PC_TEST_ADDRESS 0x0000008005802040
+#define MDI_TEST_BP_ADDRESS_OFFSET 0x20
+
+#endif // MDIAPITEST_H
\ No newline at end of file
diff --git a/device-management/tests/mdi_debug/RunControlApiTestcmds.cpp b/device-management/tests/mdi_debug/RunControlApiTestcmds.cpp
new file mode 100644
index 00000000..d24a6433
--- /dev/null
+++ b/device-management/tests/mdi_debug/RunControlApiTestcmds.cpp
@@ -0,0 +1,58 @@
+//******************************************************************************
+// Copyright (C) 2021 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "MDIApiTest.h"
+#include "TestDevMgmtApiSyncCmds.h"
+#include <dlfcn.h>
+#include <glog/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace dev;
+using namespace device_management;
+
+class RunControlApiTestcmds : public TestDevMgmtApiSyncCmds {
+  void SetUp() override {
+    initDMTestFramework();
+  }
+  void TearDown() override {
+    cleanupDMTestFramework();
+  }
+};
+
+TEST_F(RunControlApiTestcmds, testRunControlCmdsSetandUnsetBreakpoint) {
+  if (targetInList({Target::Silicon, Target::SysEMU})) {
+    testRunControlCmdsSetandUnsetBreakpoint(MDI_TEST_DEFAULT_SHIRE_ID, MDI_TEST_DEFAULT_THREAD_MASK,
+                                            MDI_TEST_DEFAULT_HARTID,
+                                            (COMPUTE_KERNEL_DEVICE_ADDRESS + MDI_TEST_BP_ADDRESS_OFFSET));
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(RunControlApiTestcmds, testRunControlCmdsGetHartStatus) {
+  if (targetInList({Target::Silicon, Target::SysEMU})) {
+    testRunControlCmdsGetHartStatus(MDI_TEST_DEFAULT_SHIRE_ID, MDI_TEST_DEFAULT_THREAD_MASK, MDI_TEST_DEFAULT_HARTID);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+int main(int argc, char** argv) {
+  google::InitGoogleLogging(argv[0]);
+  google::SetCommandLineOption("GLOG_minloglevel", "0");
+  FLAGS_minloglevel = 0;
+  FLAGS_logtostderr = 1;
+  testing::InitGoogleTest(&argc, argv);
+  google::ParseCommandLineFlags(&argc, &argv, true);
+  return RUN_ALL_TESTS();
+}
diff --git a/device-management/tests/mdi_debug/StateInspectionApiTestcmds.cpp b/device-management/tests/mdi_debug/StateInspectionApiTestcmds.cpp
new file mode 100644
index 00000000..5eaa096a
--- /dev/null
+++ b/device-management/tests/mdi_debug/StateInspectionApiTestcmds.cpp
@@ -0,0 +1,115 @@
+//******************************************************************************
+// Copyright (C) 2021 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "MDIApiTest.h"
+#include "TestDevMgmtApiSyncCmds.h"
+#include <dlfcn.h>
+#include <glog/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace dev;
+using namespace device_management;
+
+class StateInspectionApiTestcmds : public TestDevMgmtApiSyncCmds {
+  void SetUp() override {
+    initDMTestFramework();
+  }
+  void TearDown() override {
+    cleanupDMTestFramework();
+  }
+};
+
+TEST_F(StateInspectionApiTestcmds, readMem_unprivileged) {
+  if (targetInList({Target::Silicon, Target::SysEMU})) {
+    readMem_unprivileged(COMPUTE_KERNEL_DEVICE_ADDRESS);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(StateInspectionApiTestcmds, readMem_privileged) {
+  if (targetInList({Target::Silicon, Target::SysEMU})) {
+    addToDevErrorEventSkipList({DevErrorEvent::EventType::SpCeEvent});
+    readMem_privileged(MM_FW_MASTER_SDATA_BASE);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(StateInspectionApiTestcmds, writeMem_unprivileged) {
+  if (targetInList({Target::Silicon, Target::SysEMU})) {
+    writeMem_unprivileged(MDI_TEST_WRITE_MEM_TEST_DATA, COMPUTE_KERNEL_DEVICE_ADDRESS);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(StateInspectionApiTestcmds, writeMem_privileged) {
+  if (targetInList({Target::Silicon, Target::SysEMU})) {
+    addToDevErrorEventSkipList({DevErrorEvent::EventType::SpCeEvent});
+    writeMem_privileged(MDI_TEST_WRITE_MEM_TEST_DATA, MM_FW_MASTER_SDATA_BASE);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(StateInspectionApiTestcmds, testStateInspectionReadGPR) {
+  if (targetInList({Target::Silicon, Target::SysEMU})) {
+    testStateInspectionReadGPR(MDI_TEST_DEFAULT_SHIRE_ID, MDI_TEST_DEFAULT_THREAD_MASK, MDI_TEST_DEFAULT_HARTID);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(StateInspectionApiTestcmds, testStateInspectionWriteGPR) {
+  if (targetInList({Target::Silicon, Target::SysEMU})) {
+    testStateInspectionWriteGPR(MDI_TEST_DEFAULT_SHIRE_ID, MDI_TEST_DEFAULT_THREAD_MASK, MDI_TEST_DEFAULT_HARTID,
+                                MDI_TEST_GPR_WRITE_TEST_DATA);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(StateInspectionApiTestcmds, testStateInspectionReadCSR) {
+  if (targetInList({Target::Silicon, Target::SysEMU})) {
+    testStateInspectionReadCSR(MDI_TEST_DEFAULT_SHIRE_ID, MDI_TEST_DEFAULT_THREAD_MASK, MDI_TEST_DEFAULT_HARTID,
+                               MDI_TEST_CSR_PC_REG);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(StateInspectionApiTestcmds, testStateInspectionWriteCSR) {
+  if (targetInList({Target::Silicon, Target::SysEMU})) {
+    testStateInspectionWriteCSR(MDI_TEST_DEFAULT_SHIRE_ID, MDI_TEST_DEFAULT_THREAD_MASK, MDI_TEST_DEFAULT_HARTID,
+                                MDI_TEST_CSR_PC_REG, MDI_TEST_CSR_WRITE_PC_TEST_ADDRESS);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+int main(int argc, char** argv) {
+  google::InitGoogleLogging(argv[0]);
+  google::SetCommandLineOption("GLOG_minloglevel", "0");
+  FLAGS_minloglevel = 0;
+  FLAGS_logtostderr = 1;
+  testing::InitGoogleTest(&argc, argv);
+  google::ParseCommandLineFlags(&argc, &argv, true);
+  return RUN_ALL_TESTS();
+}
diff --git a/device-management/tests/mix/MixTestDevMgmtApiAllCmds.sh.in b/device-management/tests/mix/MixTestDevMgmtApiAllCmds.sh.in
new file mode 100755
index 00000000..e6842d83
--- /dev/null
+++ b/device-management/tests/mix/MixTestDevMgmtApiAllCmds.sh.in
@@ -0,0 +1,50 @@
+#!/bin/bash
+
+#------------------------------------------------------------------------------
+# Copyright (C) 2021, Esperanto Technologies Inc.
+# The copyright to the computer program(s) herein is the
+# property of Esperanto Technologies, Inc. All Rights Reserved.
+# The program(s) may be used and/or copied only with
+# the written permission of Esperanto Technologies and
+# in accordance with the terms and conditions stipulated in the
+# agreement/contract under which the program(s) have been supplied.
+#------------------------------------------------------------------------------
+
+RUN_DIR=@CMAKE_CURRENT_BINARY_DIR@
+cd $RUN_DIR
+
+## Checking environment variables
+if [ -z "$DURATION" ]; then
+    ## Default test duration
+    DURATION="5minute"
+fi
+echo "$0: Tests duration is $DURATION"
+
+if [ -n "$VERBOSE" ]; then
+    VERBOSE="-V"
+fi
+
+labels="FUNCTIONAL|SECURITY|INTEGRATION|OPS_NODE_DEPENDENT"
+mgmt_tests=($(ctest -L $labels -E "RunControlApiTestcmds|StateInspectionApiTestcmds" -N | awk '$2 ~ /#[0-9]+:/ && $4 !~ /Disabled/ {print $3}'))
+mgmt_tests_count=${#mgmt_tests[@]}
+if [[ $mgmt_tests_count -eq 0 ]]; then
+    exit 1
+fi
+
+## save logs for one test and print at once. This will be helpful when
+## mgmt and ops tests be executed in parallel
+mgmt_tests_logfile=$(mktemp)
+mgmt_tests_endtime=$(date -ud "$DURATION" +%s)
+while [[ $(date -u +%s) -le $mgmt_tests_endtime ]]
+do
+    mgmt_exec_idx=$(($RANDOM % $mgmt_tests_count))
+    echo "Running ${mgmt_tests[$mgmt_exec_idx]}"
+    TARGET=${TARGET} PARALLEL=1 ctest -L $labels -R "^${mgmt_tests[$mgmt_exec_idx]}$" ${VERBOSE} --output-on-failure > $mgmt_tests_logfile
+    mgmt_tests_rv=$?
+    cat $mgmt_tests_logfile | tail -n +2 | head -n -7
+    if [ $mgmt_tests_rv -ne 0 ]; then
+        rm $mgmt_tests_logfile
+        exit $mgmt_tests_rv
+    fi
+done
+rm $mgmt_tests_logfile
diff --git a/device-management/tests/opsNodeDependent/OpsNodeDependentTestDevMgmtApiFirmwareMgmtCmds.cpp b/device-management/tests/opsNodeDependent/OpsNodeDependentTestDevMgmtApiFirmwareMgmtCmds.cpp
new file mode 100644
index 00000000..509b3ac9
--- /dev/null
+++ b/device-management/tests/opsNodeDependent/OpsNodeDependentTestDevMgmtApiFirmwareMgmtCmds.cpp
@@ -0,0 +1,88 @@
+//******************************************************************************
+// Copyright (C) 2020 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "TestDevMgmtApiSyncCmds.h"
+#include <dlfcn.h>
+#include <glog/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace dev;
+using namespace device_management;
+
+class OpsNodeDependentTestDevMgmtApiFirmwareMgmtCmds : public TestDevMgmtApiSyncCmds {
+  void SetUp() override {
+    handle_ = dlopen("libDM.so", RTLD_LAZY);
+    ASSERT_NE(handle_, nullptr);
+  }
+  void TearDown() override {
+    cleanupEventProcessor();
+    if (handle_ != nullptr) {
+      dlclose(handle_);
+    }
+  }
+};
+
+TEST_F(OpsNodeDependentTestDevMgmtApiFirmwareMgmtCmds, resetMM) {
+  if (isParallelRun()) {
+    DV_LOG(INFO) << "Skipping the test since it cannot be run in parallel with ops device";
+    return;
+  }
+  if (targetInList({Target::FullBoot, Target::FullChip, Target::Bemu, Target::Silicon})) {
+    devLayer_ = IDeviceLayer::createPcieDeviceLayer(false, true);
+    ASSERT_NE(devLayer_, nullptr);
+    initTestTrace();
+    controlTraceLogging();
+    resetMM(false);
+    extractAndPrintTraceData(false /* multiple devices */, TraceBufferType::TraceBufferSP);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+  }
+}
+
+TEST_F(OpsNodeDependentTestDevMgmtApiFirmwareMgmtCmds, resetMMWithOpsInUse) {
+  if (isParallelRun()) {
+    DV_LOG(INFO) << "Skipping the test since it cannot be run in parallel with ops device";
+    return;
+  }
+  if (targetInList({Target::FullBoot, Target::FullChip, Target::Bemu, Target::Silicon})) {
+    devLayer_ = IDeviceLayer::createPcieDeviceLayer(true, true);
+    ASSERT_NE(devLayer_, nullptr);
+    initTestTrace();
+    controlTraceLogging();
+    resetMMWithOpsInUse(false);
+    extractAndPrintTraceData(false /* multiple devices */, TraceBufferType::TraceBufferSP);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+  }
+}
+
+TEST_F(OpsNodeDependentTestDevMgmtApiFirmwareMgmtCmds, resetSOCSWithOpsInUse) {
+  if (isParallelRun()) {
+    DV_LOG(INFO) << "Skipping the test since it cannot be run in parallel with ops device";
+    return;
+  }
+  devLayer_ = IDeviceLayer::createPcieDeviceLayer(true, true);
+  ASSERT_NE(devLayer_, nullptr);
+  initTestTrace();
+  controlTraceLogging();
+  resetSOCWithOpsInUse(false);
+  extractAndPrintTraceData(false /* multiple devices */, TraceBufferType::TraceBufferSP);
+}
+
+int main(int argc, char** argv) {
+  google::InitGoogleLogging(argv[0]);
+  google::SetCommandLineOption("GLOG_minloglevel", "0");
+  FLAGS_minloglevel = 0;
+  FLAGS_logtostderr = 1;
+  testing::InitGoogleTest(&argc, argv);
+  google::ParseCommandLineFlags(&argc, &argv, true);
+  return RUN_ALL_TESTS();
+}
diff --git a/device-management/tests/opsNodeDependent/OpsNodeDependentTestDevMgmtApiTraceCmds.cpp b/device-management/tests/opsNodeDependent/OpsNodeDependentTestDevMgmtApiTraceCmds.cpp
new file mode 100644
index 00000000..a8f1e9d2
--- /dev/null
+++ b/device-management/tests/opsNodeDependent/OpsNodeDependentTestDevMgmtApiTraceCmds.cpp
@@ -0,0 +1,47 @@
+//******************************************************************************
+// Copyright (C) 2020 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "TestDevMgmtApiSyncCmds.h"
+#include <dlfcn.h>
+#include <glog/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace dev;
+using namespace device_management;
+
+class OpsNodeDependentTestDevMgmtApiTraceCmds : public TestDevMgmtApiSyncCmds {
+  void SetUp() override {
+    initDMTestFramework();
+  }
+  void TearDown() override {
+    cleanupDMTestFramework();
+  }
+};
+
+TEST_F(OpsNodeDependentTestDevMgmtApiTraceCmds, getMMStatsTraceBuffer) {
+  if (targetInList({Target::Silicon, Target::SysEMU})) {
+    /* Only verifying pulling of CM trace buffer from device, trace data validation is being done in firmware tests */
+    ASSERT_TRUE(extractAndPrintTraceData(false /* multiple devices */, TraceBufferType::TraceBufferMMStats));
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+int main(int argc, char** argv) {
+  google::InitGoogleLogging(argv[0]);
+  google::SetCommandLineOption("GLOG_minloglevel", "0");
+  FLAGS_minloglevel = 0;
+  FLAGS_logtostderr = 1;
+  testing::InitGoogleTest(&argc, argv);
+  google::ParseCommandLineFlags(&argc, &argv, true);
+  return RUN_ALL_TESTS();
+}
diff --git a/device-management/tests/security/SecurityTestDevMgmtApiAssetTrackingCmds.cpp b/device-management/tests/security/SecurityTestDevMgmtApiAssetTrackingCmds.cpp
new file mode 100644
index 00000000..2b08668a
--- /dev/null
+++ b/device-management/tests/security/SecurityTestDevMgmtApiAssetTrackingCmds.cpp
@@ -0,0 +1,57 @@
+//******************************************************************************
+// Copyright (C) 2020 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "TestDevMgmtApiSyncCmds.h"
+#include <dlfcn.h>
+#include <glog/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace dev;
+using namespace device_management;
+
+class SecurityTestDevMgmtApiAssetTrackingCmds : public TestDevMgmtApiSyncCmds {
+  void SetUp() override {
+    initDMTestFramework();
+  }
+  void TearDown() override {
+    cleanupDMTestFramework();
+  }
+};
+
+TEST_F(SecurityTestDevMgmtApiAssetTrackingCmds, getModuleManufactureNameInvalidOutputSize) {
+  getModuleManufactureNameInvalidOutputSize(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiAssetTrackingCmds, getModuleManufactureNameInvalidDeviceNode) {
+  getModuleManufactureNameInvalidDeviceNode(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiAssetTrackingCmds, getModuleManufactureNameInvalidHostLatency) {
+  getModuleManufactureNameInvalidHostLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiAssetTrackingCmds, getModuleManufactureNameInvalidDeviceLatency) {
+  getModuleManufactureNameInvalidDeviceLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiAssetTrackingCmds, getModuleManufactureNameInvalidOutputBuffer) {
+  getModuleManufactureNameInvalidOutputBuffer(false /* Multiple Devices */);
+}
+
+int main(int argc, char** argv) {
+  google::InitGoogleLogging(argv[0]);
+  google::SetCommandLineOption("GLOG_minloglevel", "0");
+  FLAGS_minloglevel = 0;
+  FLAGS_logtostderr = 1;
+  testing::InitGoogleTest(&argc, argv);
+  google::ParseCommandLineFlags(&argc, &argv, true);
+  return RUN_ALL_TESTS();
+}
diff --git a/device-management/tests/security/SecurityTestDevMgmtApiErrorControlCmds.cpp b/device-management/tests/security/SecurityTestDevMgmtApiErrorControlCmds.cpp
new file mode 100644
index 00000000..40fd621b
--- /dev/null
+++ b/device-management/tests/security/SecurityTestDevMgmtApiErrorControlCmds.cpp
@@ -0,0 +1,121 @@
+//******************************************************************************
+// Copyright (C) 2020 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "TestDevMgmtApiSyncCmds.h"
+#include <dlfcn.h>
+#include <glog/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace dev;
+using namespace device_management;
+
+class SecurityTestDevMgmtApiErrorControlCmds : public TestDevMgmtApiSyncCmds {
+  void SetUp() override {
+    initDMTestFramework();
+  }
+  void TearDown() override {
+    cleanupDMTestFramework();
+  }
+};
+
+TEST_F(SecurityTestDevMgmtApiErrorControlCmds, setDDRECCCountInvalidInputBuffer) {
+  setDDRECCCountInvalidInputBuffer(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiErrorControlCmds, setDDRECCCountInvalidInputSize) {
+  setDDRECCCountInvalidInputSize(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiErrorControlCmds, setDDRECCCountInvalidOutputSize) {
+  setDDRECCCountInvalidOutputSize(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiErrorControlCmds, setDDRECCCountInvalidDeviceNode) {
+  setDDRECCCountInvalidDeviceNode(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiErrorControlCmds, setDDRECCCountInvalidHostLatency) {
+  setDDRECCCountInvalidHostLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiErrorControlCmds, setDDRECCCountInvalidDeviceLatency) {
+  setDDRECCCountInvalidDeviceLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiErrorControlCmds, setDDRECCCountInvalidOutputBuffer) {
+  setDDRECCCountInvalidOutputBuffer(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiErrorControlCmds, setPCIEECCCountInvalidInputBuffer) {
+  setPCIEECCCountInvalidInputBuffer(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiErrorControlCmds, setPCIEECCountInvalidInputSize) {
+  setPCIEECCountInvalidInputSize(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiErrorControlCmds, setPCIEECCountInvalidOutputSize) {
+  setPCIEECCountInvalidOutputSize(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiErrorControlCmds, setPCIEECCountInvalidDeviceNode) {
+  setPCIEECCountInvalidDeviceNode(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiErrorControlCmds, setPCIEECCountInvalidHostLatency) {
+  setPCIEECCountInvalidHostLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiErrorControlCmds, setPCIEECCountInvalidDeviceLatency) {
+  setPCIEECCountInvalidDeviceLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiErrorControlCmds, setPCIEECCountInvalidOutputBuffer) {
+  setPCIEECCountInvalidOutputBuffer(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiErrorControlCmds, setSRAMECCCountInvalidInputBuffer) {
+  setSRAMECCCountInvalidInputBuffer(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiErrorControlCmds, setSRAMECCCountInvalidInputSize) {
+  setSRAMECCCountInvalidInputSize(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiErrorControlCmds, setSRAMECCountInvalidOutputSize) {
+  setSRAMECCountInvalidOutputSize(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiErrorControlCmds, setSRAMECCountInvalidDeviceNode) {
+  setSRAMECCountInvalidDeviceNode(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiErrorControlCmds, setSRAMECCountInvalidHostLatency) {
+  setSRAMECCountInvalidHostLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiErrorControlCmds, setSRAMECCountInvalidDeviceLatency) {
+  setSRAMECCountInvalidDeviceLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiErrorControlCmds, setSRAMECCountInvalidOutputBuffer) {
+  setSRAMECCountInvalidOutputBuffer(false /* Multiple Devices */);
+}
+
+int main(int argc, char** argv) {
+  google::InitGoogleLogging(argv[0]);
+  google::SetCommandLineOption("GLOG_minloglevel", "0");
+  FLAGS_minloglevel = 0;
+  FLAGS_logtostderr = 1;
+  testing::InitGoogleTest(&argc, argv);
+  google::ParseCommandLineFlags(&argc, &argv, true);
+  return RUN_ALL_TESTS();
+}
diff --git a/device-management/tests/security/SecurityTestDevMgmtApiGenericCmds.cpp b/device-management/tests/security/SecurityTestDevMgmtApiGenericCmds.cpp
new file mode 100644
index 00000000..e939e6f3
--- /dev/null
+++ b/device-management/tests/security/SecurityTestDevMgmtApiGenericCmds.cpp
@@ -0,0 +1,45 @@
+//******************************************************************************
+// Copyright (C) 2020 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "TestDevMgmtApiSyncCmds.h"
+#include <dlfcn.h>
+#include <glog/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace dev;
+using namespace device_management;
+
+class SecurityTestDevMgmtApiGenericCmds : public TestDevMgmtApiSyncCmds {
+  void SetUp() override {
+    initDMTestFramework();
+  }
+  void TearDown() override {
+    cleanupDMTestFramework();
+  }
+};
+
+TEST_F(SecurityTestDevMgmtApiGenericCmds, isUnsupportedService) {
+  isUnsupportedService(false /* Multiple devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiGenericCmds, testInvalidCmdCode) {
+  testInvalidCmdCode(false /* Multiple Devices */);
+}
+
+int main(int argc, char** argv) {
+  google::InitGoogleLogging(argv[0]);
+  google::SetCommandLineOption("GLOG_minloglevel", "0");
+  FLAGS_minloglevel = 0;
+  FLAGS_logtostderr = 1;
+  testing::InitGoogleTest(&argc, argv);
+  google::ParseCommandLineFlags(&argc, &argv, true);
+  return RUN_ALL_TESTS();
+}
diff --git a/device-management/tests/security/SecurityTestDevMgmtApiHistoricalExtremeValCmds.cpp b/device-management/tests/security/SecurityTestDevMgmtApiHistoricalExtremeValCmds.cpp
new file mode 100644
index 00000000..53bba931
--- /dev/null
+++ b/device-management/tests/security/SecurityTestDevMgmtApiHistoricalExtremeValCmds.cpp
@@ -0,0 +1,57 @@
+//******************************************************************************
+// Copyright (C) 2020 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "TestDevMgmtApiSyncCmds.h"
+#include <dlfcn.h>
+#include <glog/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace dev;
+using namespace device_management;
+
+class SecurityTestDevMgmtApiHistoricalExtremeValCmds : public TestDevMgmtApiSyncCmds {
+  void SetUp() override {
+    initDMTestFramework();
+  }
+  void TearDown() override {
+    cleanupDMTestFramework();
+  }
+};
+
+TEST_F(SecurityTestDevMgmtApiHistoricalExtremeValCmds, getHistoricalExtremeWithInvalidDeviceNode) {
+  getHistoricalExtremeWithInvalidDeviceNode(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiHistoricalExtremeValCmds, getHistoricalExtremeWithInvalidHostLatency) {
+  getHistoricalExtremeWithInvalidHostLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiHistoricalExtremeValCmds, getHistoricalExtremeWithInvalidDeviceLatency) {
+  getHistoricalExtremeWithInvalidDeviceLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiHistoricalExtremeValCmds, getHistoricalExtremeWithInvalidOutputBuffer) {
+  getHistoricalExtremeWithInvalidOutputBuffer(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiHistoricalExtremeValCmds, getHistoricalExtremeWithInvalidOutputSize) {
+  getHistoricalExtremeWithInvalidOutputSize(false /* Multiple Devices */);
+}
+
+int main(int argc, char** argv) {
+  google::InitGoogleLogging(argv[0]);
+  google::SetCommandLineOption("GLOG_minloglevel", "0");
+  FLAGS_minloglevel = 0;
+  FLAGS_logtostderr = 1;
+  testing::InitGoogleTest(&argc, argv);
+  google::ParseCommandLineFlags(&argc, &argv, true);
+  return RUN_ALL_TESTS();
+}
diff --git a/device-management/tests/security/SecurityTestDevMgmtApiLinkMgmtCmds.cpp b/device-management/tests/security/SecurityTestDevMgmtApiLinkMgmtCmds.cpp
new file mode 100644
index 00000000..f6534c73
--- /dev/null
+++ b/device-management/tests/security/SecurityTestDevMgmtApiLinkMgmtCmds.cpp
@@ -0,0 +1,45 @@
+//******************************************************************************
+// Copyright (C) 2020 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "TestDevMgmtApiSyncCmds.h"
+#include <dlfcn.h>
+#include <glog/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace dev;
+using namespace device_management;
+
+class SecurityTestDevMgmtApiLinkMgmtCmds : public TestDevMgmtApiSyncCmds {
+  void SetUp() override {
+    initDMTestFramework();
+  }
+  void TearDown() override {
+    cleanupDMTestFramework();
+  }
+};
+
+TEST_F(SecurityTestDevMgmtApiLinkMgmtCmds, setPCIELinkSpeedToInvalidLinkSpeed) {
+  setPCIELinkSpeedToInvalidLinkSpeed(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiLinkMgmtCmds, setPCIELaneWidthToInvalidLaneWidth) {
+  setPCIELaneWidthToInvalidLaneWidth(false /* Multiple Devices */);
+}
+
+int main(int argc, char** argv) {
+  google::InitGoogleLogging(argv[0]);
+  google::SetCommandLineOption("GLOG_minloglevel", "0");
+  FLAGS_minloglevel = 0;
+  FLAGS_logtostderr = 1;
+  testing::InitGoogleTest(&argc, argv);
+  google::ParseCommandLineFlags(&argc, &argv, true);
+  return RUN_ALL_TESTS();
+}
diff --git a/device-management/tests/security/SecurityTestDevMgmtApiPerfMgmtCmds.cpp b/device-management/tests/security/SecurityTestDevMgmtApiPerfMgmtCmds.cpp
new file mode 100644
index 00000000..a33bd6f5
--- /dev/null
+++ b/device-management/tests/security/SecurityTestDevMgmtApiPerfMgmtCmds.cpp
@@ -0,0 +1,177 @@
+//******************************************************************************
+// Copyright (C) 2020 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "TestDevMgmtApiSyncCmds.h"
+#include <dlfcn.h>
+#include <glog/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace dev;
+using namespace device_management;
+
+class SecurityTestDevMgmtApiPerfMgmtCmds : public TestDevMgmtApiSyncCmds {
+  void SetUp() override {
+    initDMTestFramework();
+  }
+  void TearDown() override {
+    cleanupDMTestFramework();
+  }
+};
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICFrequenciesInvalidOutputSize) {
+  getASICFrequenciesInvalidOutputSize(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICFrequenciesInvalidDeviceNode) {
+  getASICFrequenciesInvalidDeviceNode(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICFrequenciesInvalidHostLatency) {
+  getASICFrequenciesInvalidHostLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICFrequenciesInvalidDeviceLatency) {
+  getASICFrequenciesInvalidDeviceLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICFrequenciesInvalidOutputBuffer) {
+  getASICFrequenciesInvalidOutputBuffer(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getDRAMBandwidthInvalidOutputSize) {
+  getDRAMBandwidthInvalidOutputSize(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getDRAMBandwidthInvalidDeviceNode) {
+  getDRAMBandwidthInvalidDeviceNode(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getDRAMBandwidthInvalidHostLatency) {
+  getDRAMBandwidthInvalidHostLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getDRAMBandwidthInvalidDeviceLatency) {
+  getDRAMBandwidthInvalidDeviceLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getDRAMBandwidthInvalidOutputBuffer) {
+  getDRAMBandwidthInvalidOutputBuffer(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getDRAMCapacityUtilizationInvalidOutputSize) {
+  getDRAMCapacityUtilizationInvalidOutputSize(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getDRAMCapacityUtilizationInvalidDeviceNode) {
+  getDRAMCapacityUtilizationInvalidDeviceNode(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getDRAMCapacityUtilizationInvalidHostLatency) {
+  getDRAMCapacityUtilizationInvalidHostLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getDRAMCapacityUtilizationInvalidDeviceLatency) {
+  getDRAMCapacityUtilizationInvalidDeviceLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getDRAMCapacityUtilizationInvalidOutputBuffer) {
+  getDRAMCapacityUtilizationInvalidOutputBuffer(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICPerCoreDatapathUtilizationInvalidOutputSize) {
+  getASICPerCoreDatapathUtilizationInvalidOutputSize(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICPerCoreDatapathUtilizationInvalidDeviceNode) {
+  getASICPerCoreDatapathUtilizationInvalidDeviceNode(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICPerCoreDatapathUtilizationInvalidHostLatency) {
+  getASICPerCoreDatapathUtilizationInvalidHostLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICPerCoreDatapathUtilizationInvalidDeviceLatency) {
+  getASICPerCoreDatapathUtilizationInvalidDeviceLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICPerCoreDatapathUtilizationInvalidOutputBuffer) {
+  getASICPerCoreDatapathUtilizationInvalidOutputBuffer(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICUtilizationInvalidOutputSize) {
+  getASICUtilizationInvalidOutputSize(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICUtilizationInvalidDeviceNode) {
+  getASICUtilizationInvalidDeviceNode(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICUtilizationInvalidHostLatency) {
+  getASICUtilizationInvalidHostLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICUtilizationInvalidDeviceLatency) {
+  getASICUtilizationInvalidDeviceLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICUtilizationInvalidOutputBuffer) {
+  getASICUtilizationInvalidOutputBuffer(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICStallsInvalidOutputSize) {
+  getASICStallsInvalidOutputSize(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICStallsInvalidDeviceNode) {
+  getASICStallsInvalidDeviceNode(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICStallsInvalidHostLatency) {
+  getASICStallsInvalidHostLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICStallsInvalidDeviceLatency) {
+  getASICStallsInvalidDeviceLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICStallsInvalidOutputBuffer) {
+  getASICStallsInvalidOutputBuffer(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICLatencyInvalidOutputSize) {
+  getASICLatencyInvalidOutputSize(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICLatencyInvalidDeviceNode) {
+  getASICLatencyInvalidDeviceNode(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICLatencyInvalidHostLatency) {
+  getASICLatencyInvalidHostLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICLatencyInvalidDeviceLatency) {
+  getASICLatencyInvalidDeviceLatency(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiPerfMgmtCmds, getASICLatencyInvalidOutputBuffer) {
+  getASICLatencyInvalidOutputBuffer(false /* Multiple Devices */);
+}
+
+int main(int argc, char** argv) {
+  google::InitGoogleLogging(argv[0]);
+  google::SetCommandLineOption("GLOG_minloglevel", "0");
+  FLAGS_minloglevel = 0;
+  FLAGS_logtostderr = 1;
+  testing::InitGoogleTest(&argc, argv);
+  google::ParseCommandLineFlags(&argc, &argv, true);
+  return RUN_ALL_TESTS();
+}
diff --git a/device-management/tests/security/SecurityTestDevMgmtApiThermalAndPowerMonitoringCmds.cpp b/device-management/tests/security/SecurityTestDevMgmtApiThermalAndPowerMonitoringCmds.cpp
new file mode 100644
index 00000000..0f83d6a3
--- /dev/null
+++ b/device-management/tests/security/SecurityTestDevMgmtApiThermalAndPowerMonitoringCmds.cpp
@@ -0,0 +1,49 @@
+//******************************************************************************
+// Copyright (C) 2020 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "TestDevMgmtApiSyncCmds.h"
+#include <dlfcn.h>
+#include <glog/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace dev;
+using namespace device_management;
+
+class SecurityTestDevMgmtApiThermalAndPowerMonitoringCmds : public TestDevMgmtApiSyncCmds {
+  void SetUp() override {
+    initDMTestFramework();
+  }
+  void TearDown() override {
+    cleanupDMTestFramework();
+  }
+};
+
+TEST_F(SecurityTestDevMgmtApiThermalAndPowerMonitoringCmds, setModuleActivePowerManagementRange) {
+  setModuleActivePowerManagementRange(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiThermalAndPowerMonitoringCmds, setModuleActivePowerManagementRangeInvalidInputSize) {
+  setModuleActivePowerManagementRangeInvalidInputSize(false /* Multiple Devices */);
+}
+
+TEST_F(SecurityTestDevMgmtApiThermalAndPowerMonitoringCmds, setModuleActivePowerManagementRangeInvalidInputBuffer) {
+  setModuleActivePowerManagementRangeInvalidInputBuffer(false /* Multiple Devices */);
+}
+
+int main(int argc, char** argv) {
+  google::InitGoogleLogging(argv[0]);
+  google::SetCommandLineOption("GLOG_minloglevel", "0");
+  FLAGS_minloglevel = 0;
+  FLAGS_logtostderr = 1;
+  testing::InitGoogleTest(&argc, argv);
+  google::ParseCommandLineFlags(&argc, &argv, true);
+  return RUN_ALL_TESTS();
+}
diff --git a/device-management/tests/stress/StressTestDevMgmtApiFirmwareMgmtCmds.cpp b/device-management/tests/stress/StressTestDevMgmtApiFirmwareMgmtCmds.cpp
new file mode 100644
index 00000000..dad82d4b
--- /dev/null
+++ b/device-management/tests/stress/StressTestDevMgmtApiFirmwareMgmtCmds.cpp
@@ -0,0 +1,151 @@
+//******************************************************************************
+// Copyright (C) 2022 Esperanto Technologies Inc.
+// The copyright to the computer program(s) herein is the
+// property of Esperanto Technologies, Inc. All Rights Reserved.
+// The program(s) may be used and/or copied only with
+// the written permission of Esperanto Technologies and
+// in accordance with the terms and conditions stipulated in the
+// agreement/contract under which the program(s) have been supplied.
+//------------------------------------------------------------------------------
+
+#include "TestDevMgmtApiSyncCmds.h"
+#include <dlfcn.h>
+#include <glog/logging.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace dev;
+using namespace device_management;
+
+class StressTestDevMgmtApiFirmwareMgmtCmds : public TestDevMgmtApiSyncCmds {
+  void SetUp() override {
+    handle_ = dlopen("libDM.so", RTLD_LAZY);
+    ASSERT_NE(handle_, nullptr);
+    devLayer_ = IDeviceLayer::createPcieDeviceLayer(false, true);
+    ASSERT_NE(devLayer_, nullptr);
+    initTestTrace();
+    controlTraceLogging();
+    // NOTE: DM Event processor cannot run during ETSOC reset
+    // TODO: SW-18858: Add support to stop and restart event processor for ETSOC
+    // reset keeping the option to run the event processor threads in detach mode
+  }
+  void TearDown() override {
+    if (handle_ != nullptr) {
+      dlclose(handle_);
+    }
+  }
+};
+
+/* TODO: SW-19075: Re-enable once issue is resolved */
+TEST_F(StressTestDevMgmtApiFirmwareMgmtCmds, DISABLED_backToBackUpdateFirmwareImageSingleDevice) {
+  if (targetInList({Target::FullBoot, Target::Silicon})) {
+    if (isParallelRun()) {
+      DV_LOG(INFO) << "Skipping the test since it cannot be run in parallel with ops device";
+      FLAGS_enable_trace_dump = false;
+      return;
+    }
+    initEventProcessor();
+    setFirmwareUpdateImage(true /* Single Device */, false, 4);
+    cleanupEventProcessor();
+    extractAndPrintTraceData(true /* Single Device */, TraceBufferType::TraceBufferSP);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+/* TODO: SW-19075: Re-enable once issue is resolved */
+TEST_F(StressTestDevMgmtApiFirmwareMgmtCmds, DISABLED_backToBackUpdateFirmwareImageMultiDevice) {
+  if (targetInList({Target::FullBoot, Target::Silicon})) {
+    if (isParallelRun()) {
+      DV_LOG(INFO) << "Skipping the test since it cannot be run in parallel with ops device";
+      FLAGS_enable_trace_dump = false;
+      return;
+    }
+    initEventProcessor();
+    int iterations = 4 / devLayer_->getDevicesCount();
+    iterations = iterations ? iterations : 1;
+    setFirmwareUpdateImage(false /* Multiple Devices */, false, iterations);
+    cleanupEventProcessor();
+    extractAndPrintTraceData(false /* Multiple Devices */, TraceBufferType::TraceBufferSP);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(StressTestDevMgmtApiFirmwareMgmtCmds, DISABLED_backToBackUpdateFirmwareImageAndResetSingleDevice) {
+  if (targetInList({Target::FullBoot, Target::Silicon})) {
+    if (isParallelRun()) {
+      DV_LOG(INFO) << "Skipping the test since it cannot be run in parallel with ops device";
+      FLAGS_enable_trace_dump = false;
+      return;
+    }
+    initEventProcessor();
+    setFirmwareUpdateImage(true /* Single Device */, true, 4);
+    cleanupEventProcessor();
+    extractAndPrintTraceData(true /* Single Device */, TraceBufferType::TraceBufferSP);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(StressTestDevMgmtApiFirmwareMgmtCmds, DISABLED_backToBackUpdateFirmwareImageAndResetMultiDevice) {
+  if (targetInList({Target::FullBoot, Target::Silicon})) {
+    if (isParallelRun()) {
+      DV_LOG(INFO) << "Skipping the test since it cannot be run in parallel with ops device";
+      FLAGS_enable_trace_dump = false;
+      return;
+    }
+    initEventProcessor();
+    int iterations = 4 / devLayer_->getDevicesCount();
+    iterations = iterations ? iterations : 1;
+    setFirmwareUpdateImage(false /* Multiple Devices */, true, iterations);
+    cleanupEventProcessor();
+    extractAndPrintTraceData(false /* Multiple Devices */, TraceBufferType::TraceBufferSP);
+  } else {
+    DV_LOG(INFO) << "Skipping the test since its not supported on current target";
+    FLAGS_enable_trace_dump = false;
+  }
+}
+
+TEST_F(StressTestDevMgmtApiFirmwareMgmtCmds, backToBackResetSOCSingleDevice) {
+  if (isParallelRun()) {
+    DV_LOG(INFO) << "Skipping the test since it cannot be run in parallel with ops device";
+    return;
+  }
+  auto iteration = getTestTarget() == Target::Loopback ? 30 : 10;
+  for (int i = 0; i < iteration; i++) {
+    resetSOC(true /* Single Device */);
+  }
+  extractAndPrintTraceData(true /* Single Device */, TraceBufferType::TraceBufferSP);
+}
+
+TEST_F(StressTestDevMgmtApiFirmwareMgmtCmds, backToBackResetSOCMultiDevice) {
+  if (isParallelRun()) {
+    DV_LOG(INFO) << "Skipping the test since it cannot be run in parallel with ops device";
+    return;
+  }
+
+  if (devLayer_->getDevicesCount() <= 1) {
+    DV_LOG(INFO) << "Skipping the test since this is multi device test";
+    return;
+  }
+
+  auto iteration = (getTestTarget() == Target::Loopback ? 30 : 10) / devLayer_->getDevicesCount();
+  for (int i = 0; i < iteration; i++) {
+    resetSOC(false /* Multiple Devices */);
+  }
+  extractAndPrintTraceData(false /* Multiple Devices */, TraceBufferType::TraceBufferSP);
+}
+
+int main(int argc, char** argv) {
+  google::InitGoogleLogging(argv[0]);
+  google::SetCommandLineOption("GLOG_minloglevel", "0");
+  FLAGS_minloglevel = 0;
+  FLAGS_logtostderr = 1;
+  testing::InitGoogleTest(&argc, argv);
+  google::ParseCommandLineFlags(&argc, &argv, true);
+  return RUN_ALL_TESTS();
+}
diff --git a/device-management/tests/test-plan-system.ods b/device-management/tests/test-plan-system.ods
new file mode 100644
index 00000000..86b61803
Binary files /dev/null and b/device-management/tests/test-plan-system.ods differ
